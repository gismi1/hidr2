ARCHIVOS DE CABECERA: PLEDERCurvaNumeroDlg.h #pragma once #include "resource.h" // Cuadro de diálogo de CPLEDERCurvaNumeroDlg class CPLEDERCurvaNumeroDlg : public CAdUiDialog { DECLARE_DYNAMIC(CPLEDERCurvaNumeroDlg) public: CPLEDERCurvaNumeroDlg(CWnd *pParent =NULL, HINSTANCE hInstance =NULL); // Constructor estándar virtual ~CPLEDERCurvaNumeroDlg(); // Datos del cuadro de diálogo enum { IDD = IDD_HIDRO_PLCN }; //Declaramos variables del cuadro de diálogo. // Cajas de texto CAcUiNumericEdit m_Edit_AREA1; CString m_a1; CAcUiNumericEdit m_Edit_CN1; CString m_cn1; CAcUiNumericEdit m_Edit_AREA2; CString m_a2; CAcUiNumericEdit m_Edit_CN2; CString m_cn2; CAcUiNumericEdit m_Edit_AREA3; CString m_a3; CAcUiNumericEdit m_Edit_CN3; CString m_cn3; CAcUiNumericEdit m_Edit_AREA4; CString m_a4; CAcUiNumericEdit m_Edit_CN4; CString m_cn4; CAcUiNumericEdit m_Edit_AREA5; CString m_a5; CAcUiNumericEdit m_Edit_CN5; CString m_cn5; CAcUiNumericEdit m_Edit_AREA6; CString m_a6; CAcUiNumericEdit m_Edit_CN6; CString m_cn6; CAcUiNumericEdit m_Edit_CNC; CString m_cnc; protected: virtual void DoDataExchange(CDataExchange* pDX); afx_msg LRESULT OnAcadKeepFocus (WPARAM, LPARAM) ; // Cajas de texto para controlar mensajes afx_msg void OnKillfocusEdit_AREA1(); afx_msg void OnKillfocusEdit_AREA2(); afx_msg void OnKillfocusEdit_AREA3(); afx_msg void OnKillfocusEdit_AREA4(); afx_msg void OnKillfocusEdit_AREA5(); afx_msg void OnKillfocusEdit_AREA6(); afx_msg void OnKillfocusEdit_CN1(); afx_msg void OnKillfocusEdit_CN2(); afx_msg void OnKillfocusEdit_CN3(); afx_msg void OnKillfocusEdit_CN4(); afx_msg void OnKillfocusEdit_CN5(); afx_msg void OnKillfocusEdit_CN6(); public: virtual BOOL OnInitDialog(); afx_msg void OnBnClickedOk(); // Funciones de los botones en el cuadro de diálogo virtual void onCALCLimpiar(); virtual void onCALCCalcularCNC(); DECLARE_MESSAGE_MAP() }; PLEDERHidrogramaUnitariosDlg.h #pragma once #include "adui.h" #include "resource.h" // Cuadro de diálogo de CPLEDERHidrogramaUnitariosDlg class CPLEDERHidrogramaUnitariosDlg : public CAdUiDialog { DECLARE_DYNAMIC(CPLEDERHidrogramaUnitariosDlg) public: CPLEDERHidrogramaUnitariosDlg(CWnd *pParent =NULL, HINSTANCE hInstance =NULL); // Constructor estándar virtual ~CPLEDERHidrogramaUnitariosDlg(); enum { IDD = IDD_PLHU }; protected: virtual void DoDataExchange(CDataExchange* pDX); afx_msg LRESULT OnAcadKeepFocus (WPARAM, LPARAM) ; //Botones afx_msg void OnButtonImportarHU(); afx_msg void OnButtonImportarPulsos(); public: virtual BOOL OnInitDialog();afx_msg void OnBnClickedOk(); DECLARE_MESSAGE_MAP() }; PLEDERHidrologiaBufer.h #pragma once //Clases Bufer para hidrologia class HidrogramaUnitarioBufer { public: HidrogramaUnitarioBufer(); HidrogramaUnitarioBufer (int n, double HU, double PULSO); public: HidrogramaUnitarioBufer *ObtenerSiguiente(); void PonerSiguiente(HidrogramaUnitarioBufer *p); virtual ~HidrogramaUnitarioBufer(); public: HidrogramaUnitarioBufer *Siguiente; int n ; double HU, PULSO; }; PLEDERHidrologiaCalculos.h #pragma once class CPLEDERHidrologiaCalculos { public: CPLEDERHidrologiaCalculos(void); public: ~CPLEDERHidrologiaCalculos(void); public: // Calcula las precipitaciones acumulas, incrementales y alternas según IILA SENAMHI-UNI. float HietogramaIILA(int N, float a, float b, float k, float n, float dt, float var, float Tr, float* D, float* Pacum, float* Pincr, float* Palte); // Calcula las precipitaciones acumulas, incrementales y alternas según NRCS. float HietogramaNRCS(float P24, float Ndt, int Tormenta, float* ND, float* TipoT, float* NPacum, float* NPincr); // Calcula las abstracciones y el hietograma de exceso según NRCS. float AbstraccionesHietogramaNRCS(int NP,int CN, float* Palt, float* Pacum, float* Ia, float* Fa, float* PexcesoAcum, float* Pexceso); // Cálculo los Pulsos de ingreso. float PulsosP(int NP, int DT, int dt, float* Pexceso, float* Pulsos, int *nP); // Cálculos mediante la convolución discreta Q = PU. int Convolucion(int nP, int nU, float *P, float *U, float *Q); }; PLEDERHidrologiaDatos.h #pragma once #define PUNFILEEXTHU _T("hu;abia;txt") #define DCEXP 3 #define GETLINEMAXBUFF 1024 #define PUNFILESEP " ,\t\n" class HidrogramaUnitarioBufer; /*------------------------------------------------------------------*/ class CPLEDERHidrologiaDatos { public: CPLEDERHidrologiaDatos(void); public: ~CPLEDERHidrologiaDatos(void); public: // Cálculo de la escorrentía directa, de datos HU versus pulsos int EscorrentiaDirecta1(HidrogramaUnitarioBufer *pPrimerHU); // Importar las ordenadas del Hidrolograma Unitario int ImportarHidrogramaUnitario(const TCHAR *pNombreArchivo,long *NumeroVertHU); // Datos de la distribución de Tormentas según el NRCS. float TormentasNRCS(int Tormenta, float *TipoT, float Ndt); // Datos Hidrograma Sintético NRCS. float HidrogramaSinteticoNRCS(float Tp, float qp,float *t, float *q); // Datos Hidrograma Sintético SNYDER float HidrogramaSinteticoSnyder(float T ,float tR, float tpR, float tb, float QpR, float W50, float W75); //Libera el buffer en ristra HU void LiberarBufferHidrogramaUnitario(); public: HidrogramaUnitarioBufer* pPrimerHU; elemento HU. a la clase HidrogramaUnitarioBufer. public: // Variables HU //Puntero primer  float (SALIDA) }; *P, *U, *Q; // Lista de Pulsos. // Lista de Función respuesta al Pulso. // Lista de Caudal de escorrentia directa /*------------------------------------------------------------------*/ PLEDERHietogramaIilaSenamhiDlg.h #pragma once #include "resource.h" // Cuadro de diálogo de CPLEDERIilaSenamhiDlg class CPLEDERIilaSenamhiDlg : public CAdUiDialog { DECLARE_DYNAMIC(CPLEDERIilaSenamhiDlg) public: CPLEDERIilaSenamhiDlg(CWnd *pParent =NULL, HINSTANCE hInstance =NULL); // Constructor estándar virtual ~CPLEDERIilaSenamhiDlg(); // Datos del cuadro de diálogo enum { IDD = IDD_HIDRO_IILA }; //Declaramos variables del cuadro de diálogo. CAcUiNumericEdit m_Edit_a; CString m_a; CAcUiNumericEdit m_Edit_k; CString m_k; CAcUiNumericEdit m_Edit_n; CString m_n; CAcUiNumericEdit m_Edit_duracion; CString m_duracion; CAcUiNumericEdit m_Edit_tr; CString m_tr; CAcUiNumericEdit m_Edit_PX; CString m_PX; CAcUiNumericEdit m_Edit_PY; CString m_PY; // Combo Box CComboBox m_Combo_b; CString m_b; CComboBox m_Combo_Var; CString m_variacion; // Botones CAcUiPickButton m_PickButton_PUNTO; protected: virtual void DoDataExchange(CDataExchange* pDX); afx_msg LRESULT OnAcadKeepFocus (WPARAM, LPARAM) ; afx_msg void OnKillfocusEdit_a(); afx_msg void OnKillfocusEdit_k(); afx_msg void OnKillfocusEdit_n(); afx_msg void OnKillfocusEdit_duracion(); afx_msg void OnKillfocusEdit_tr(); afx_msg void OnKillfocusCombob(); afx_msg void OnKillfocusComboVar(); afx_msg void OnButtonPUNTO(); public: virtual BOOL OnInitDialog(); afx_msg void OnBnClickedOk(); DECLARE_MESSAGE_MAP() }; PLEDERHietogramaNrcsDlg.h #pragma once #include "resource.h" // Cuadro de diálogo de CPLEDERNRCSDlg class CPLEDERNrcsDlg : public CAdUiDialog { DECLARE_DYNAMIC(CPLEDERNrcsDlg) public: CPLEDERNrcsDlg(CWnd *pParent =NULL, HINSTANCE hInstance =NULL); // Constructor estándar virtual ~CPLEDERNrcsDlg(); // Datos del cuadro de diálogo enum { IDD = IDD_HIDRO_NRCS }; //Declaramos variables del cuadro de diálogo. CAcUiNumericEdit m_Edit_P24; CString m_P24; CAcUiNumericEdit m_Edit_NPX; CString m_NPX; CAcUiNumericEdit m_Edit_NPY; CString m_NPY; // Combo Box CComboBox m_Combo_Ndt; CString m_Ndt; CComboBox m_Combo_Tormenta; CString m_Tipo; int m_Tormenta; //Botones CAcUiPickButton m_PickButton_NPUNTO; protected: virtual void DoDataExchange(CDataExchange* pDX); Compatibilidad con DDX/DDV afx_msg LRESULT OnAcadKeepFocus (WPARAM, LPARAM) ; afx_msg void OnKillfocusEdit_P24(); afx_msg void OnKillfocusComboNdt(); afx_msg void OnKillfocusComboTormenta(); afx_msg void OnButtonNPUNTO(); public: virtual BOOL OnInitDialog(); afx_msg void OnBnClickedOk(); DECLARE_MESSAGE_MAP() }; PLEDERHUNRCSDlg.h #pragma once #include "resource.h" // Cuadro de diálogo de CPLEDERTiempoRetrasoDlg class CPLEDERHUNRCSDlg : public CAdUiDialog { DECLARE_DYNAMIC(CPLEDERHUNRCSDlg) public: // CPLEDERHUNRCSDlg(CWnd *pParent =NULL, HINSTANCE hInstance =NULL); // Constructor estándar virtual ~CPLEDERHUNRCSDlg(); // Datos del cuadro de diálogo enum { IDD = IDD_HIDRO_HUNRCS }; int m_TipoTc; // Cajas de texto CAcUiNumericEdit m_Edit_long; CString m_long; CAcUiNumericEdit m_Edit_pend; CString m_pend; CAcUiNumericEdit m_Edit_tc; CString m_tc; CAcUiNumericEdit m_Edit_tlag1; CString m_tlag1; // Botones (CAD) CAcUiPickButton m_PickButton_Long; CAcUiPickButton m_PickButton_Pend; protected: virtual void DoDataExchange(CDataExchange* pDX); Compatibilidad con DDX/DDV afx_msg LRESULT OnAcadKeepFocus (WPARAM, LPARAM) ; // Radio (Cuando existan cambios en el radio) afx_msg void OnRadioKirpich(); afx_msg void OnRadioUsuario(); // Cajas de texto afx_msg void OnKillfocusEdit_long(); afx_msg void OnKillfocusEdit_pend(); afx_msg void OnKillfocusEdit_tc(); // Botones afx_msg void OnButtonLong(); afx_msg void OnButtonPend(); public: virtual BOOL OnInitDialog(); afx_msg void OnBnClickedOk(); // Funciones para realizar cálculos. virtual void onCalcularTc(); virtual void onCalcularTlag(); DECLARE_MESSAGE_MAP() }; PLEDERHUSnyderDlg.h #pragma once #include "resource.h" // Cuadro de diálogo de CPLEDERHUSNYDERDlg class CPLEDERHUSNYDERDlg : public CAdUiDialog { DECLARE_DYNAMIC(CPLEDERHUSNYDERDlg) public: // CPLEDERHUSNYDERDlg(CWnd *pParent =NULL, HINSTANCE hInstance =NULL); // Constructor estándar virtual ~CPLEDERHUSNYDERDlg(); // Datos del cuadro de diálogo enum { IDD = IDD_HIDRO_HUSNYDER }; int m_TipoCalc; // Cajas de texto CAcUiNumericEdit m_Edit_Area; CString m_area; CAcUiNumericEdit m_Edit_L; CString m_L; CAcUiNumericEdit m_Edit_Lc; CString m_Lc; CAcUiNumericEdit m_Edit_TR; CString m_TR; CAcUiNumericEdit m_Edit_TpR; CString m_TpR; CAcUiNumericEdit m_Edit_Qp; CString m_Qp; CAcUiNumericEdit m_Edit_Ct; CString m_Ct; CAcUiNumericEdit m_Edit_tp; CString m_tp; CAcUiNumericEdit m_Edit_Cp; CString m_Cp; protected: virtual void DoDataExchange(CDataExchange* pDX); Compatibilidad con DDX/DDV afx_msg LRESULT OnAcadKeepFocus (WPARAM, LPARAM) ; // Radio (Cuando existan cambios en el radio) afx_msg void OnRadioCalcularC(); afx_msg void OnRadioUsuarioC(); // Cajas de texto afx_msg void OnKillfocusEdit_Area(); afx_msg void OnKillfocusEdit_L(); afx_msg void OnKillfocusEdit_Lc(); afx_msg void OnKillfocusEdit_TR(); afx_msg void OnKillfocusEdit_TpR(); afx_msg void OnKillfocusEdit_Qp(); afx_msg void OnKillfocusEdit_Ct(); afx_msg void OnKillfocusEdit_tp(); afx_msg void OnKillfocusEdit_Cp(); public: virtual BOOL OnInitDialog(); afx_msg void OnBnClickedOk(); // Funciones para realizar cálculos. virtual void onCalcularCtCp(); virtual void onMensajesCp(); DECLARE_MESSAGE_MAP() }; PLEDERLluviaEscorrentiaDlg.h #pragma once #include "resource.h" // Cuadro de diálogo de CPLEDERLluviaEscorrentiaDlg //  class CPLEDERLluviaEscorrentiaDlg : public CAdUiDialog { DECLARE_DYNAMIC(CPLEDERLluviaEscorrentiaDlg) public: CPLEDERLluviaEscorrentiaDlg(CWnd *pParent =NULL, HINSTANCE hInstance =NULL); // Constructor estándar virtual ~CPLEDERLluviaEscorrentiaDlg(); // Datos del cuadro de diálogo enum { IDD = IDD_HIDRO_HPLEDER }; //Declaramos variables del cuadro de diálogo. // Cajas de texto CAcUiNumericEdit m_Edit_AREA; CString m_area; CAcUiNumericEdit m_Edit_QB; CString m_qb; CAcUiNumericEdit m_Edit_CN; CString m_cn; CAcUiNumericEdit m_Edit_PPX; CString m_ppx; CAcUiNumericEdit m_Edit_PPY; CString m_ppy; // Combo Box CComboBox m_Combo_HUS; int m_hus; CComboBox int m_mm; CComboBox m_Combo_MM; m_Combo_INTERT; CString m_intert; // Botones (Sólo CAD) CAcUiPickButton m_PickButton_AREA; CAcUiPickButton m_PickButton_PPUNTO; // Botones (Dialogo general) CButton m_Button_HUS; // Variables extras de cálculos int pNP, // Número de datos en la lista de precipitaciones. Duracion; // Variación de tiempo de las precipitaciones float Palternaincremental[1441]; alternas o incrementales. // Lista de precipitaciones float PaltAcum[1441];// Lista de precipitaciones alternas acumuladas float Tretardo; // Tiempo de retardo. datos HUS NRCS float tp, Cp; // Coeficientes tp, Cp, SNYDER 147 bool computadoMM; // Boleano para verificar si se calculó metodos meteorológicos. bool computadoHU; // Boleano que verifica si se calculó los H.U. protected: virtual void DoDataExchange(CDataExchange* pDX); // Compatibilidad con DDX/DDV afx_msg LRESULT OnAcadKeepFocus (WPARAM, LPARAM) ; afx_msg void OnKillfocusEdit_CN(); // Combo Box (Cuando existan cambios en el combo) afx_msg void OnKillfocusComboHUS(); afx_msg void OnKillfocusComboMM(); afx_msg void OnKillfocusComboINTERT(); // Botones (Sólo CAD) afx_msg void OnButtonAREA(); afx_msg void OnButtonPPUNTO(); public: virtual BOOL OnInitDialog(); afx_msg void OnBnClickedOk(); // Funciones de los botones en el cuadro de diálogo virtual void OnCALCCurvaNumero(); virtual void OnCALCHidrogramaUnitario(); virtual void OnCALCPrecipitaciones(); DECLARE_MESSAGE_MAP() };  ARCHIVOS Cpp: PLEDERCurvaNumeroDlg.cpp /*-------------------------------------------------------------------- PLEDERCurvaNumeroDlg.cpp: archivo de implementación Cuadro de diálogo de CPLEDERCurvaNumeroDlg -> Calcula el número de curva compuesto. --------------------------------------------------------------------*/ #include "stdafx.h" #include "PLEDERCurvaNumeroDlg.h" /*------------------------------------------------------------------*/ IMPLEMENT_DYNAMIC(CPLEDERCurvaNumeroDlg, CAdUiDialog) CPLEDERCurvaNumeroDlg::CPLEDERCurvaNumeroDlg(CWnd *pParent /*=NULL*/,HINSTANCE hInstance /*=NULL*/) : CAdUiDialog (CPLEDERCurvaNumeroDlg::IDD, pParent, hInstance) { m_a1 = _T("0.0"); m_cn1 = _T("0.0"); m_a2 = _T("0.0"); m_cn2 = _T("0.0"); m_a3 = _T("0.0"); m_cn3 = _T("0.0"); m_a4 = _T("0.0"); m_cn4 = _T("0.0"); m_a5 = _T("0.0"); m_cn5 = _T("0.0"); m_a6 = _T("0.0"); m_cn6 = _T("0.0"); m_cnc = _T("0.0"); } CPLEDERCurvaNumeroDlg::~CPLEDERCurvaNumeroDlg() { } BEGIN_MESSAGE_MAP(CPLEDERCurvaNumeroDlg, CAdUiDialog) // Cajas de Texto ON_EN_KILLFOCUS(IDC_EDIT_a1, OnKillfocusEdit_AREA1) ON_EN_KILLFOCUS(IDC_EDIT_a2, OnKillfocusEdit_AREA2) ON_EN_KILLFOCUS(IDC_EDIT_a3, OnKillfocusEdit_AREA3) ON_EN_KILLFOCUS(IDC_EDIT_a4, OnKillfocusEdit_AREA4) ON_EN_KILLFOCUS(IDC_EDIT_a5, OnKillfocusEdit_AREA5) ON_EN_KILLFOCUS(IDC_EDIT_a6, OnKillfocusEdit_AREA6) ON_EN_KILLFOCUS(IDC_EDIT_cn1, OnKillfocusEdit_CN1) ON_EN_KILLFOCUS(IDC_EDIT_cn2, OnKillfocusEdit_CN2) ON_EN_KILLFOCUS(IDC_EDIT_cn3, OnKillfocusEdit_CN3) ON_EN_KILLFOCUS(IDC_EDIT_cn4, OnKillfocusEdit_CN4) ON_EN_KILLFOCUS(IDC_EDIT_cn5, OnKillfocusEdit_CN5) ON_EN_KILLFOCUS(IDC_EDIT_cn6, OnKillfocusEdit_CN6) // Botones incluidos cad ON_BN_CLICKED(IDC_BUTTON_limpiar, onCALCLimpiar) ON_BN_CLICKED(IDOK, &CPLEDERCurvaNumeroDlg::OnBnClickedOk) END_MESSAGE_MAP() void CPLEDERCurvaNumeroDlg::DoDataExchange(CDataExchange* pDX) { CAdUiDialog::DoDataExchange(pDX); // Cajas de Texto. DDX_Control(pDX, IDC_EDIT_a1, m_Edit_AREA1); DDX_Control(pDX, IDC_EDIT_cn1, m_Edit_CN1); DDX_Control(pDX, IDC_EDIT_a2, m_Edit_AREA2); DDX_Control(pDX, IDC_EDIT_cn2, m_Edit_CN2); DDX_Control(pDX, IDC_EDIT_a3, m_Edit_AREA3); DDX_Control(pDX, IDC_EDIT_cn3, m_Edit_CN3); DDX_Control(pDX, IDC_EDIT_a4, m_Edit_AREA4); DDX_Control(pDX, IDC_EDIT_cn4, m_Edit_CN4); DDX_Control(pDX, IDC_EDIT_a5, m_Edit_AREA5); DDX_Control(pDX, IDC_EDIT_cn5, m_Edit_CN5); DDX_Control(pDX, IDC_EDIT_a6, m_Edit_AREA6); DDX_Control(pDX, IDC_EDIT_cn6, m_Edit_CN6); DDX_Control(pDX, IDC_EDIT_cnc, m_Edit_CNC); } BOOL CPLEDERCurvaNumeroDlg::OnInitDialog() { CDialog::OnInitDialog(); // Inicializa Cajas de texto m_Edit_AREA1.SetWindowText(m_a1); m_Edit_AREA2.SetWindowText(m_a2); m_Edit_AREA3.SetWindowText(m_a3); m_Edit_AREA4.SetWindowText(m_a4); m_Edit_AREA5.SetWindowText(m_a5); m_Edit_AREA6.SetWindowText(m_a6); m_Edit_CN1.SetWindowText(m_cn1); m_Edit_CN1.SetRange(0, 100); m_Edit_CN2.SetWindowText(m_cn2); m_Edit_CN2.SetRange(0, 100); m_Edit_CN3.SetWindowText(m_cn3); m_Edit_CN3.SetRange(0, 100); m_Edit_CN4.SetWindowText(m_cn4); m_Edit_CN4.SetRange(0, 100); m_Edit_CN5.SetWindowText(m_cn5); m_Edit_CN5.SetRange(0, 100); m_Edit_CN6.SetWindowText(m_cn6); m_Edit_CN6.SetRange(0, 100); m_Edit_CNC.SetWindowText(m_cnc); return TRUE; } void CPLEDERCurvaNumeroDlg::OnKillfocusEdit_AREA1() 150 onCALCCalcularCNC();{ } void CPLEDERCurvaNumeroDlg::OnKillfocusEdit_AREA2() { onCALCCalcularCNC(); } void CPLEDERCurvaNumeroDlg::OnKillfocusEdit_AREA3() { onCALCCalcularCNC(); } void CPLEDERCurvaNumeroDlg::OnKillfocusEdit_AREA4() { onCALCCalcularCNC(); } void CPLEDERCurvaNumeroDlg::OnKillfocusEdit_AREA5() { onCALCCalcularCNC(); } void CPLEDERCurvaNumeroDlg::OnKillfocusEdit_AREA6() { onCALCCalcularCNC(); } void CPLEDERCurvaNumeroDlg::OnKillfocusEdit_CN1() { m_Edit_CN1.Convert(); if (!m_Edit_CN1.Validate()) { ::AfxMessageBox(_T("Curva Número no válida, \nrango = 1 @ 100")); } m_Edit_CN1.SetFocus(); m_Edit_CN1.SetSel(0, -1); CString str; m_Edit_CN1.GetWindowText(m_cn1); acdbRToS(::_wtof(m_cn1), 2, 0, str.GetBuffer(80)); m_Edit_CN1.SetWindowText(str); onCALCCalcularCNC(); } void CPLEDERCurvaNumeroDlg::OnKillfocusEdit_CN2() { m_Edit_CN2.Convert(); if (!m_Edit_CN2.Validate()) { ::AfxMessageBox(_T("Curva Número no válida, \nrango = 1 @ 100")); } m_Edit_CN2.SetFocus(); m_Edit_CN2.SetSel(0, -1); CString str; m_Edit_CN2.GetWindowText(m_cn2); acdbRToS(::_wtof(m_cn2), 2, 0, str.GetBuffer(80)); -- m_Edit_CN2.SetWindowText(str); onCALCCalcularCNC(); } void CPLEDERCurvaNumeroDlg::OnKillfocusEdit_CN3() { m_Edit_CN3.Convert(); if (!m_Edit_CN3.Validate()){ 100")); } ::AfxMessageBox(_T("Curva Número no válida, \nrango = 1 @ m_Edit_CN3.SetFocus(); m_Edit_CN3.SetSel(0, -1); CString str; m_Edit_CN3.GetWindowText(m_cn3); acdbRToS(::_wtof(m_cn3), 2, 0, str.GetBuffer(80)); m_Edit_CN3.SetWindowText(str); onCALCCalcularCNC(); } void CPLEDERCurvaNumeroDlg::OnKillfocusEdit_CN4() { m_Edit_CN4.Convert(); if (!m_Edit_CN4.Validate()) { ::AfxMessageBox(_T("Curva Número no válida, \nrango = 1 @ 100")); m_Edit_CN4.SetFocus(); m_Edit_CN4.SetSel(0, -1); } CString str; m_Edit_CN4.GetWindowText(m_cn4); acdbRToS(::_wtof(m_cn4), 2, 0, str.GetBuffer(80)); m_Edit_CN4.SetWindowText(str); onCALCCalcularCNC(); } void CPLEDERCurvaNumeroDlg::OnKillfocusEdit_CN5() { m_Edit_CN5.Convert(); if (!m_Edit_CN5.Validate()) { ::AfxMessageBox(_T("Curva Número no válida, \nrango = 1 @ 100")); m_Edit_CN5.SetFocus(); m_Edit_CN5.SetSel(0, -1); } CString str; m_Edit_CN5.GetWindowText(m_cn5); acdbRToS(::_wtof(m_cn5), 2, 0, str.GetBuffer(80)); m_Edit_CN5.SetWindowText(str); onCALCCalcularCNC(); } void CPLEDERCurvaNumeroDlg::OnKillfocusEdit_CN6() { m_Edit_CN6.Convert(); if (!m_Edit_CN6.Validate()) { ::AfxMessageBox(_T("Curva Número no válida, \nrango = 1 @ 100")); } m_Edit_CN6.SetFocus(); m_Edit_CN6.SetSel(0, -1); CString str; m_Edit_CN6.GetWindowText(m_cn6); acdbRToS(::_wtof(m_cn6), 2, 0, str.GetBuffer(80)); m_Edit_CN6.SetWindowText(str); onCALCCalcularCNC(); }  void CPLEDERCurvaNumeroDlg::onCALCLimpiar() { m_Edit_AREA1.SetWindowText(_T("0.0")); m_Edit_AREA2.SetWindowText(_T("0.0")); m_Edit_AREA3.SetWindowText(_T("0.0")); m_Edit_AREA4.SetWindowText(_T("0.0")); m_Edit_AREA5.SetWindowText(_T("0.0")); m_Edit_AREA6.SetWindowText(_T("0.0")); m_Edit_CN1.SetWindowText(_T("0.0")); m_Edit_CN2.SetWindowText(_T("0.0")); m_Edit_CN3.SetWindowText(_T("0.0")); m_Edit_CN4.SetWindowText(_T("0.0")); m_Edit_CN5.SetWindowText(_T("0.0")); m_Edit_CN6.SetWindowText(_T("0.0")); m_Edit_CNC.SetWindowText(_T("0.0")); } void CPLEDERCurvaNumeroDlg::onCALCCalcularCNC() { m_Edit_AREA1.GetWindowText(m_a1); m_Edit_CN1.GetWindowText(m_cn1); m_Edit_AREA2.GetWindowText(m_a2); m_Edit_CN2.GetWindowText(m_cn2); m_Edit_AREA3.GetWindowText(m_a3); m_Edit_CN3.GetWindowText(m_cn3); m_Edit_AREA4.GetWindowText(m_a4); m_Edit_CN4.GetWindowText(m_cn4); m_Edit_AREA5.GetWindowText(m_a5); m_Edit_CN5.GetWindowText(m_cn5); m_Edit_AREA6.GetWindowText(m_a6); m_Edit_CN6.GetWindowText(m_cn6); float a1, a2, a3,a4, a5,a6, AT, cnc; int cn1, cn2, cn3, cn4, cn5, cn6; a1 = _wtof(m_a1); a2 = _wtof(m_a2); a3 = _wtof(m_a3); a4 = _wtof(m_a4); a5 = _wtof(m_a5); a6 = _wtof(m_a6); cn1 = _wtof(m_cn1); cn2 = _wtof(m_cn2); cn3 = _wtof(m_cn3); cn4 = _wtof(m_cn4); cn5 = _wtof(m_cn5); cn6 = _wtof(m_cn6); //Cálculo de CNC AT = a1+a2+a3+a4+a5+a6; if(AT > 0) { cnc = (a1*cn1 +a2*cn2+a3*cn3+a4*cn4+a5*cn5+a6*cn6)/AT; CString str; m_cnc.Format(_T("%g"), cnc); acdbRToS(::_wtof(m_cnc), 2, 0, str.GetBuffer(80)); } m_Edit_CNC.SetWindowText(str); else { } } m_Edit_CNC.SetWindowText(_T("0")); void CPLEDERCurvaNumeroDlg::OnBnClickedOk() { // Coge los valores despues de pulsar OK // Cajas de texto m_Edit_AREA1.GetWindowText(m_a1); m_Edit_CN1.GetWindowText(m_cn1); m_Edit_AREA2.GetWindowText(m_a2); m_Edit_CN2.GetWindowText(m_cn2); m_Edit_AREA3.GetWindowText(m_a3); m_Edit_CN3.GetWindowText(m_cn3); m_Edit_AREA4.GetWindowText(m_a4); m_Edit_CN4.GetWindowText(m_cn4); m_Edit_AREA5.GetWindowText(m_a5); m_Edit_CN5.GetWindowText(m_cn5); m_Edit_AREA6.GetWindowText(m_a6); m_Edit_CN6.GetWindowText(m_cn6); m_Edit_CNC.GetWindowText(m_cnc); CDialog::OnOK(); } PLEDERHidrogramaUnitariosDlg.cpp /*-------------------------------------------------------------------- PLEDERHidrogramaUnitariosDlg.cpp: archivo de implementación Cuadro de diálogo de CPLEDERHidrogramaUnitariosDlg --------------------------------------------------------------------*/ #include "stdafx.h" #include "PLEDERHidrogramaUnitariosDlg.h" #include "PLEDERHidrologiaDatos.h" #include "PLEDERRecursosCad.h" /*------------------------------------------------------------------*/ //Creando objetos CPLEDERHidrologiaDatos HU; CRecursosCad RecursosHU; /*------------------------------------------------------------------*/ IMPLEMENT_DYNAMIC(CPLEDERHidrogramaUnitariosDlg, CDialog) BEGIN_MESSAGE_MAP(CPLEDERHidrogramaUnitariosDlg, CDialog) //ON_EN_KILLFOCUS(IDC_EDIT_t, OnKillfocusEdit_t) ON_BN_CLICKED(IDC_BUTTON_HU, OnButtonImportarHU) ON_BN_CLICKED(IDC_BUTTON_PULSOS, OnButtonImportarPulsos) ON_BN_CLICKED(IDOK, &CPLEDERHidrogramaUnitariosDlg::OnBnClickedOk) END_MESSAGE_MAP() /*------------------------------------------------------------------*/ CPLEDERHidrogramaUnitariosDlg::CPLEDERHidrogramaUnitariosDlg (CWnd *pParent /*=NULL*/, HINSTANCE hInstance /*=NULL*/) : CAdUiDialog (CPLEDERHidrogramaUnitariosDlg::IDD, pParent, hInstance) { } //m_t = _T("6.0"); CPLEDERHidrogramaUnitariosDlg::~CPLEDERHidrogramaUnitariosDlg() { } /*------------------------------------------------------------------*/ void CPLEDERHidrogramaUnitariosDlg::DoDataExchange(CDataExchange* pDX) { CDialog::DoDataExchange(pDX); } /*------------------------------------------------------------------*/ BOOL CPLEDERHidrogramaUnitariosDlg::OnInitDialog() { CDialog::OnInitDialog(); return TRUE; } /*------------------------------------------------------------------*/ void CPLEDERHidrogramaUnitariosDlg::OnButtonImportarHU() { // mensaje de consola acutPrintf(_T("\nPLEDER: Importar datos de Hidrogramas Unitarios.")); long NumeroVertHU; //Número de ordenadas del H.U. struct resbuf *rb; // resbufs // crear un buffer para el nombre del fichero rb = acutNewRb(RTSTR); if (!rb) { //MDITopoLGCAD.RestSystemVars(); acdbFail(_T("\nError de asignación de memoria [IMPORTAR HU][rb].")); return; } // solicitar el nombre del fichero if (acedGetFileD(_T("Fichero de Hidrogramas Unitarios"), NULL, PUNFILEEXTHU, 4, rb) == RTERROR) { // se canceló  acutRelRb(rb); //MDITopoLGCAD.RestSystemVars(); return; } TCHAR *pNombreArchivo; // fichero // tomar la ruta del fichero pNombreArchivo = (TCHAR*)acad_malloc((_tcslen(rb >resval.rstring) + 1) * sizeof(TCHAR)); if (!pNombreArchivo) { acutRelRb(rb); //MDITopoLGCAD.RestSystemVars(); acdbFail(_T("\nError de asignación de memoria [IMPORTAR HU][pNombreArchivo].")); return; } ::memset(pNombreArchivo, '\0', _tcslen(rb->resval.rstring) + 1); _tcscpy(pNombreArchivo, rb->resval.rstring); acutRelRb(rb); // importar los ordenadas if (HU.ImportarHidrogramaUnitario(pNombreArchivo, &NumeroVertHU) != RTNORM) { } if (pNombreArchivo) { acad_free(pNombreArchivo); } //MDITopoLGCAD.RestSystemVars(); return; if (pNombreArchivo) { acad_free(pNombreArchivo); } acutPrintf(_T("\n%d Ordenadas Importadas."), NumeroVertHU); } /*------------------------------------------------------------------*/ void CPLEDERHidrogramaUnitariosDlg::OnButtonImportarPulsos() { acutPrintf(_T("\nPLEDER: Importa datos de Pulsos.")); } /*------------------------------------------------------------------*/ void CPLEDERHidrogramaUnitariosDlg::OnBnClickedOk() { //Inicializa las variables de sistema. RecursosHU.InicializarVariables();if ( HU.EscorrentiaDirecta1(HU.pPrimerHU) != RTNORM) { RecursosHU.RestaurarVariables(); acdbFail(_T("\nError: Escorrentia directa")); return; } RecursosHU.RestaurarVariables(); CDialog::OnOK(); } /*------------------------------------------------------------------*/ PLEDERHidrologiaBufer.cpp #include "StdAfx.h" #include "PLEDERHidrologiaBufer.h" /*------------------------------------------------------------------*/ HidrogramaUnitarioBufer::HidrogramaUnitarioBufer() { Siguiente = NULL; } //Constructor que inicializa a CoorXX, CoordYY, ns y siguiente = NULL HidrogramaUnitarioBufer::HidrogramaUnitarioBufer(int nn, double HUU, double PULSOP) { } Siguiente = NULL; n = nn; HU = HUU; PULSO = PULSOP; //Destructor HidrogramaUnitarioBufer::~HidrogramaUnitarioBufer() {} // Obtiene una copia del atributo Siguiente. HidrogramaUnitarioBufer* HidrogramaUnitarioBufer::ObtenerSiguiente() { return Siguiente; } //Pone el atributo Siguiente a p void HidrogramaUnitarioBufer::PonerSiguiente(HidrogramaUnitarioBufer *p) { } Siguiente = p; PLEDERHidrologiaCalculos.cpp #include "StdAfx.h" #include "PLEDERHidrologiaCalculos.h" #include "PLEDERHidrologiaDatos.h" // objetos CPLEDERHidrologiaDatos HidrologiaDatos; CPLEDERHidrologiaCalculos::CPLEDERHidrologiaCalculos(void) 157 { } CPLEDERHidrologiaCalculos::~CPLEDERHidrologiaCalculos(void) { } float CPLEDERHidrologiaCalculos::HietogramaIILA(int N, float a, float b, float k, float n, float dt, float var, float Tr, float* D, float* Pacum, float* Pincr, float* Palte) /*-------------------------------------------------------------------- Ingreso : N = Número de intervalos de tiempo. a = Parámetro regional IILA. b = Parámetro regional IILA. k = Parámetro regional IILA. n = Parámetro regional IILA. dt = Duración de la tormneta. var = Variación del tiempo. Tr = Período de retorno en años. D = Lista de duración o tiempo (min). Salida : Pacum = Lista de Precipitaciones acumuladas (mm). Pincr = Lista de Precipitaciones incrementales (mm). Palte = Lista de precipitaciones alternales (mm) -> Hietograma RTNORM si no se produce ningún error. Propósito : Calcula las precipitaciones acumulas, incrementales y alternas según la ecuación IILA SENAMHI-UNI --------------------------------------------------------------------*/ { int i,j; Pacum[0]= 0.0; //Condicion Inicial for (i =1; i <= N; i++ ) { D[i]=var*i; //Duracion en minutos if (dt <= 3) { Pacum[i]=a*(1+k*log10(Tr))* pow((D[i]/60+b),(n 1))*D[i]/60; } else { Pacum[i]=a*(1+k*log10(Tr))* pow((D[i]/60),n); } Pincr[i]=Pacum[i]-Pacum[i-1]; //Precipitación Incremental } //For i for (i =1; i <= N; i++ ) { if ( i<=N/2) { j =N+1-2*i; Palte[i]=Pincr[j]; //Precipitacion Alterna } else { j =2*i-N; Palte[i]=Pincr[j]; //Precipitacion Alterna } //acutPrintf (_T("\n Palte[%d] %0.3f"), i , Palte[i]); } //For i return RTNORM; } float CPLEDERHidrologiaCalculos::HietogramaNRCS(float P24, float Ndt, int Tormenta, float* ND, float* TipoT, float* NPacum, float* NPincr) /*-------------------------------------------------------------------- Ingreso : P24 = Precipitación máxima de 24 horas. Ndt = Intervalo de tiempo de la lluvia (min) Tormenta = Tipo de tormenta 0 : Tipo I 1 : Tipo IA 2 : Tipo II 3 : Tipo III Salida : ND = Lista de duración o tiempo (min). TipoT = Lista del tipo de distribución (P/P24). NPacum = Lista de Precipitaciones acumuladas (mm). NPincr = Lista de Precipitaciones incrementales (mm). RTNORM si no se produce ningún error. Propósito : Calcula las precipitaciones acumulas, incrementales (Hietogramas) según el tipo de tormenta del NRCS. --------------------------------------------------------------------*/ { float N = 24/(Ndt/60); // Cantidad de elementos en la lista // Toma los datos segun el tipo de tormenta. if (HidrologiaDatos.TormentasNRCS(Tormenta, TipoT, N)!= RTNORM) { acdbFail(_T("\nPLEDER: !ERROR!\nHietogramaNRCS [TormentasNRCS]")); return RTERROR; } NPacum[0]= 0.0; //Condicion Inicial float dt = 24/N; for (int i =0; i <= N+1; i++ ) { ND[i+1]=dt*i; //Duración en minutos NPacum[i+1]=P24*TipoT[i+1]; NPincr[i+1]=NPacum[i+1]-NPacum[i]; //Precipitación Incremental } //For i return RTNORM; } float CPLEDERHidrologiaCalculos::AbstraccionesHietogramaNRCS(int NP, int CN, float *Palt, float* Pacum, float* Ia, float* Fa, float* PexcesoAcum, float* Pexceso) /*-------------------------------------------------------------------- Ingreso : NP = Número de datos en la lista de precipitaciones. Palt = Precipitaciones alternas o acumuladas (mm). CN = Curva Número Salida : Pacum = Lista de Precipitaciones acumuladas (mm). Ia = Lista de Abstracciones Iniciales según NRCS (mm). Fa = Lista de Abstracciones continuas según NRCS (mm). PexcesoAcum = Lista de Exceso de lluvia acumulada en (mm) = Pacum -(Ia+Fa). Pexceso = Lista de Exceso de lluvia (mm) o PULSOS (incluyen ceros). RTNORM si no se produce ningún error. Propósito : Calcula las abstracciones según el NRCS y las precipitaciones en exceso o PULSOS de ingreso. --------------------------------------------------------------------*/ { int i; float Iai, S; S = (25400.0-254.0*CN)/CN; // Retención Potencial máxima (mm) Iai = 0.2*S; // Abstracción inicial constante (mm) Pacum[0]= 0.0; // Condiciones iniciales Palt[0] = 0.0; PexcesoAcum[0] = 0.0; for (i =1; i<= NP+1; i++ ) { // Lista Acumulada de la precipitación (mm) Pacum[i] = Pacum[i-1] + Palt[i]; // Lista de la abstración Inicial (mm) if (Pacum[i] exceso de lluvia. nP = Número de pulsos. RTNORM si no se produce ningún error. Propósito : Calcula los pulsos directos de entrada a partir de las precipitaciones en exceso (Pexceso -> dato) realizando interpolaciones según el intervalo de tiempo asignado. C -> es la relación por el cual controla si se suma los valores (C>=1) o se realizan interpolaciones (C<= NP/C ; i++) { PulsoSum = Pexceso[k]; for (j=1; j< C; j++) { PulsoSum = PulsoSum + Pexceso[k+1]; k++; }// for j Pulsos[i]=PulsoSum; k++; //acutPrintf(_T("\nPulsos[%d]: %0.5f"),i, Pulsos[i]); cont++; // Contador del número de pulsos. }//for i *nP = cont; return RTNORM; } int CPLEDERHidrologiaCalculos::Convolucion(int nP, int nU, float *P, float *U, float *Q) /*-------------------------------------------------------------------- Ingreso : nP = Cantidad de Pulsos en la lista [P]. nU = Cantidad de ordenadas de la lista [U]. P = Lista de Pulso ó Precipitación Efectiva -> exceso de lluvia. U = Lista de la función respuesta a un pulso (HU) o los caudales por unidad de precipitación efectiva del Hidrograma Unitario Salida : Q = Lista de Caudal de escorrentia directa (SALIDA) RTNORM si no se produce ningún error. Propósito : Calcula los caudales de escorrentía directa mediante en método de convolución discreta de la ecuación 2.5.15. Q = suma(PxU) --------------------------------------------------------------------*/ { float Qsum; int n, m, nQ, M; M = nP; nQ = M + nU - 1; for(n =1; n<= nQ; n++) { Qsum = 0.0; for (m = max(1,n-nU+1); m <= min(n,M); m++ ) { Qsum = Qsum + P[m]*U[n-m+1]; } // For m Q[n] = Qsum; //acutPrintf (_T("\n Q[%d] %0.3f"), n , Q[n]); } //for n return RTNORM; } PLEDERHidrologiaDatos.cpp #include "StdAfx.h" #include "PLEDERHidrologiaDatos.h" #include "PLEDERRecursosCad.h" #include "PLEDERHidrologiaBufer.h" #include "PLEDERHidrologiaCalculos.h" #include #include // Para exportar atributos #include #include /*------------------------------------------------------------------*/ //Creando objetos CPLEDERHidrologiaCalculos CalcHidrologia; /*------------------------------------------------------------------*/ CPLEDERHidrologiaDatos::CPLEDERHidrologiaDatos(void) { } CPLEDERHidrologiaDatos::~CPLEDERHidrologiaDatos(void) { delete [] P; delete [] U; delete [] Q; } int CPLEDERHidrologiaDatos::EscorrentiaDirecta1(HidrogramaUnitarioBufer *pPrimerHU) /*------------------------------------------------------------------- Ingreso : pPrimerHU = Puntero al primer elemento del buffer(HidrogramaUnitarioBufer). Salida Propósito : RTNORM si no se produce ningún error. RTERROR en otro caso. : Calcula la escorrentía directa a partir del Hidrograma Unitario y pusos o escorrentia directa --------------------------------------------------------------------*/ { // Verificar los argumentos if (!pPrimerHU) { acdbFail(_T("\nPuntero Nulo de la importación")); return RTERROR; } // Conteo de los datos importados int nU = 0, // Número de ordenadas de los U. nP = 0; // Número de Pulsos P. HidrogramaUnitarioBufer *pHU; pPrimerHU = pPrimerHU->Siguiente; for (pHU = pPrimerHU; pHU != NULL; pHU = pHU->Siguiente) { nU++; /*Cuenta la columna de pulsos distintos de cero, ya que se el ingreso fue de relleno con ceros */ if (pHU->PULSO != 0) 163 { nP++; } } int nQ = nP+nU-1; //acutPrintf(_T("\n NºU: %d, NºP: %d"), nU, nP); P = new float[nP+1]; U = new float[nU+1]; Q = new float[nQ+1]; // Obtención de los datos [P] y [U] en listas int i = 1; for (pHU = pPrimerHU; pHU != NULL; pHU = pHU->Siguiente) { P[i] = pHU->PULSO; U[i] = pHU->HU; i++; acutPrintf (_T("\n P %0.3f, U %0.3f "), pHU->PULSO , pHU >HU); } // Captura en una lista (nVert) los números de Vértices para cada S.T. if ( CalcHidrologia.Convolucion(nP, nU, P, U, Q) != RTNORM) { acdbFail(_T("\nError [Convolucion]")); return RTERROR; } // Etiqueta de los resultados acutPrintf (_T("\nResultado de la Convolución Discreta: ")); for( i = 1; i<= nQ; i++) { acutPrintf (_T("\nQ[%d]: %0.3f"), i, Q[i]); } return RTNORM; } int CPLEDERHidrologiaDatos::ImportarHidrogramaUnitario(const TCHAR *pNombreArchivo, long *NumeroVertHU ) /*------------------------------------------------------------------- Ingreso : pNombreArchivo = Puntero a una zero terminated string con el nombre del archivo. NumeroVertHU = Numero de vértices de las ordenadas del H.U. Salida : RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Importar las ordenadas del Hidrograma Unitario, a partir de un archivo. Guarda los datos en el Buffer HidrogramaUnitarioBufer, para luego llamar desde cualquier función. -------------------------------------------------------------------*/ { std::ifstream infile; char *buffer = NULL; char *token = NULL;  char int long double seps[] = PUNFILESEP; n ; np = 0; x=0, y = 0; if (!pNombreArchivo) { acdbFail(_T("\nArgumento de función no válido [ImportarHidrogramaUnitario].")); return RTERROR; } acutPrintf(_T("\nLeyendo el fichero ascii ...\n")); // abrir el fichero para lectura infile.open(pNombreArchivo); if (infile.fail() != 0) { *NumeroVertHU = 0; acdbFail(_T("\nError de E/S al abrir el fichero [IImportarHidrogramaUnitario][open].")); return RTERROR; } // crear un buffer para la lectura del fichero buffer = (char*)acad_malloc(GETLINEMAXBUFF * sizeof(char)); if (!buffer) { *NumeroVertHU = 0; infile.close(); acdbFail(_T("\nError de asignación de memoria [Importar HU][buffer].")); return RTERROR; } // tomar primero el número de puntos que contiene el fichero // para poder valorar la longitud de la barra de progeso while (!infile.eof()) { infile.getline(buffer, GETLINEMAXBUFF, '\n'); if (infile.eof()) { // limpiar el flag eof infile.clear(); break; } np++; } // mover el puntero al principio del fichero infile.seekg(0, std::ios_base::beg); // colocar una barra de progreso acedSetStatusBarProgressMeter(_T("Insertando las ordenadas del HU: "), 0, (int)np); np = 0; 165 // crear el buffer y añadir el primer Vértice como puntero try { pPrimerHU = new HidrogramaUnitarioBufer(); } catch(const std::bad_alloc&) { acedRestoreStatusBar(); acdbFail(_T("\nError de asignación de memoria [Importar HU][pPrimerHU].")); return RTERROR; } HidrogramaUnitarioBufer *nHU, *nbprevious = pPrimerHU; // recorrer el fichero while (!infile.eof()) { // leer una línea del fichero infile.getline(buffer, GETLINEMAXBUFF, '\n'); if (infile.eof()) break; // separar los campos token = ::strtok(buffer, seps); if (!token) { *NumeroVertHU = np; infile.close(); acad_free(buffer); acedRestoreStatusBar(); acdbFail(_T("\nFichero de Hidrograma Unitario No válido [Importar HU]")); return RTERROR; } n = atoi(token); // Ordenada del HU token = ::strtok(NULL, seps); if (!token) { *NumeroVertHU = np; infile.close(); acad_free(buffer); acedRestoreStatusBar(); acdbFail(_T("\nFichero de Hidrograma Unitario No válido -n- [Importar HU]")); return RTERROR; } x = atof(token); // PULSOS token = ::strtok(NULL, seps); if (!token) { *NumeroVertHU = np; infile.close(); acad_free(buffer); acedRestoreStatusBar(); acdbFail(_T("\nFichero de Hidrograma Unitario No válido -n- [Importar HU]")); return RTERROR; } y = atof(token); int contador = 1; // añadir los vértices de las secciones transv. al buffer try { nHU = new HidrogramaUnitarioBufer(n, x, y); } catch(const std::bad_alloc&) { LiberarBufferHidrogramaUnitario(); acedRestoreStatusBar(); acdbFail(_T("\nError de asignación de memoria [Importar HU][nHU].")); return RTERROR; } nbprevious->Siguiente = nHU; nbprevious = nHU; // actualizar la barra de progreso acedSetStatusBarProgressMeterPos((int)np++); } // while infile.close(); acad_free(buffer); acedRestoreStatusBar(); *NumeroVertHU = np; //Número de vértices totales return RTNORM; } float CPLEDERHidrologiaDatos::TormentasNRCS(int Tormenta, float *TipoT, float N) /*-------------------------------------------------------------------- Ingreso : Tormenta = Valor entero que coge el tipo de tormenta 0 : Tipo I 1 : Tipo IA 2 : Tipo II 3 : Tipo III Salida : Tormenta Elegida. RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Retorna la tormenta elegida -------------------------------------------------------------------*/  { // Distribución Tipo I float TipoI[241]= {0.0,0.00174,0.00348,0.00522,0.00697,0.00871,0.01046,0.0122,0.01 395,0.0157,0.01745,0.0192,0.02095,0.0227,0.02446,0.02621,0.02797 ,0.02972,0.03148,0.03324,0.035,0.03677,0.03858,0.04041,0.04227,0 .04416,0.04608,0.04803,0.05001,0.05201,0.05405,0.05611,0.05821,0 .06033,0.06248,0.06466,0.06687,0.06911,0.07138,0.07367,0.076,0.0 7835,0.0807,0.08307,0.08545,0.08784,0.09024,0.09265,0.09507,0.09 751,0.09995,0.10241,0.10487,0.10735,0.10984,0.11234,0.11485,0.11 737,0.1199,0.12245,0.125,0.12761,0.13034,0.13317,0.1361,0.13915, 0.1423,0.14557,0.14894,0.15241,0.156,0.15966,0.16334,0.16706,0.1 7082,0.1746,0.17842,0.18226,0.18614,0.19006,0.194,0.19817,0.2027 5,0.20775,0.21317,0.219,0.22523,0.23185,0.23885,0.24623,0.254,0. 26233,0.27139,0.28119,0.29173,0.303,0.31942,0.34542,0.38784,0.46 316,0.515,0.5322,0.5476,0.5612,0.573,0.583,0.59188,0.60032,0.608 32,0.61588,0.623,0.62982,0.63648,0.64298,0.64932,0.6555,0.66152, 0.66738,0.67308,0.67862,0.684,0.68925,0.6944,0.69945,0.7044,0.70 925,0.714,0.71865,0.7232,0.72765,0.732,0.73625,0.7404,0.74445,0. 7484,0.75225,0.756,0.75965,0.7632,0.76665,0.77,0.77329,0.77656,0 .77981,0.78304,0.78625,0.78944,0.79261,0.79576,0.79889,0.802,0.8 0509,0.80816,0.81121,0.81424,0.81725,0.82024,0.82321,0.82616,0.8 2909,0.832,0.83489,0.83776,0.84061,0.84344,0.84625,0.84904,0.851 81,0.85456,0.85729,0.86,0.86269,0.86536,0.86801,0.87064,0.87325, 0.87584,0.87841,0.88096,0.88349,0.886,0.88849,0.89096,0.89341,0. 89584,0.89825,0.90064,0.90301,0.90536,0.90769,0.91,0.91229,0.914 56,0.91681,0.91904,0.92125,0.92344,0.92561,0.92776,0.92989,0.932 ,0.93409,0.93616,0.93821,0.94024,0.94225,0.94424,0.94621,0.94816 ,0.95009,0.952,0.95389,0.95576,0.95761,0.95944,0.96125,0.96304,0 .96481,0.96656,0.96829,0.97,0.97169,0.97336,0.97501,0.97664,0.97 825,0.97984,0.98141,0.98296,0.98449,0.986,0.98749,0.98896,0.9904 1,0.99184,0.99325,0.99464,0.99601,0.99736,0.99869,1.0}; // Distribución Tipo IA float TipoIA[241]= {0.0,0.00224,0.00432,0.00628,0.00816,0.01,0.01184,0.01372,0.0156 8,0.01776,0.02,0.02276,0.02568,0.02872,0.03184,0.035,0.03797,0.0 4095,0.04394,0.04695,0.05,0.05315,0.05633,0.05954,0.06276,0.066, 0.0692,0.0724,0.0756,0.0788,0.082,0.08514,0.08829,0.09147,0.0947 1,0.098,0.10147,0.10502,0.10862,0.11229,0.116,0.11969,0.12342,0. 12721,0.13107,0.135,0.13901,0.1431,0.14729,0.15159,0.156,0.16059 ,0.1653,0.17011,0.17501,0.18,0.18494,0.18999,0.19517,0.20049,0.2 06,0.21196,0.21808,0.22432,0.23064,0.237,0.24285,0.24878,0.2549, 0.26127,0.268,0.27517,0.28287,0.29118,0.30019,0.31,0.33142,0.354 69,0.37876,0.40255,0.425,0.43936,0.45168,0.46232,0.47164,0.48,0. 48904,0.49752,0.50548,0.51296,0.52,0.52664,0.53292,0.53888,0.544 56,0.55,0.55564,0.56116,0.56656,0.57184,0.577,0.58198,0.58685,0. 59163,0.59635,0.601,0.60576,0.61044,0.61504,0.61956,0.624,0.6283 6,0.63264,0.63684,0.64096,0.645,0.64889,0.65272,0.65651,0.66026, 0.664,0.66773,0.67148,0.67527,0.6791,0.683,0.68665,0.69027,0.693 86,0.69744,0.701,0.70473,0.70838,0.71198,0.71551,0.719,0.72245,0 .72586,0.72926,0.73263,0.736,0.73939,0.74277,0.74613,0.74948,0.7 5281,0.75613,0.75943,0.76271,0.76598,0.76924,0.77248,0.77571,0.7 7892,0.78211,0.78529,0.78845,0.7916,0.79474,0.79786,0.80096,0.80 405,0.80712,0.81018,0.81322,0.81625,0.81926,0.82226,0.82524,0.82 821,0.83116,0.8341,0.83702,0.83992,0.84281,0.84569,0.84855,0.851 4,0.85423,0.85704,0.85984,0.86262,0.86539,0.86815,0.87089,0.8736 1,0.87632,0.87901,0.88169,0.88435,0.887,0.88963,0.89225,0.89485, 0.89744,0.90001,0.90257,0.90511,0.90763,0.91014,0.91264,0.91512, 0.91759,0.92004,0.92247,0.92489,0.92729,0.92968,0.93206,0.93442, 0.93676,0.93909,0.9414,0.9437,0.94598,0.94825,0.9505,0.95274,0.9  5496,0.95717,0.95936,0.96154,0.9637,0.96584,0.96797,0.97009,0.97 219,0.97428,0.97635,0.9784,0.98044,0.98246,0.98447,0.98647,0.988 45,0.99041,0.99236,0.99429,0.99621,0.99811,1.0}; // Distribución Tipo II float TipoII[241]= {0.0,0.00101,0.00202,0.00305,0.00408,0.00513,0.00618,0.00725,0.0 0832,0.00941,0.0105,0.01161,0.01272,0.01385,0.01498,0.01613,0.01 728,0.01845,0.01962,0.02081,0.022,0.02321,0.02442,0.02565,0.0268 8,0.02813,0.02938,0.03065,0.03192,0.03321,0.0345,0.03581,0.03712 ,0.03845,0.03978,0.04113,0.04248,0.04385,0.04522,0.04661,0.048,0 .04941,0.05084,0.05229,0.05376,0.05525,0.05676,0.05829,0.05984,0 .06141,0.063,0.06461,0.06624,0.06789,0.06956,0.07125,0.07296,0.0 7469,0.07644,0.07821,0.08,0.08181,0.08364,0.08549,0.08736,0.0892 5,0.09116,0.09309,0.09504,0.09701,0.099,0.10101,0.10304,0.10509, 0.10716,0.10925,0.11136,0.11349,0.11564,0.11781,0.12,0.12225,0.1 246,0.12705,0.1296,0.13225,0.135,0.13785,0.1408,0.14385,0.147,0. 1502,0.1534,0.1566,0.1598,0.163,0.16628,0.16972,0.17332,0.17708, 0.181,0.18512,0.18948,0.19408,0.19892,0.204,0.2094,0.2152,0.2214 ,0.228,0.235,0.24268,0.25132,0.26092,0.27148,0.283,0.30684,0.354 36,0.43079,0.56786,0.663,0.68196,0.69864,0.71304,0.72516,0.735,0 .74344,0.75136,0.75876,0.76564,0.772,0.77796,0.78364,0.78904,0.7 9416,0.799,0.8036,0.808,0.8122,0.8162,0.82,0.82367,0.82726,0.830 79,0.83424,0.83763,0.84094,0.84419,0.84736,0.85047,0.8535,0.8564 7,0.85936,0.86219,0.86494,0.86763,0.87024,0.87279,0.87526,0.8776 7,0.88,0.88229,0.88455,0.88679,0.889,0.89119,0.89335,0.89549,0.8 976,0.89969,0.90175,0.90379,0.9058,0.90779,0.90975,0.91169,0.913 6,0.91549,0.91735,0.91919,0.921,0.92279,0.92455,0.92629,0.928,0. 92969,0.93135,0.93299,0.9346,0.93619,0.93775,0.93929,0.9408,0.94 229,0.94375,0.94519,0.9466,0.94799,0.94935,0.95069,0.952,0.9533, 0.95459,0.95588,0.95716,0.95844,0.95971,0.96098,0.96224,0.9635,0 .96475,0.966,0.96724,0.96848,0.96971,0.97094,0.97216,0.97338,0.9 7459,0.9758,0.977,0.9782,0.97939,0.98058,0.98176,0.98294,0.98411 ,0.98528,0.98644,0.9876,0.98875,0.9899,0.99104,0.99218,0.99331,0 .99444,0.99556,0.99668,0.99779,0.9989,1.0}; // Distribución Tipo III float TipoIII[241]= {0.0,0.001,0.002,0.003,0.004,0.005,0.006,0.007,0.008,0.009,0.01, 0.011,0.012,0.013,0.014,0.015,0.016,0.017,0.018,0.019,0.02,0.021 01,0.02203,0.02307,0.02412,0.02519,0.02627,0.02737,0.02848,0.029 61,0.03075,0.03191,0.03308,0.03427,0.03547,0.03669,0.03792,0.039 17,0.04043,0.04171,0.043,0.04431,0.04563,0.04697,0.04832,0.04969 ,0.05107,0.05247,0.05388,0.05531,0.05675,0.05821,0.05968,0.06117 ,0.06267,0.06419,0.06572,0.06727,0.06883,0.07041,0.072,0.07363,0 .0753,0.07703,0.0788,0.08063,0.0825,0.08443,0.0864,0.08843,0.090 5,0.09263,0.0948,0.09703,0.0993,0.10163,0.104,0.10643,0.1089,0.1 1143,0.114,0.11666,0.11943,0.12232,0.12532,0.12844,0.13167,0.135 02,0.13848,0.14206,0.14575,0.14956,0.15348,0.15752,0.16167,0.165 94,0.17032,0.17482,0.17943,0.18416,0.189,0.19402,0.19928,0.20478 ,0.21052,0.2165,0.22272,0.22918,0.23588,0.24282,0.25,0.25776,0.2 6644,0.27604,0.28656,0.298,0.3143,0.3394,0.3733,0.416,0.5,0.584, 0.6267,0.6606,0.6857,0.702,0.71344,0.72396,0.73356,0.74224,0.75, 0.75718,0.76412,0.77082,0.77728,0.7835,0.78948,0.79522,0.80072,0 .80598,0.811,0.81584,0.82057,0.82518,0.82968,0.83406,0.83833,0.8 4248,0.84652,0.85044,0.85425,0.85794,0.86152,0.86498,0.86833,0.8 7156,0.87468,0.87768,0.88057,0.88334,0.886,0.88858,0.8911,0.8935 8,0.896,0.89838,0.9007,0.90298,0.9052,0.90738,0.9095,0.91158,0.9 136,0.91558,0.9175,0.91938,0.9212,0.92298,0.9247,0.92638,0.928,0 .92959,0.93117,0.93273,0.93428,0.93581,0.93733,0.93883,0.94032,0 .94179,0.94325,0.94469,0.94612,0.94753,0.94893,0.95031,0.95168,0 169 .95303,0.95437,0.95569,0.957,0.95829,0.95958,0.96085,0.96211,0.9 6336,0.9646,0.96582,0.96704,0.96824,0.96944,0.97062,0.97179,0.97 295,0.9741,0.97523,0.97636,0.97747,0.97858,0.97967,0.98075,0.981 82,0.98288,0.98392,0.98496,0.98598,0.987,0.988,0.98899,0.98997,0 .99094,0.99189,0.99284,0.99377,0.9947,0.99561,0.99651,0.9974,0.9 9828,0.99914,1.0}; int i, // Contador for j=0, // Contador temporal cont; // Valor entero para como contador. float dt; // Variación del tiempo. dt = 24/N; cont = dt*10; // Los datos del hietograma estan en relacion a 1/10 switch (Tormenta) { case 0: // Tormenta tipo I { for (i = 1; i <= N+1; i++ ) { TipoT[i] = TipoI[j]; j = j + cont; } break; } case 1: // Tormenta tipo IA { for (i = 1; i <= N+1; i++ ) { TipoT[i] = TipoIA[j]; j = j + cont; } break; } case 2: // Tormenta tipo II { for (i = 1; i <=N+1; i++ ) { TipoT[i] = TipoII[j]; j = j + cont; //acutPrintf (_T("\n TipoT[%d] %0.5f"), i , TipoT[i]); } break; } case 3: //Tormenta tipo III { for (i = 1; i <= N+1; i++ ) { TipoT[i] = TipoIII[j]; j = j + cont; } break; } default: acutPrintf(_T("\nFuera de Rango")); } //switch (Tormenta) return RTNORM; } float CPLEDERHidrologiaDatos::HidrogramaSinteticoNRCS(float Tp, float qp,float *t, float *q) /*-------------------------------------------------------------------- Ingreso : Tp = Tiempo de ocurrencia del pico (min) qp = Caudal pico HU (m3/s/mm) Salida : t = Lista de tiempos (min) q = Lista de caudales (m3/s/mm) RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Retorna los datos del tiempo (t) y caudal (q) del Hidrograma Unitario t = Tp* (t/Tp); q = qp*(q/qp). --------------------------------------------------------------------*/ { float t_Tp[33] = {0.00,0.10,0.20,0.30,0.40,0.50,0.60,0.70,0.80,0.90,1.00,1.10,1.2 0,1.30,1.40,1.50,1.60,1.70,1.80,1.90,2.00,2.20,2.40,2.60,2.80,3. 00,3.20,3.40,3.6,3.8,4,4.5,5}; float q_qp[33] = {0.00,0.030,0.100,0.190,0.310,0.470,0.660,0.820,0.930,0.990,1.00 0,0.990,0.930,0.860,0.780,0.680,0.560,0.460,0.390,0.330,0.280,0. 207,0.147,0.107,0.077,0.055,0.040,0.029,0.021,0.015,0.011,0.005, 0}; for(int i=1; i <= 33; i++) { t[i] = t_Tp[i-1] * Tp; q[i] = q_qp[i-1] * qp; } return RTNORM; } float CPLEDERHidrologiaDatos::HidrogramaSinteticoSnyder(float T ,float tR, float tpR, float tb, float QpR, float W50, float W75) /*-------------------------------------------------------------------- Ingreso : Tp = Tiempo de ocurrencia del pico (min) qp = Caudal pico HU (m3/s/mm) Salida : t = Lista de tiempos (min) q = Lista de caudales (m3/s/mm) RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Retorna los datos del tiempo (t) y caudal (q) del Hidrograma Unitario t = Tp* (t/Tp); q = qp*(q/qp). -------------------------------------------------------------------*/ { int i; float P = tR/2 +tpR, Q; // Tramo AB if ( T>=0 && T <= P-(1.0/3.0)*W50) { Q = (0.5*QpR/(P-(1.0/3.0)*W50))*T; Q = Q/10.0; // [ m³/(sxmm)] } // Tramo BC if ( T> P-(1.0/3.0)*W50 && T <= P-(1.0/3.0)*W75) { Q = 0.5*QpR + (0.75*QpR/(W50-W75))*(T-P+(1.0/3.0)*W50); Q = Q/10.0; // [ m³/(sxmm)] } // Tramo CD if ( T > P-(1.0/3.0)*W75 && T <= P) { Q = 0.75*QpR + (0.75*QpR/W75)*(T-P+(1.0/3.0)*W75); Q = Q/10.0; // [ m³/(sxmm)] } // Tramo DE if ( T > P && T <= P + (2.0/3.0)*W75) { Q = QpR - 3*QpR/(8*W75)*(T-P); Q = Q/10.0; // [ m³/(sxmm)] } // Tramo EF if ( T > P + (2.0/3.0)*W75 && T <= P + (2.0/3.0)*W50) { Q = 0.75*QpR - 3*QpR/(8*(W50-W75))*(T-P-(2.0/3.0)*W75); Q = Q/10.0; // [ m³/(sxmm)] } // Tramo FG if ( T > P + (2.0/3.0)*W50 && T <= tb) { Q = 0.50*QpR - (0.5*QpR/(tb-P-(2.0/3.0)*W50))*(T-P (2.0/3.0)*W50); Q = Q/10.0; // [ m³/(sxmm)] } return Q; } void CPLEDERHidrologiaDatos::LiberarBufferHidrogramaUnitario() /*-------------------------------------------------------------------- Ingreso : Vacío. Salida : Vacío. Propósito : Libera el buffer en ristra HidrogramaUnitarioBufer al que apunta el miembro pPrimerHU. Llamar a esta función para liberar el buffer con las ordenasas del HU , obtenidos mediante una llamada a la función ImportarHidrogramaUnitario(). --------------------------------------------------------------------*/ { if (!pPrimerHU) return; HidrogramaUnitarioBufer *nHU = pPrimerHU; HidrogramaUnitarioBufer *Siguiente = NULL; // liberar la ristra while (Siguiente = nHU->Siguiente) delete nHU; { } nHU = Siguiente; delete nHU; pPrimerHU = NULL; } PLEDERHietogramaIilaSenamhiDlg.cpp /*-------------------------------------------------------------------- PLEDERIilaSenamhiDlg.cpp: archivo de implementación Cuadro de diálogo CPLEDERIilaSenamhiDlg -> para obtener Hietogramas mediante el método IILA SENAMHI UNI -------------------------------------------------------------------*/ #include "stdafx.h" #include "resource.h" #include "PLEDERHietogramaIilaSenamhiDlg.h" #include "PLEDERHidrologiaDatos.h" #include "PLEDERRecursosCad.h" /*-----------------------------------------------------------------*/ //Creando objetos CRecursosCad RecursosIILA; /*-----------------------------------------------------------------*/ IMPLEMENT_DYNAMIC(CPLEDERIilaSenamhiDlg, CAdUiDialog) CPLEDERIilaSenamhiDlg::CPLEDERIilaSenamhiDlg (CWnd *pParent /*=NULL*/, HINSTANCE hInstance /*=NULL*/) : CAdUiDialog (CPLEDERIilaSenamhiDlg::IDD, pParent, hInstance) { m_a = _T("12.12"); m_k = _T("0.533"); m_n = _T("0.254"); m_duracion = _T("3.0"); m_tr = _T("100.0"); m_PX = _T("0.00"); m_PY = _T("0.00"); } CPLEDERIilaSenamhiDlg::~CPLEDERIilaSenamhiDlg() { } /*------------------------------------------------------------------*/ BEGIN_MESSAGE_MAP(CPLEDERIilaSenamhiDlg, CAdUiDialog) ON_EN_KILLFOCUS(IDC_EDIT_a, OnKillfocusEdit_a) ON_EN_KILLFOCUS(IDC_EDIT_k, OnKillfocusEdit_k) ON_EN_KILLFOCUS(IDC_EDIT_n, OnKillfocusEdit_n) ON_EN_KILLFOCUS(IDC_EDIT_dt, OnKillfocusEdit_duracion) ON_EN_KILLFOCUS(IDC_EDIT_Tr, OnKillfocusEdit_tr) //Funcion para los cambios en el ComboBox  //ON_CBN_SELCHANGE(IDC_COMB_b, OnKillfocusCombob) // Botones ON_BN_CLICKED(IDC_BUTTON_Punto, OnButtonPUNTO) ON_BN_CLICKED(IDOK, &CPLEDERIilaSenamhiDlg::OnBnClickedOk) END_MESSAGE_MAP() /*------------------------------------------------------------------*/ void CPLEDERIilaSenamhiDlg::DoDataExchange (CDataExchange *pDX) { CAdUiDialog::DoDataExchange (pDX) ; DDX_Control(pDX, IDC_EDIT_a, m_Edit_a); DDX_Control(pDX, IDC_EDIT_k, m_Edit_k); DDX_Control(pDX, IDC_EDIT_n, m_Edit_n); DDX_Control(pDX, IDC_EDIT_dt, m_Edit_duracion); DDX_Control(pDX, IDC_EDIT_Tr, m_Edit_tr); DDX_Control(pDX, IDC_EDIT_PX, m_Edit_PX); DDX_Control(pDX, IDC_EDIT_PY, m_Edit_PY); //Botones DDX_Control(pDX, IDC_BUTTON_Punto, m_PickButton_PUNTO); //ComboBox DDX_Control(pDX, IDC_COMB_b, m_Combo_b); DDX_Control(pDX, IDC_COMB_Var, m_Combo_Var); } /*------------------------------------------------------------------*/ // Controladores de mensajes de CALC_HIDRAULIC_DLG BOOL CPLEDERIilaSenamhiDlg::OnInitDialog() { CDialog::OnInitDialog(); m_Edit_a.SetWindowText(m_a); m_Edit_a.SetRange(0, 1000.0); m_Edit_k.SetWindowText(m_k); m_Edit_k.SetRange(0, 1000); m_Edit_n.SetWindowText(m_n); m_Edit_n.SetRange(0, 1000); m_Edit_duracion.SetWindowText(m_duracion); m_Edit_duracion.SetRange(0, 24); m_Edit_tr.SetWindowText(m_tr); m_Edit_tr.SetRange(0, 100000.0); m_Edit_PX.SetWindowText(m_PX); m_Edit_PY.SetWindowText(m_PY); m_PickButton_PUNTO.AutoLoad(); m_Combo_b.SetCurSel(1); m_Combo_Var.SetCurSel(3); return TRUE; } void CPLEDERIilaSenamhiDlg::OnKillfocusEdit_a() { m_Edit_a.Convert(); if (!m_Edit_a.Validate()) { ::AfxMessageBox(_T("Entrada no válida, rango = 1 @ 1000.0")); } m_Edit_a.SetFocus(); m_Edit_a.SetSel(0, -1); CString str; m_Edit_a.GetWindowText(m_a); acdbRToS(::_wtof(m_a), 2, 3, str.GetBuffer(80)); m_Edit_a.SetWindowText(str); } void CPLEDERIilaSenamhiDlg::OnKillfocusEdit_k() { m_Edit_k.Convert(); if (!m_Edit_k.Validate()) { ::AfxMessageBox(_T("Entrada no válida, rango = 1 @ 1000.0")); } m_Edit_k.SetFocus(); m_Edit_k.SetSel(0, -1); CString str; m_Edit_k.GetWindowText(m_k); acdbRToS(::_wtof(m_k), 2, 3, str.GetBuffer(80)); m_Edit_k.SetWindowText(str); } void CPLEDERIilaSenamhiDlg::OnKillfocusEdit_n() { m_Edit_n.Convert(); if (!m_Edit_n.Validate()) { ::AfxMessageBox(_T("Entrada no válida, rango = 1 @ 1000.0")); } m_Edit_n.SetFocus(); m_Edit_n.SetSel(0, -1); CString str; m_Edit_n.GetWindowText(m_n); acdbRToS(::_wtof(m_n), 2, 3, str.GetBuffer(80)); m_Edit_n.SetWindowText(str); } void CPLEDERIilaSenamhiDlg::OnKillfocusEdit_duracion() { m_Edit_duracion.Convert(); if (!m_Edit_duracion.Validate()) { ::AfxMessageBox(_T("Entrada no válida, rango = 1 @ 24"));  m_Edit_duracion.SetFocus(); m_Edit_duracion.SetSel(0, -1); } CString str; m_Edit_duracion.GetWindowText(m_duracion); acdbRToS(::_wtof(m_duracion), 2, 3, str.GetBuffer(80)); m_Edit_duracion.SetWindowText(str); } void CPLEDERIilaSenamhiDlg::OnKillfocusEdit_tr() { m_Edit_tr.Convert(); if (!m_Edit_tr.Validate()) { ::AfxMessageBox(_T("Entrada no válida, rango = 1 @ 1000.0")); } m_Edit_tr.SetFocus(); m_Edit_tr.SetSel(0, -1); CString str; m_Edit_tr.GetWindowText(m_tr); acdbRToS(::_wtof(m_tr), 2, 3, str.GetBuffer(80)); m_Edit_tr.SetWindowText(str); } void CPLEDERIilaSenamhiDlg::OnButtonPUNTO() { //Clase que habilita CAD //AcAxDocLock docLock; CAcModuleResourceOverride resourceOverride; // Esconde el diálogo BeginEditorCommand(); ads_point p1; // Coge el Punto P1 if (acedGetPoint (NULL, _T("\nPique un Punto para la tabla [Resultados IILA]"), p1) != RTNORM ) { acutPrintf(_T("\nError al ingresar el Punto")); // si no cancela el comando(incluyendo el diálogo) // CancelEditorCommand(); CompleteEditorCommand(); return; } CompleteEditorCommand(); m_PX.Format(_T("%g"), p1[X] ); m_Edit_PX.SetWindowText(m_PX); m_PY.Format(_T("%g"), p1[Y] ); m_Edit_PY.SetWindowText(m_PY); } void CPLEDERIilaSenamhiDlg::OnBnClickedOk() { // TODO : Add extra validation here m_Edit_a.GetWindowText(m_a); m_Edit_k.GetWindowText(m_k); m_Edit_n.GetWindowText(m_n); m_Edit_duracion.GetWindowText(m_duracion); m_Edit_tr.GetWindowText(m_tr); m_Edit_PX.GetWindowText(m_PX); m_Edit_PY.GetWindowText(m_PY); int nIndex = m_Combo_b.GetCurSel(); m_Combo_b.GetLBText(nIndex,m_b); nIndex = m_Combo_Var.GetCurSel(); m_Combo_Var.GetLBText(nIndex,m_variacion); CDialog::OnOK(); } PLEDERHietogramaNrcsDlg.cpp /*-------------------------------------------------------------------- PLEDERNRCSDlg.cpp: archivo de implementación Cuadro de diálogo CPLEDERNrcsDlg -> para obtener Hietogramas mediante el método NRCS --------------------------------------------------------------------*/ #include "stdafx.h" #include "PLEDERHietogramaNrcsDlg.h" #include "PLEDERRecursosCad.h" #include "PLEDERHidrologiaCalculos.h" /*------------------------------------------------------------------*/ //Creando objetos CRecursosCad RecursosNRCS; CPLEDERHidrologiaCalculos HidrologiaNRCS; /*------------------------------------------------------------------*/ IMPLEMENT_DYNAMIC(CPLEDERNrcsDlg, CAdUiDialog) CPLEDERNrcsDlg::CPLEDERNrcsDlg (CWnd *pParent /*=NULL*/, HINSTANCE hInstance /*=NULL*/) : CAdUiDialog (CPLEDERNrcsDlg::IDD, pParent, hInstance) { } m_P24 = _T("56.75"); m_NPX = _T("0.00"); m_NPY = _T("0.00"); CPLEDERNrcsDlg::~CPLEDERNrcsDlg() { } BEGIN_MESSAGE_MAP(CPLEDERNrcsDlg, CAdUiDialog) ON_EN_KILLFOCUS(IDC_EDIT_P24, OnKillfocusEdit_P24) // Botones ON_BN_CLICKED(IDC_BUTTON_Npunto, OnButtonNPUNTO) ON_BN_CLICKED(IDOK, &CPLEDERNrcsDlg::OnBnClickedOk) END_MESSAGE_MAP() void CPLEDERNrcsDlg::DoDataExchange(CDataExchange* pDX) { CAdUiDialog::DoDataExchange (pDX) ; DDX_Control(pDX, IDC_EDIT_P24, m_Edit_P24); DDX_Control(pDX, IDC_EDIT_NPX, m_Edit_NPX); DDX_Control(pDX, IDC_EDIT_NPY, m_Edit_NPY); //ComboBox DDX_Control(pDX, IDC_COMBO_Ndt, m_Combo_Ndt); DDX_Control(pDX, IDC_COMBO_Ntormenta, m_Combo_Tormenta); //Botones DDX_Control(pDX, IDC_BUTTON_Npunto, m_PickButton_NPUNTO); } BOOL CPLEDERNrcsDlg::OnInitDialog() { CDialog::OnInitDialog(); m_Edit_P24.SetWindowText(m_P24); m_Edit_P24.SetRange(0, 10000.0); m_Edit_NPX.SetWindowText(m_NPX); m_Edit_NPY.SetWindowText(m_NPY); m_PickButton_NPUNTO.AutoLoad(); m_Combo_Ndt.SetCurSel(3); m_Combo_Tormenta.SetCurSel(2); return TRUE; } void CPLEDERNrcsDlg::OnKillfocusEdit_P24() { m_Edit_P24.Convert(); if (!m_Edit_P24.Validate()) { ::AfxMessageBox(_T("Entrada no válida, rango = 1 @ 10000.0")); } m_Edit_P24.SetFocus(); m_Edit_P24.SetSel(0, -1); CString str; m_Edit_P24.GetWindowText(m_P24); acdbRToS(::_wtof(m_P24), 2, 3, str.GetBuffer(80)); m_Edit_P24.SetWindowText(str); } void CPLEDERNrcsDlg::OnButtonNPUNTO() { //Clase que habilita CAD  //AcAxDocLock docLock; CAcModuleResourceOverride resourceOverride; // Esconde el diálogo BeginEditorCommand(); ads_point p1; // Coge el Punto P1 if (acedGetPoint (NULL, _T("\nPique un Punto para la tabla [Resultados NRCS]"), p1) != RTNORM ) { acutPrintf(_T("\nError al ingresar el Punto")); // si no cancela el comando(incluyendo el diálogo) // CancelEditorCommand(); CompleteEditorCommand(); return; } CompleteEditorCommand(); m_NPX.Format(_T("%g"), p1[X] ); m_Edit_NPX.SetWindowText(m_NPX); m_NPY.Format(_T("%g"), p1[Y] ); m_Edit_NPY.SetWindowText(m_NPY); } void CPLEDERNrcsDlg::OnBnClickedOk() { // TODO : Add extra validation here m_Edit_P24.GetWindowText(m_P24); m_Edit_NPX.GetWindowText(m_NPX); m_Edit_NPY.GetWindowText(m_NPY); int nIndexNdt = m_Combo_Ndt.GetCurSel(); m_Combo_Ndt.GetLBText(nIndexNdt,m_Ndt); m_Combo_Tormenta.GetLBText(nIndexNdt,m_Tipo); m_Tormenta = m_Combo_Tormenta.GetCurSel(); // Coge la posisión del combo Tormenta CDialog::OnOK(); } PLEDERHUNRCSDlg.cpp // PLEDERHUNRCSDlg.cpp: archivo de implementación // #include "stdafx.h" #include "PLEDERHUNRCSDlg.h" // Cuadro de diálogo de PLEDERHUNRCSDlg  IMPLEMENT_DYNAMIC(CPLEDERHUNRCSDlg, CDialog) CPLEDERHUNRCSDlg::CPLEDERHUNRCSDlg(CWnd *pParent /*=NULL*/, HINSTANCE hInstance /*=NULL*/) : CAdUiDialog (CPLEDERHUNRCSDlg::IDD, pParent, hInstance) { m_TipoTc = 0; m_long = _T("103.38"); m_pend = _T("23.00"); m_tc = _T("42.24"); m_tlag1 = _T("25.35"); } CPLEDERHUNRCSDlg::~CPLEDERHUNRCSDlg() { } BEGIN_MESSAGE_MAP(CPLEDERHUNRCSDlg, CAdUiDialog) // Cajas de texto ON_EN_KILLFOCUS(IDC_EDIT_long, OnKillfocusEdit_long) ON_EN_KILLFOCUS(IDC_EDIT_pend, OnKillfocusEdit_pend) ON_EN_KILLFOCUS(IDC_EDIT_tc, OnKillfocusEdit_tc) // Botones ON_BN_CLICKED(IDC_BUTTON_Long, OnButtonLong) ON_BN_CLICKED(IDC_BUTTON_Pend, OnButtonPend) // Radios (cambios en los Radios) ON_BN_CLICKED(IDC_RADIO_Kirpich, OnRadioKirpich) ON_BN_CLICKED(IDC_RADIO_usuario, OnRadioUsuario) ON_BN_CLICKED(IDOK, &CPLEDERHUNRCSDlg::OnBnClickedOk) END_MESSAGE_MAP() void CPLEDERHUNRCSDlg::DoDataExchange(CDataExchange* pDX) { CAdUiDialog::DoDataExchange(pDX); // Cajas de Texto. DDX_Control(pDX, IDC_EDIT_long, m_Edit_long); DDX_Control(pDX, IDC_EDIT_pend, m_Edit_pend); DDX_Control(pDX, IDC_EDIT_tc, m_Edit_tc); DDX_Control(pDX, IDC_EDIT_tlag1, m_Edit_tlag1); // Radio DDX_Radio(pDX, IDC_RADIO_Kirpich, m_TipoTc); // Botones (CAD) DDX_Control(pDX, IDC_BUTTON_Long, m_PickButton_Long); DDX_Control(pDX, IDC_BUTTON_Pend, m_PickButton_Pend); } BOOL CPLEDERHUNRCSDlg::OnInitDialog() { CDialog::OnInitDialog();// Activar radio Kirpich CButton *pTipoTc; pTipoTc = (CButton *)GetDlgItem(IDC_RADIO_Kirpich); pTipoTc->SetCheck(1); m_TipoTc = 0; // Inicializa Cajas de texto m_Edit_long.SetWindowText(m_long); m_Edit_pend.SetWindowText(m_pend); m_Edit_tc.SetWindowText(m_tc); m_Edit_tlag1.SetWindowText(m_tlag1); // Inicializa el boton tipo Cad m_PickButton_Long.AutoLoad(); m_PickButton_Pend.AutoLoad(); return TRUE; } void CPLEDERHUNRCSDlg::OnKillfocusEdit_long() { CString str; m_Edit_long.GetWindowText(m_long); acdbRToS(::_wtof(m_long), 2, 3, str.GetBuffer(80)); m_Edit_long.SetWindowText(str); // Calcula el Tiempo de Concentración onCalcularTc(); // Calcula el Tiempo de retardo (tlag) m_Edit_tc.GetWindowText(m_tc); float Tlag, Tc; Tc = _wtof(m_tc); Tlag = 0.6*Tc; m_tlag1.Format(_T("%g"), Tlag); m_Edit_tlag1.SetWindowText(m_tlag1); } void CPLEDERHUNRCSDlg::OnKillfocusEdit_pend() { CString str; m_Edit_pend.GetWindowText(m_pend); acdbRToS(::_wtof(m_pend), 2, 5, str.GetBuffer(80)); m_Edit_pend.SetWindowText(str); // Calcula el Tiempo de Concentración onCalcularTc(); // Calcula el Tiempo de retardo (tlag) m_Edit_tc.GetWindowText(m_tc); float Tlag, Tc; Tc = _wtof(m_tc); Tlag = 0.6*Tc; m_tlag1.Format(_T("%g"), Tlag); m_Edit_tlag1.SetWindowText(m_tlag1); } void CPLEDERHUNRCSDlg::OnKillfocusEdit_tc() { // Calcula el Tiempo de retardo (tlag) m_Edit_tc.GetWindowText(m_tc); float Tlag, Tc; Tc = _wtof(m_tc); Tlag = 0.6*Tc; m_tlag1.Format(_T("%g"), Tlag); m_Edit_tlag1.SetWindowText(m_tlag1); } void CPLEDERHUNRCSDlg::OnRadioKirpich() { // Activa las casillas de la ventana m_Edit_long.EnableWindow(1); m_Edit_pend.EnableWindow(1); CStatic *pPend; pPend = (CStatic *)GetDlgItem(IDC_STATIC_pend); pPend->EnableWindow(1); CStatic *pLong; pLong = (CStatic *)GetDlgItem(IDC_STATIC_long); pLong->EnableWindow(1); CButton *pBLong; pBLong = (CButton *)GetDlgItem(IDC_BUTTON_Long); pBLong->EnableWindow(1); CButton *pBPend; pBPend = (CButton *)GetDlgItem(IDC_BUTTON_Pend); pBPend->EnableWindow(1); // Desactiva la caja de texto tc m_Edit_tc.EnableWindow(0); } void CPLEDERHUNRCSDlg::OnRadioUsuario() { // Desactiva las casillas de la ventana m_Edit_long.EnableWindow(0); m_Edit_pend.EnableWindow(0); CStatic *pPend; pPend = (CStatic *)GetDlgItem(IDC_STATIC_pend); pPend->EnableWindow(0); CStatic *pLong; pLong = (CStatic *)GetDlgItem(IDC_STATIC_long); pLong->EnableWindow(0); CButton *pBLong; pBLong = (CButton *)GetDlgItem(IDC_BUTTON_Long); pBLong->EnableWindow(0); CButton *pBPend; pBPend = (CButton *)GetDlgItem(IDC_BUTTON_Pend); pBPend->EnableWindow(0); // Activa la caja de texto tc m_Edit_tc.EnableWindow(1); } void CPLEDERHUNRCSDlg::OnButtonLong() { //Esconde el diálogo BeginEditorCommand(); int double ads_point rc; area; punto; ads_name nombrep; if (acedEntSel(_T("\nSelecione el curso principal de la cuenca [Polilinea]:\n"), nombrep , punto) != RTNORM) { acutPrintf(_T("\nPLEDER: !ERROR!\nal seleccionar la Polilinea")); CompleteEditorCommand(); return; } AcDbObjectId AcDbEntity ID; *pEnt; // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, nombrep) != Acad::eOk) { CompleteEditorCommand(); return acdbFail(_T("\nPLEDER: !ERROR!\nal tomar el ObjectId de la entidad [acdbGetObjectId].")); } // abrir el objeto para lectura if (acdbOpenObject(pEnt, ID, AcDb::kForRead) != Acad::eOk) { CompleteEditorCommand(); return acdbFail(_T("\nPLEDER: !ERROR!\nal abrir el Objeto ")); } // chequear el tipo de objeto if (pEnt->isKindOf(AcDbPolyline::desc()) != Adesk::kTrue) { pEnt->close(); CompleteEditorCommand(); return acdbFail(_T("\nTipo de entidad inesperada ")); } //Retorna al diálogo CompleteEditorCommand(); 183 AcDbPolyline *pPolyline = (AcDbPolyline*)pEnt; // chequear si la Polyline tiene elevación cero if (pPolyline->elevation() != 0) { pPolyline->close(); CompleteEditorCommand(); acutPrintf(_T("\nLa polyline no tiene elevación 0.")); } unsigned int numVerts; // Tomar el número de vértices de la polyline numVerts = pPolyline->numVerts(); if (numVerts <= 2) { pPolyline->close(); CompleteEditorCommand(); return acdbFail(_T("\nPLEDER: !ERROR!\nPolyline no válida ")); } AcGeLineSeg2d ls; AcGePoint2d start, end; ads_point v0, v1; unsigned int i; double Lc=0.00; //longitud de la cuenca v0[Z] = v1[Z] = 0; // recorrer los vértices y calcular la distancia for (i = 0; i < numVerts - 1; i++) { pPolyline->getLineSegAt(i, ls); start = ls.startPoint(); end = ls.endPoint(); v0[X] = start.x; v0[Y] = start.y; v1[X] = end.x; v1[Y] = end.y; Lc = Lc + acutDistance(v0 , v1); } pPolyline->close(); m_long.Format(_T("%g"),Lc/1000.0); //Conversion a km2 m_Edit_long.SetWindowText(m_long); } void CPLEDERHUNRCSDlg::OnButtonPend() { //Esconde el diálogo BeginEditorCommand(); ads_point p1, p2; //Coge el Primer Punto P1 if (acedGetPoint (NULL, _T("\nIngrese el primer Punto [cota menor]"), p1) != RTNORM ) { acutPrintf(_T("\nPLEDER: !ERROR!\nal ingresar el Punto")); // si no cancela el comando(incluyendo el diálogo) //CancelEditorCommand(); CompleteEditorCommand(); return; } int contador =0; double angle, s, l, S =0.0, L=0.0 , ls=0.0; while (true) { // Cogen los puntos siguienes if (acedGetPoint(p1, _T("\nSiguiente punto: "), p2) != RTNORM) { // se canceló o pulsó enter // cancela el comando (incluyendo el diálogo) //CancelEditorCommand(); CompleteEditorCommand(); if(contador == 0) { S=0.0; } else { S=S*100.0; } m_pend.Format(_T("%g"), S ); m_Edit_pend.SetWindowText(m_pend); return; } contador++; // siguiente //Calculo de la pendiente del curso principal //empleando la ecuación de taylor y Schwarz s = abs((p1[Y]-p2[Y]))/abs((p2[X]-p1[X])); acutPrintf(_T("Pendiente %d: %0.2f%s"), contador, s*100.0, "%"); ls = (1.0/sqrt(s))+ ls; S = pow((contador/ls),2.0); p1[X]=p2[X]; p1[Y]=p2[Y]; p1[Z]=0.0; }//while } // Cálculo del tiempo de concentración Kirpich void CPLEDERHUNRCSDlg::onCalcularTc() { m_Edit_long.GetWindowText(m_long); m_Edit_pend.GetWindowText(m_pend); float L, S, Tc, exp1 =0.77, exp2 =0.385;  L = _wtof(m_long); S = _wtof(m_pend); //Cálculo del tiempo de concentración Tc = 3.97*pow(L,exp1)/(pow(S, exp2)); m_tc.Format(_T("%g"), Tc); m_Edit_tc.SetWindowText(m_tc); } void CPLEDERHUNRCSDlg::onCalcularTlag() { m_Edit_long.GetWindowText(m_long); m_Edit_pend.GetWindowText(m_pend); float L, S, Tc, exp1 =0.77, exp2 =0.385; L = _wtof(m_long); S = _wtof(m_pend); //Cálculo del tiempo de concentración Tc = 3.97*pow(L,exp1)/(pow(S, exp2)); m_tc.Format(_T("%g"), Tc); m_Edit_tc.SetWindowText(m_tc); } void CPLEDERHUNRCSDlg::OnBnClickedOk() { // TODO : Add extra validation here m_Edit_long.GetWindowText(m_long); m_Edit_pend.GetWindowText(m_pend); m_Edit_tc.GetWindowText(m_tc); CDialog::OnOK(); } PLEDERHUSnyderDlg.cpp // PLEDERHUSNYDERDlg.cpp: archivo de implementación // #include "stdafx.h" #include "PLEDERHUSnyderDlg.h" // Cuadro de diálogo de CPLEDERHUSNYDERDlg IMPLEMENT_DYNAMIC(CPLEDERHUSNYDERDlg, CDialog) CPLEDERHUSNYDERDlg::CPLEDERHUSNYDERDlg(CWnd *pParent /*=NULL*/, HINSTANCE hInstance /*=NULL*/) : CAdUiDialog (CPLEDERHUSNYDERDlg::IDD, pParent, hInstance) { m_TipoCalc = 0; m_area = _T("3500.00"); 186 = _T("150.00"); m_L m_Lc = _T("75.00"); m_TR = _T("12.00"); m_TpR = _T("34.00"); m_Qp = _T("157.50"); m_Ct = _T("2.64"); m_tp = _T("32.51"); m_Cp = _T("0.56"); } CPLEDERHUSNYDERDlg::~CPLEDERHUSNYDERDlg() { } BEGIN_MESSAGE_MAP(CPLEDERHUSNYDERDlg, CAdUiDialog) // Cajas de texto ON_EN_KILLFOCUS(IDC_EDIT_SNa, OnKillfocusEdit_Area) ON_EN_KILLFOCUS(IDC_EDIT_SNl, OnKillfocusEdit_L) ON_EN_KILLFOCUS(IDC_EDIT_SNlc, OnKillfocusEdit_Lc) ON_EN_KILLFOCUS(IDC_EDIT_SNtr, OnKillfocusEdit_TR) ON_EN_KILLFOCUS(IDC_EDIT_SNtpr, OnKillfocusEdit_TpR) ON_EN_KILLFOCUS(IDC_EDIT_SNqp, OnKillfocusEdit_Qp) ON_EN_KILLFOCUS(IDC_EDIT_SNct, OnKillfocusEdit_Ct) ON_EN_KILLFOCUS(IDC_EDIT_SNtp, OnKillfocusEdit_tp) ON_EN_KILLFOCUS(IDC_EDIT_SNcp, OnKillfocusEdit_Cp) // Radios (cambios en los Radios) ON_BN_CLICKED(IDC_RADIO_SNcalcular, OnRadioCalcularC) ON_BN_CLICKED(IDC_RADIO_SNusuario, OnRadioUsuarioC) ON_BN_CLICKED(IDOK, &CPLEDERHUSNYDERDlg::OnBnClickedOk) END_MESSAGE_MAP() void CPLEDERHUSNYDERDlg::DoDataExchange(CDataExchange* pDX) { CAdUiDialog::DoDataExchange(pDX); // Cajas de Texto. DDX_Control(pDX, IDC_EDIT_SNa, m_Edit_Area); DDX_Control(pDX, IDC_EDIT_SNl, m_Edit_L); DDX_Control(pDX, IDC_EDIT_SNlc, m_Edit_Lc); DDX_Control(pDX, IDC_EDIT_SNtr, m_Edit_TR); DDX_Control(pDX, IDC_EDIT_SNtpr, m_Edit_TpR); DDX_Control(pDX, IDC_EDIT_SNqp, m_Edit_Qp); DDX_Control(pDX, IDC_EDIT_SNct, m_Edit_Ct); DDX_Control(pDX, IDC_EDIT_SNtp, m_Edit_tp); DDX_Control(pDX, IDC_EDIT_SNcp, m_Edit_Cp); // Radio DDX_Radio(pDX, IDC_RADIO_SNcalcular, m_TipoCalc); } BOOL CPLEDERHUSNYDERDlg::OnInitDialog() { CDialog::OnInitDialog(); // Activar radio Kirpich CButton *pTipoCalc; pTipoCalc = (CButton *)GetDlgItem(IDC_RADIO_SNcalcular); pTipoCalc->SetCheck(1); m_TipoCalc = 0; // Inicializa Cajas de texto m_Edit_Area.SetWindowText(m_area); m_Edit_L.SetWindowText(m_L); m_Edit_Lc.SetWindowText(m_Lc); m_Edit_TR.SetWindowText(m_TR); m_Edit_TpR.SetWindowText(m_TpR); m_Edit_Qp.SetWindowText(m_Qp); m_Edit_Ct.SetWindowText(m_Ct); m_Edit_tp.SetWindowText(m_tp); m_Edit_Cp.SetWindowText(m_Cp); m_Edit_Cp.SetRange(0.1, 1); return TRUE; } void CPLEDERHUSNYDERDlg::OnKillfocusEdit_Area() { CString str; m_Edit_Area.GetWindowText(m_area); acdbRToS(::_wtof(m_area), 2, 3, str.GetBuffer(80)); m_Edit_Area.SetWindowText(str); // Calcula los Coeficientes Ct y Cp onCalcularCtCp(); } void CPLEDERHUSNYDERDlg::OnKillfocusEdit_L() { CString str; m_Edit_L.GetWindowText(m_L); acdbRToS(::_wtof(m_L), 2, 3, str.GetBuffer(80)); m_Edit_L.SetWindowText(str); // Calcula los Coeficientes Ct y Cp onCalcularCtCp(); } void CPLEDERHUSNYDERDlg::OnKillfocusEdit_Lc() { CString str; m_Edit_Lc.GetWindowText(m_Lc); acdbRToS(::_wtof(m_Lc), 2, 3, str.GetBuffer(80)); m_Edit_Lc.SetWindowText(str); // Calcula los Coeficientes Ct y Cp onCalcularCtCp(); } void CPLEDERHUSNYDERDlg::OnKillfocusEdit_TR() { CString str; m_Edit_TR.GetWindowText(m_TR); acdbRToS(::_wtof(m_TR), 2, 3, str.GetBuffer(80)); m_Edit_TR.SetWindowText(str); // Calcula los Coeficientes Ct y Cp onCalcularCtCp(); } void CPLEDERHUSNYDERDlg::OnKillfocusEdit_TpR() { CString str; m_Edit_TpR.GetWindowText(m_TpR); acdbRToS(::_wtof(m_TpR), 2, 3, str.GetBuffer(80)); m_Edit_TpR.SetWindowText(str); // Calcula los Coeficientes Ct y Cp onCalcularCtCp(); } void CPLEDERHUSNYDERDlg::OnKillfocusEdit_Qp() { CString str; m_Edit_Qp.GetWindowText(m_Qp); acdbRToS(::_wtof(m_Qp), 2, 3, str.GetBuffer(80)); m_Edit_Qp.SetWindowText(str); // Calcula los Coeficientes Ct y Cp onCalcularCtCp(); } void CPLEDERHUSNYDERDlg::OnKillfocusEdit_Ct() { CString str; m_Edit_Ct.GetWindowText(m_Ct); acdbRToS(::_wtof(m_Ct), 2, 3, str.GetBuffer(80)); m_Edit_Ct.SetWindowText(str); } void CPLEDERHUSNYDERDlg::OnKillfocusEdit_tp() { CString str; m_Edit_tp.GetWindowText(m_tp); acdbRToS(::_wtof(m_tp), 2, 3, str.GetBuffer(80)); m_Edit_tp.SetWindowText(str); } void CPLEDERHUSNYDERDlg::OnKillfocusEdit_Cp() { m_Edit_Cp.Convert(); if (!m_Edit_Cp.Validate()) { ::AfxMessageBox(_T("Coeficiente Cp no Válido, \nrango = 0.1 @ 1")); } m_Edit_Cp.SetFocus(); m_Edit_Cp.SetSel(0, -1); CString str; m_Edit_Cp.GetWindowText(m_Cp); acdbRToS(::_wtof(m_Cp), 2, 3, str.GetBuffer(80)); m_Edit_Cp.SetWindowText(str); } // Cálculo del tiempo de concentración Kirpich void CPLEDERHUSNYDERDlg::onCalcularCtCp() { m_Edit_Area.GetWindowText(m_area); m_Edit_L.GetWindowText(m_L); m_Edit_Lc.GetWindowText(m_Lc); m_Edit_TR.GetWindowText(m_TR); m_Edit_TpR.GetWindowText(m_TpR); m_Edit_Qp.GetWindowText(m_Qp); float A, L, Lc, tR, tpR, Qp, Ct, Cp, exp1 = 0.30; float qp, tp, tr, qpR; A = _wtof(m_area); L = _wtof(m_L); Lc = _wtof(m_Lc); tR = _wtof(m_TR); tpR = _wtof(m_TpR); Qp = _wtof(m_Qp); qp = Qp/A; if (tpR == 5.5*tR) { tr = tR; tp = tpR; Ct = tp/(0.75*pow(L*Lc,exp1)); qpR = qp; Cp = qpR*tpR/2.75; } else { } tr = (tpR - 0.25*tR)/5.25; tp = 5.5*tr; Ct = tp/(0.75*pow(L*Lc,exp1)); qpR = qp; Cp = qpR*tpR/2.75; m_Ct.Format(_T("%g"), Ct); m_Edit_Ct.SetWindowText(m_Ct); m_tp.Format(_T("%g"), tp); m_Edit_tp.SetWindowText(m_tp); m_Cp.Format(_T("%g"), Cp); m_Edit_Cp.SetWindowText(m_Cp); } void { CPLEDERHUSNYDERDlg::onMensajesCp() float Cp = _wtof(m_Cp); if ( Cp < 0.1 | Cp > 1 ) { ::AfxMessageBox(_T("coefieinte Cp no Válido, \nrango = 0.1 @ 1")); } } void CPLEDERHUSNYDERDlg::OnRadioCalcularC() { // Activa las casillas de la ventana m_Edit_Area.EnableWindow(1); m_Edit_L.EnableWindow(1); m_Edit_Lc.EnableWindow(1); m_Edit_TR.EnableWindow(1); m_Edit_TpR.EnableWindow(1); m_Edit_Qp.EnableWindow(1); // Desactiva la caja de texto tc m_Edit_Ct.EnableWindow(0); m_Edit_tp.EnableWindow(0); m_Edit_Cp.EnableWindow(0); } void CPLEDERHUSNYDERDlg::OnRadioUsuarioC() { // Activa las casillas de la ventana m_Edit_Area.EnableWindow(0); m_Edit_L.EnableWindow(0); m_Edit_Lc.EnableWindow(0); m_Edit_TR.EnableWindow(0); m_Edit_TpR.EnableWindow(0); m_Edit_Qp.EnableWindow(0); // Desactiva la caja de texto tc m_Edit_Ct.EnableWindow(0); m_Edit_tp.EnableWindow(1); m_Edit_Cp.EnableWindow(1); } void CPLEDERHUSNYDERDlg::OnBnClickedOk() { // TODO : Add extra validation here m_Edit_Ct.GetWindowText(m_Ct); m_Edit_Cp.GetWindowText(m_Cp); CDialog::OnOK(); m_Edit_Cp.GetWindowText(m_Cp); float Cp = _wtof(m_Cp); if ( Cp < 0.1 | Cp > 1 ) { ::AfxMessageBox(_T("Verifique el Coeficiente Cp, \nrango = 0.1 @ 1")); } } PLEDERLluviaEscorrentiaDlg.cpp /*-------------------------------------------------------------------- PLEDERLluviaEscorrentiaDlg.cpp: archivo de implementación Cuadro de diálogo CPLEDERLluviaEscorrentiaDlg -> Calcula la transformación de la lluvia escorrentía (hietogramas -> Hidrogramas) -------------------------------------------------------------------*/ #include "stdafx.h" #include "PLEDERLluviaEscorrentiaDlg.h" #include "PLEDERRecursosCad.h" #include "PLEDERHidrologiaCalculos.h" #include "PLEDERHUNRCSDlg.h" #include "PLEDERHUSnyderDlg.h" #include "PLEDERHidrologiaDatos.h" #include "PLEDERCurvaNumeroDlg.h" #include "PLEDERHietogramaNrcsDlg.h" #include "PLEDERHietogramaIilaSenamhiDlg.h" /*------------------------------------------------------------------*/ //Creando objetos CRecursosCad RecursosLLES; CPLEDERHidrologiaCalculos HidrologiaLLES; /*------------------------------------------------------------------*/ IMPLEMENT_DYNAMIC(CPLEDERLluviaEscorrentiaDlg, CAdUiDialog) CPLEDERLluviaEscorrentiaDlg::CPLEDERLluviaEscorrentiaDlg(CWnd *pParent /*=NULL*/, HINSTANCE hInstance /*=NULL*/) : CAdUiDialog (CPLEDERLluviaEscorrentiaDlg::IDD, pParent, hInstance) { m_area = _T("1810.34"); m_qb = _T("0.00"); m_cn = _T("73"); m_ppx = _T("0.0"); m_ppy = _T("0.0"); computadoMM = false; computadoHU = false; } CPLEDERLluviaEscorrentiaDlg::~CPLEDERLluviaEscorrentiaDlg() { } BEGIN_MESSAGE_MAP(CPLEDERLluviaEscorrentiaDlg, CAdUiDialog) // Cajas de Texto //ON_EN_KILLFOCUS(IDC_EDIT_area, OnKillfocusEdit_AREA) //ON_EN_KILLFOCUS(IDC_EDIT_qb, OnKillfocusEdit_QB) ON_EN_KILLFOCUS(IDC_EDIT_cn, OnKillfocusEdit_CN) // Combo Box ON_CBN_SELCHANGE(IDC_COMBO_hus, OnKillfocusComboHUS) ON_CBN_SELCHANGE(IDC_COMBO_mm, OnKillfocusComboMM) ON_CBN_SELCHANGE(IDC_COMBO_intert, OnKillfocusComboINTERT) // Botones incluidos cad ON_BN_CLICKED(IDC_BUTTON_area, OnButtonAREA) ON_BN_CLICKED(IDC_BUTTON_PPunto, OnButtonPPUNTO) ON_BN_CLICKED(IDC_BUTTON_cn, OnCALCCurvaNumero) ON_BN_CLICKED(IDC_BUTTON_hus, OnCALCHidrogramaUnitario) ON_BN_CLICKED(IDC_BUTTON_mm, OnCALCPrecipitaciones) ON_BN_CLICKED(IDOK, &CPLEDERLluviaEscorrentiaDlg::OnBnClickedOk) END_MESSAGE_MAP() void CPLEDERLluviaEscorrentiaDlg::DoDataExchange(CDataExchange* pDX) { CAdUiDialog::DoDataExchange(pDX); // Cajas de Texto. DDX_Control(pDX, IDC_EDIT_area, m_Edit_AREA); DDX_Control(pDX, IDC_EDIT_qb, m_Edit_QB); DDX_Control(pDX, IDC_EDIT_cn, m_Edit_CN); DDX_Control(pDX, IDC_EDIT_PPX, m_Edit_PPX); DDX_Control(pDX, IDC_EDIT_PPY, m_Edit_PPY); //ComboBox. DDX_Control(pDX, IDC_COMBO_hus, m_Combo_HUS); DDX_Control(pDX, IDC_COMBO_mm, m_Combo_MM); DDX_Control(pDX, IDC_COMBO_intert, m_Combo_INTERT); // Botones (Sólo CAD) DDX_Control(pDX, IDC_BUTTON_area, m_PickButton_AREA); DDX_Control(pDX, IDC_BUTTON_PPunto, m_PickButton_PPUNTO); // Botones (Diálogo) DDX_Control(pDX, IDC_BUTTON_hus, m_Button_HUS); } BOOL CPLEDERLluviaEscorrentiaDlg::OnInitDialog() { CDialog::OnInitDialog(); // Inicializa Cajas de texto m_Edit_AREA.SetWindowText(m_area); m_Edit_QB.SetWindowText(m_qb); m_Edit_CN.SetWindowText(m_cn); m_Edit_CN.SetRange(1, 100); m_Edit_PPX.SetWindowText(m_ppx); m_Edit_PPY.SetWindowText(m_ppy); // Inicializa Bombo box m_Combo_HUS.SetCurSel(0); m_Combo_MM.SetCurSel(0); m_Combo_INTERT.SetCurSel(3); // Inicializa el boton tipo Cad m_PickButton_AREA.AutoLoad(); m_PickButton_PPUNTO.AutoLoad(); return TRUE; } void CPLEDERLluviaEscorrentiaDlg::OnKillfocusEdit_CN() { m_Edit_CN.Convert(); if (!m_Edit_CN.Validate()) { ::AfxMessageBox(_T("Entrada no válida, rango = 1 @ 100.0")); } m_Edit_CN.SetFocus(); m_Edit_CN.SetSel(0, -1); CString str; m_Edit_CN.GetWindowText(m_cn); acdbRToS(::_wtof(m_cn), 2, 0, str.GetBuffer(80)); m_Edit_CN.SetWindowText(str); } void CPLEDERLluviaEscorrentiaDlg::OnKillfocusComboHUS() { } void CPLEDERLluviaEscorrentiaDlg::OnKillfocusComboMM() { } void CPLEDERLluviaEscorrentiaDlg::OnKillfocusComboINTERT() { } void CPLEDERLluviaEscorrentiaDlg::OnButtonAREA() { //Esconde el diálogo BeginEditorCommand(); int rc; double area; ads_point punto; ads_name nombrep; if (acedEntSel(_T("\nSelecione La Cuenca [Polilinea]:\n"), nombrep , punto) != RTNORM) { acutPrintf(_T("\nError al seleccionar la Polilinea")); CompleteEditorCommand(); return; } AcDbObjectId AcDbEntity ID; *pEnt; // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, nombrep) != Acad::eOk) { CompleteEditorCommand(); return acdbFail(_T("\nError al tomar el ObjectId de la entidad [acdbGetObjectId].")); } // abrir el objeto para lectura if (acdbOpenObject(pEnt, ID, AcDb::kForRead) != Acad::eOk) { CompleteEditorCommand(); return acdbFail(_T("\nError al abrir el Objeto ")); } // chequear el tipo de objeto if (pEnt->isKindOf(AcDbPolyline::desc()) != Adesk::kTrue) { pEnt->close(); CompleteEditorCommand(); return acdbFail(_T("\nTipo de entidad inesperada ")); } //Retorna al diálogo CompleteEditorCommand(); AcDbPolyline *pPolyline = (AcDbPolyline*)pEnt; pPolyline->getArea(area); pPolyline->close(); m_area.Format(_T("%g"),area/1000000.0);//Conversión a km2 m_Edit_AREA.SetWindowText(m_area); } void CPLEDERLluviaEscorrentiaDlg::OnButtonPPUNTO() { //Clase que habilita CAD //AcAxDocLock docLock; CAcModuleResourceOverride resourceOverride; // Esconde el diálogo BeginEditorCommand(); ads_point p1; // Coge el Punto P1 if (acedGetPoint (NULL, _T("\nPique un Punto para la tabla [Resultados PLEDER]"), p1) != RTNORM ) { acutPrintf(_T("\nError al ingresar el Punto")); // si no cancela el comando(incluyendo el diálogo) // CancelEditorCommand(); CompleteEditorCommand(); return; } CompleteEditorCommand(); m_ppx.Format(_T("%g"), p1[X] ); m_Edit_PPX.SetWindowText(m_ppx); m_ppy.Format(_T("%g"), p1[Y] ); m_Edit_PPY.SetWindowText(m_ppy); } void CPLEDERLluviaEscorrentiaDlg::OnCALCCurvaNumero() { //Declaracion de Objetos diálogos CPLEDERCurvaNumeroDlg dlgCNC(CWnd::FromHandle(adsw_acadMainWnd())); if (dlgCNC.DoModal() != IDOK) { acutPrintf(_T("\nPLEDER: Se Canceló la Operación")); return; } m_Edit_CN.SetWindowText(dlgCNC.m_cnc); } void CPLEDERLluviaEscorrentiaDlg::OnCALCHidrogramaUnitario() { m_hus = m_Combo_HUS.GetCurSel(); // Coge la posición del combo hus switch (m_hus) { case 0: // HUS NRCS { //Declaracion de Objetos diálogos CPLEDERHUNRCSDlg dlgHUNRCS(CWnd::FromHandle(adsw_acadMainWnd())); if (dlgHUNRCS.DoModal() != IDOK) { acutPrintf(_T("\nPLEDER: Se Canceló la Operación[HUS NRCS]")); return; } Tretardo = _wtof(dlgHUNRCS.m_tlag1); computadoHU = true; break; } 196 case 1: // HUS Snyder { //Declaracion de Objetos diálogos CPLEDERHUSNYDERDlg dlgHUSN(CWnd::FromHandle(adsw_acadMainWnd())); if (dlgHUSN.DoModal() != IDOK) { acutPrintf(_T("\nPLEDER: Se Canceló la Operación[HUS SNYDER]")); return; } tp = _wtof(dlgHUSN.m_tp); Cp = _wtof(dlgHUSN.m_Cp); computadoHU = true; break; } default: acutPrintf(_T("\nFuera de Rango")); } //switch (m_hus) } void CPLEDERLluviaEscorrentiaDlg::OnCALCPrecipitaciones() { pNP = 0; m_mm = m_Combo_MM.GetCurSel(); // Coge la posición del combo mm switch (m_mm) { case 0: // Tormenta NRCS { CPLEDERNrcsDlg dlgNRCS(CWnd::FromHandle(adsw_acadMainWnd())); if (dlgNRCS.DoModal() != IDOK) { pNP = 0; // Una forma de saber si se calculó o no acutPrintf(_T("\nPLEDER: Se Canceló la Operación")); return; } // Variables Hietograma NRCS float P24, // Precipitación máxima de 24 horas. Ndt, // Intervalo de tiempo de la lluvia (min) PX, // Punto de referencia X. PY; // Punto de referencia Y. int Tormenta; // Tipo de tormenta // 0 : Tipo I // 1 : Tipo IA // 2 : Tipo II // 3 : Tipo III //Coge las variables del diálogo IILA P24 = _wtof(dlgNRCS.m_P24); Ndt = _wtof(dlgNRCS.m_Ndt); Tormenta =dlgNRCS.m_Tormenta; PX =_wtof(dlgNRCS.m_NPX); PY =_wtof(dlgNRCS.m_NPY); // Variables para los reesultados. Max = 241 valores para Ndt 10 minutos. float *ND= new float[241]; // Lista de duración o tiempo (min). float *TipoT = new float[241];// Lista de la distribución de la tormenta elegida float *NPacum = new float[241]; // Lista de Precipitaciones acumuladas (mm). float *NPincr = new float[241]; // Lista de Precipitaciones incrementales (mm). // hietogramas mediante la distribución NRCS if ( HidrologiaLLES.HietogramaNRCS(P24, Ndt, Tormenta, ND, TipoT, NPacum, NPincr)!= RTNORM) { acdbFail(_T("\nError: HietogramaNRCS")); return; } // Traspasa los resultados a la variable global //PaltAcum[0] = 0.0; PaltAcum[1] = 0.0; for (int i =1; i <= 24/(Ndt/60)+1; i++ ) { Palternaincremental[i] = NPincr[i]; // Precipitación alterna PaltAcum[i+1] = PaltAcum[i]+ NPincr[i+1]; // Precipitación alterna acumulada }// For i pNP = 24/(Ndt/60); // número de elementos de la lista de precipitaciones Duracion = Ndt; computadoMM = true; delete [] ND; delete [] TipoT; delete [] NPacum; delete [] NPincr; break; } case 1: // IILA { CPLEDERIilaSenamhiDlg dlgIILA(CWnd::FromHandle(adsw_acadMainWnd())); if (dlgIILA.DoModal() != IDOK) { pNP = 0; // Una forma de saber si se calculó o no acutPrintf(_T("\nPLEDER: Se Canceló la Operación")); return; } //Variables Parámetros regionales float a, //Parámetro regional k, //Parámetro regional b, //Parámetro regional: 0.5 horas Costa //: 0.4 horas Sierra //: 0.2 horas Costa Norte y selava n, //Parámetro regional dt, //Duración de la lluvia (hr) var, //Variación (min) Tr, //Periodo de retorno (años) PX, //Punto de referencia X. PY; //Punto de referencia Y. //Coge las variables del diálogo IILA a = _wtof(dlgIILA.m_a); k = _wtof(dlgIILA.m_k); b = _wtof(dlgIILA.m_b); n = _wtof(dlgIILA.m_n); dt = _wtof(dlgIILA.m_duracion); var =_wtof(dlgIILA.m_variacion); Tr =_wtof(dlgIILA.m_tr); PX =_wtof(dlgIILA.m_PX); PY =_wtof(dlgIILA.m_PY); int N =dt*60/var; // Número de intervalos de tiempo. float *D= new float[N+1];// Lista de duración o tiempo (min). float *Pacum = new float[N+1];// Lista de Precipitaciones acumuladas (mm). float *Pincr = new float[N+1];// Lista de Precipitaciones incrementales (mm). float *Palte = new float[N+1];// Lista de precipitaciones alternales (mm) -> Hietograma //Precipitaciones Totales mediante el metodo de IILA SENAMHI UNI if ( HidrologiaLLES.HietogramaIILA(N,a,b,k,n,dt,var,Tr, D, Pacum, Pincr, Palte)!= RTNORM) { acdbFail(_T("\nError: HietogramaIILA")); return; } PaltAcum[1] = 0.0; Palternaincremental[1] = 0.0; // Traspasa los resultados a la variable global for (int i =1; i <= N+1; i++ ) { Palternaincremental[i+1] = Palte[i]; PaltAcum[i+1] = PaltAcum[i]+ Palternaincremental[i+1]; // Precipitación alterna acumulada }// For i pNP = N;// número de elementos de la lista de precipitaciones Duracion = var; computadoMM = true; delete [] D; delete [] Pacum; delete [] Pincr; delete [] Palte; break; } case 2: // Especificado por el usuario { break; } default: acutPrintf(_T("\nFuera de Rango")); } //switch (m_mm) } void CPLEDERLluviaEscorrentiaDlg::OnBnClickedOk() { // Coge los valores despues de pulsar OK // Cajas de texto m_Edit_AREA.GetWindowText(m_area); m_Edit_QB.GetWindowText(m_qb); m_Edit_CN.GetWindowText(m_cn); m_Edit_PPX.GetWindowText(m_ppx); m_Edit_PPY.GetWindowText(m_ppy); // Combo Box , Coge la posisión de los combos m_hus = m_Combo_HUS.GetCurSel(); m_mm = m_Combo_MM.GetCurSel(); // Coge el valor como un string int nIndexNdt = m_Combo_INTERT.GetCurSel(); m_Combo_INTERT.GetLBText(nIndexNdt,m_intert); CDialog::OnOK(); }
Apendice B. HIDRAULICA CODIGO FUENTE C++ ARCHIVOS DE CABECERA: PLEDERFlujoPermanente.h #pragma once //class polilineabuffer; class CrossSectionsBufer; class FGVResultadosBufer; class CPLEDERFlujoPermanente { public: CPLEDERFlujoPermanente(void); ~CPLEDERFlujoPermanente(void); public: //Cálculo del Flujo G. V. en estado subrítico. int FGVFlujoSubcritico(float Q, float h); //Cálculo del Flujo G. V. en estado supercrítico. int FGVFlujoSupercritico(float Q, float h); // Cálculo mediante el método de la Bisección int FGVBiseccionMethod(double Zlower, double Zupper, AcGePoint3dArray Vertices,long BL, long BR, double nLF, double nMC, double nRF, double LLF, double LMC, double LRF, double CC, double CE,double Betai, double Qi, double Ai, double Zsi, double Ki, double *RHidraulicos); // Obtiene la conductividad laterales y centrales int FGVGetConveyanceK(double ALF, double AMC, double ARF, double PLF, double PMC, double PRF, double nLF, double nMC, double nRF, double *KLF, double *KMC, double *KRF, double *K); // Factor de correción Beta int FGVGetCorrectionFactorBeta(double ALF, double AMC, double ARF, double KLF, double KMC, double KRF, double *Betai); // Obtiene la longitud ponderada del tramo i-i+1 int FGVGetLenghtDeltaX(double LLF, double LMC, double LRF, double ALF, double AMC, double ARF, double *dX); // Obtiene la pérdida de fricción en el tramo i-i+1 (hf12) int FGVGetFrictionLosshf(double dX, double Qi1, double Qi, double Ki, double Ki1, double *hfi12); // Función F del Flujo Gradualmente Variado float FGVFuncionF(double Bi1, double Bi, double Qi1, double Qi, double Ai1, double Ai, double Zsi1, double Zsi, double hfi12, double hci12); // Dibuja los niveles de la superficie libre en las secciones transversales. int FGVPlotLevelFreeSurface(double Zsi, double IdST, double Q, double h, AcGePoint2dArray& CSPoligon, double *TopWith); // Libera el burfer de los resultados void FreeAllFGVResultadosBufer(FGVResultadosBufer *theFirstResult); 202 public: //struct CrossSection* m_pSections; // buffer con las secciones transv. struct Vertex* m_pSections; // buffer con las secciones transv. long m_Sections_len; int m_MetodoSf; // Método para calcular la pendiente de fricción float m_htexto; bool computado; public: //FGVResultadosBufer* m_theFirstR; }; PLEDERFlujoPermanenteDlg.h #pragma once #include "resource.h" // Cuadro de diálogo de CPLEDERFlujoPermanenteDlg class CPLEDERFlujoPermanenteDlg : public CAdUiDialog { DECLARE_DYNAMIC(CPLEDERFlujoPermanenteDlg) public: CPLEDERFlujoPermanenteDlg(CWnd* pParent = NULL); // Constructor estándar virtual ~CPLEDERFlujoPermanenteDlg(); // Datos del cuadro de diálogo enum { IDD = IDD_HIDRA_CALC1D }; // Cajas de texto CAcUiNumericEdit m_Edit_Ydowstream; CString m_Ydowstream; CAcUiNumericEdit m_Edit_Yupstream; CString m_Yupstream; CAcUiNumericEdit m_Edit_Caudal; CString m_Caudal; int m_TipoFlujo; protected: virtual void DoDataExchange(CDataExchange* pDX); // Compatibilidad con DDX/DDV afx_msg LRESULT OnAcadKeepFocus (WPARAM, LPARAM) ; // Radio (Cuando existan cambios en el radio) afx_msg void OnRadioFlujoSubcritico(); afx_msg void OnRadioFlujoSupercritico(); afx_msg void OnRadioFlujoMixto(); // Cajas de texto  203 public: virtual BOOL OnInitDialog(); afx_msg void OnBnClickedOk(); DECLARE_MESSAGE_MAP() }; PLEDERHidraB#pragma once // Estructura para calcular Socavaciones struct SocavacionST { double IdST; // Id int Material, // Tipo de material, Cohesivo = 0, No Cohesivo = 1. CoefProb; // Coeficiente de probabilidad de gasto. double CoefMaterial;// Peso específico ó diámetro medio del material de fondo. }; // Estructura para datos Socavaciones hidráulicas. struct Socavacion { int nV; // Número de vértices calculados. double IdST, // Id Zs, // Cota Tirante. At, // Area Total. Pt, // Perímetro Total. Q; // Descarga del flujo. AcGePoint3d GVerticeFlow[MAX_VERTICES]; // Vértices de la sección hidráulica (mojada). }; // Estructura para los perfiles struct Perfiles { double IdST, // Id h, // Tirante. Zs, // Cota Tirante. At, // Area Total. Q, // Descarga del flujo. LMC; // Length main channel }; // Estructura para los resultados struct Resultados { double IdST, // Id h, // Tirante. Zs, // Cota Tirante. Beta, // Coeciente de corrección. ALF, // Area llanura Izquierda. AMC, // Area Canal central. ARF, // Area llanura derecha. PLF, // Perímetro llanura izquierdo. PMC, // Perímetro canal central.  204 PRF, // Perímetro llanura derecho KLF, // Conductividad llanura izquierdo. KMC, // Conductividad canal central. KRF, // Conductividad llanura derecho Q, // Descarga del flujo. hf12, // Pérdida por fircción. hc12, // Pérdida local. TopW; // Espejo de Agua. }; // Estructura para las secciones transversales struct Vertex { double HminG, // Vértice mínimo global. HminL; // Vértice mínimo Local. double IdST; // ID sección transversal long nVST; // Número de vértices de la sección transversal double LL, // Longitud izquierdo. LC, // Longitud central. LR, // Longitud derecho. nL, //Coeficiente de manning banco izquierdo. nC, // Coeficiente de manning canal central. nR, // Coeficiente de manning banco derecho CC, // Coeficiente de contracción. CE; // Coeficiente de expansión. long BL, // Límite banco izquierdo. BR; // Límite banco derecho. AcGePoint3d Vertice[MAX_VERTICES]; }; //Clase CrossSectionsBufer: Bufer para secciones transversales class CrossSectionsBufer { public: CrossSectionsBufer(); //Constructor por defecto, pone Siguiente = NULL; CrossSectionsBufer(AcGePoint2d P1, double X1, double Y1, double IdST, long nVST, AcGePoint2dArray Vertice, double HminG, double HminL, double LL, double LC, double LR, double NL, double NC, double NR, long BL, long BR, double CC, double CE); virtual ~CrossSectionsBufer(); // Destructor public: CrossSectionsBufer *nbnext; // siguiente AcGePoint2d m_P1; // Punto de referecia para los vértices locales. double m_X1, // Distancia de referencia en X. m_Y1, // Cota de referencia en Y. m_HminG, // Vértice mínimo global. m_HminL; // Vértice mínimo Local.  205  double long double long m_IdST; m_nVST; m_LL, m_LC, m_LR, m_NL, m_NC, m_NR, m_CC, m_CE; m_BL, m_BR; // ID sección transversal // Número de vértices de la sección transversal // Longitud izquierdo. // Longitud central. // Longitud derecho. // Coeficiente de manning banco izquierdo. // Coeficiente de manning canal central. // Coeficiente de manning banco derecho // Coeficiente de contracción. // Coeficiente de expansión. // Límite banco izquierdo. // Límite banco derecho. AcGePoint3d m_GlobalVertice[MAX_VERTICES]; // Vértices de las secciones transversales globales AcGePoint3d m_LocalVertice[MAX_VERTICES]; // Vértices de las secciones transversales locales }; //Clase CrossSectionsSocavacionBufer: Bufer para Socavaciones class CrossSectionsSocavacionBufer { public: CrossSectionsSocavacionBufer(); pone Siguiente = NULL; //Constructor por defecto, CrossSectionsSocavacionBufer(double IdST, int Material, int CoefProb, double CoefMaterial); virtual ~CrossSectionsSocavacionBufer(); // Destructor public: CrossSectionsSocavacionBufer *nbnext; // Parámetros para socavación // siguiente int m_Material, // Tipo de material, Cohesivo = 0, No Cohesivo = 1. m_CoefProb; // Coeficiente de probabilidad de gasto. double m_CoefMaterial; // Peso específico ó diámetro medio del material de fondo. double }; m_IdST; // ID sección transversal //Clase FGVResultadosBufer: Bufer para los resultados del flujo class FGVResultadosBufer { public: FGVResultadosBufer (); //Constructor por defecto, pone Siguiente = NULL; FGVResultadosBufer (int nV,AcGePoint2dArray Vertice, double IdST, double h, double Zs, double Beta, double ALF, double AMC,double ARF, double PLF, double PMC, double PRF, double KLF, 206 double KMC,double KRF, double Q, double hf12, double hc12, double TopW, double LMC); virtual ~FGVResultadosBufer(); // Destructor public: FGVResultadosBufer *pRnext; // siguiente public: double m_IdST; // Id int m_nV; double m_h, // Tirante. m_Zs, // Cota Tirante. m_Beta, // Coeciente de corrección. m_ALF, // Area llanura Izquierda. m_AMC, // Area Canal central. m_ARF, // Area llanura derecha. m_PLF, // Perímetro llanura izquierdo. m_PMC, // Perímetro canal central. m_PRF, // Perímetro llanura derecho m_KLF, // Conductividad llanura izquierdo. m_KMC, // Conductividad canal central. m_KRF, // Conductividad llanura derecho m_Q, // Descarga del flujo. m_hf12, // Pérdida por fircción. m_hc12, // Pérdida local. m_TopW, // Espejo de Agua. m_LMC; // Longitud del canal central. AcGePoint3d m_ResultVertice[MAX_VERTICES]; // Vértices de las secciones transversales resultados }; //Clase SeccionesBufer: Bufer para seciones transversales desde importacion Excel class SeccionesBufer { public: SeccionesBufer ();//Constructor por defecto, pone Siguiente = NULL; SeccionesBufer (int nss, double CoordX, double CoordY, double manning); public: SeccionesBufer *ObtenerSiguiente(); // Obtener siguiente void PonerSiguiente(SeccionesBufer *p);// Poner siguiente virtual ~SeccionesBufer(); // Destructor public: SeccionesBufer *Siguiente;// Puntero a SeccionesBufer Siguiente int ns; // Número de secciones double CoordX, CoordY , manning; // Cordenadas X y Y, manning };  207  class PerfilesBufer { public: PerfilesBufer(); //Constructor por defecto PerfilesBufer(int nST, ads_point v0, ads_point v1); virtual ~PerfilesBufer(); public: // Destructor PerfilesBufer *SiguienteP;// Puntero a SeccionesBufer Siguiente float nST; ads_point start; ads_point }; uffer.h end; PLEDERHidraSecTrasnv.h #pragma once // inicio // final #define PUNFILEEXT _T("st;sec;abia;txt") // Extensiones para el fichero de Secciones Transversales #define DCEXP 3 // Decimales para las Secciones Trasnversales exportados #define GETLINEMAXBUFF 1024 // 1 kB Tamaño de buffer de lectura líneas de ficheros #define PUNFILESEP" ,\t\n" Secciones Trasnversales //class polilineabuffer; class SeccionesBufer; //Clase HidraSecTrasnv class HidraSecTrasnv { public: HidraSecTrasnv(void); public: ~HidraSecTrasnv(void); public: // Separador de campos en el fichero de // Retorna EL Número de Vértices de una polilinea int NumeroVerticesPolilinea(ads_name nombrep, long *nVST); // Almacena las coordenadas de una polilinea (ST) en la consola en coordenadas locales int LeerVerticesPolilineaConsola(ads_name nombrep, ads_point p1,double X1, double Y1, int contador); // Almacena las coordenadas de una polilinea (ST) en listas en coordenadas locales int LeerVerticesPolilineaLista(ads_name nombrep, ads_point p1,double X1, double Y1, double* CX, double* CY); 208  // Almacena las coordenadas de una polilinea (ST) en listas sin alteraciones de coordenadas int LeerVerticesPolilinea(ads_name nombrep, double* CX, double* CY); // Importar las Secciones Transversales desde un archivo int ImportarSeccionesTransversales(const TCHAR *pNombreArchivo,long *NumeroVertST); // Obtiene los datos del buffer SeccionesBufer int ObtenerSeccionesTransversales(); //Libera el buffer en ristra SeccionesBufer void LiberarBufferSeccionesTransv(); public: SeccionesBufer* }; pPrimerST; PLEDERRecursosSuperficieLibre.h #pragma once #include "PLEDERSuperficieLibre.h" class CRecursosSuperficieLibre { public: CRecursosSuperficieLibre(void); public: ~CRecursosSuperficieLibre(void); public: //Puntero primer elemento ST. a la clase SeccionesBufer. // Calcula el números de vértices para cada Sección Transversal. int NumeroVerticesCadaST(float *V, int n, int nST, float *nVert); // Calcula los Vértices Máximos y Mínimos. int VerticesMaximosMinimos(float *CY, int nST, float *nVert, float *Vmin, float *Vmax); // Pediente Motriz I12(Sfm) double PendienteMotrizSfm(float K1,float K2, float Q, float nn, int MetodoSfm); float CRecursosSuperficieLibre::NumeroFroude(float Q, float A, float dA ); public: // Calcula el Area y el Perímetro. int AreaPerimetro(int inicio, int fin, float CotaTirante, float *CX, float *CY, double *Area, double *Perimetro); 209  // Calcula el Area , Perímetro, Derivada del Area y Derivada del Perímetro. int AreaPerimetroDerivadas(int inicio, int fin, float CotaTirante, float *CX, float *CY, double *Area, double *Perimetro,double *dArea, double *dPerimetro); }; PLEDERResutadosDlg.h #pragma once //------------------------------------------------------------------- class FGVResultadosBufer; #include "adui.h" #include "PLEDERReportCtrl.h" #include "resource.h" //-------------------------------------------------------------------- class CPLEDERResutadosDlg : public CAdUiDialog { DECLARE_DYNAMIC (CPLEDERResutadosDlg) public: static BOOL CALLBACK ItemdataProc(DWORD dwData, LPARAM lParam); CPLEDERResutadosDlg (CWnd *pParent =NULL, HINSTANCE hInstance =NULL) ; virtual ~CPLEDERResutadosDlg(); // Datos del cuadro de diálogo enum { IDD = IDD_HIDRA_RESULT} ; // DAtos Tabla CReportCtrl m_wndListR; BOOL m_bFullRow; BOOL m_bGridLines; BOOL m_bCheckboxes; // Cajas de texto CAcUiNumericEdit m_Edit_Rx; CString m_Rx; CAcUiNumericEdit m_Edit_Ry; CString m_Ry; // Botones (Sólo CAD) CAcUiPickButton m_PickButton_RPunto; protected: virtual void DoDataExchange (CDataExchange *pDX) ; afx_msg LRESULT OnAcadKeepFocus (WPARAM, LPARAM) ; afx_msg void OnButtonRPunto(); public: virtual BOOL OnInitDialog(); afx_msg void OnBnClickedOk(); public: FGVResultadosBufer* struct m_theFirstR; Resultados* m_pRHidraulicos; // Struct buffer para los resultados. 210 long m_Result_len; DECLARE_MESSAGE_MAP() //-------------------------------------------------------------------- // Funciones extras para los resultados public: // Libera los datos de los niveles calculados void FreeAllResultBufs(); // Adquirir o tomar los niveles calculados int AcquireLevelFreeSurface(long *numberL); // Eliminar los niveles calculados int DeleteLevelFreeSurface(bool prompt); } ; PLEDERSeccionesTransversales.h #pragma once class CrossSectionsBufer; class CrossSectionsSocavacionBufer; class CPLEDERSeccionesTransversales { public: CPLEDERSeccionesTransversales(void); ~CPLEDERSeccionesTransversales(void); public: // Libera los datos de las secciones transversales void FreeAllCrossSectionsBufs(); // Libera los datos de las socavaciones void FreeAllCrossSectionsSocavacionBufs(); // Adquirir o tomar las secciones transversales int AcquireCrossSections(long *numberof); // Adquirir o tomar las secciones transversales con socavaciones int AcquireCrossSectionsSocavacion(long *numberof); // Busca en forma ordenada, la primera S.T. int GetFirstNumberCrossSections(long *nfirst); // Busca el último número ST. int GetLastNumberCrossSections(long *nlast); // Contabiliza el número de las S.T. int GetNumberofCrossSections(long *numberof); // Obtiene los atributos de la S.T. int GetCrossSectionsAttributes(); // Encuadra la S.T. a paritr de su ID int ZoomCrossSections(double IdnST); // Obtiene los atributos de la S.T. a partir de su ID  211  int GetIdCrossSectionsAttributes(double IdST, long *nVST, AcGePoint2dArray& LvertexArray,AcGePoint2dArray& GvertexArray, double *LL, double *LC, double *LR, double *NL,double *NC, double *NR, long *BL, long *BR, double *CC, double *CE); // Obtiene los atributos de la S.T. a partir de su ID int GetIdCrossSectionsAttributesSocavacion(double IdST, int *Material, int *CoefProb, double *CoefMaterial); // Obtiene el vértice mínino int GetMinVertice(double *VerticeY, long nVert, double *Hmin); // Obtener las áreas-perímetros laterales y área-perímetro central. int GetAreaPerimeter(double CotaTirante, AcGePoint3dArray LvertexArray,long BL, long BR, double *ALF , double *AMC, double *ARF,double *PLF, double *PMC, double *PRF, double *A, double *P); int GetAreaPoligon(AcGePoint2dArray VerticesPoligon, double *Area); public: CrossSectionsBufer* m_theFirstST; CrossSectionsSocavacionBufer* m_theFirstSOC; double m_STTextHeight; double }; m_STDiameter; PLEDERSeccionesTransversalesDlg.h #pragma once #include "PLEDERReportCtrl.h" #include "PLEDERSeccionesTransversales.h" #include "resource.h" // Cuadro de diálogo de CPLEDERSeccionesTransversalesDlg class CPLEDERSeccionesTransversalesDlg : public CAdUiDialog { DECLARE_DYNAMIC(CPLEDERSeccionesTransversalesDlg) public: static BOOL CALLBACK ItemdataProc(DWORD dwData, LPARAM lParam); CPLEDERSeccionesTransversalesDlg(CWnd* pParent = NULL); Constructor estándar virtual ~CPLEDERSeccionesTransversalesDlg(); // Datos del cuadro de diálogo enum { IDD = IDD_HIDRA_ST }; // DAtos Tabla CReportCtrl m_wndList; BOOL m_bFullRow; BOOL m_bGridLines; // 212  BOOL m_bCheckboxes; // Cajas de texto CAcUiNumericEdit m_Edit_LI; CString m_LI; CAcUiNumericEdit m_Edit_LC; CString m_LC; CAcUiNumericEdit m_Edit_LD; CString m_LD; CAcUiNumericEdit m_Edit_BI; CString m_BI; CAcUiNumericEdit m_Edit_BD; CString m_BD; CAcUiNumericEdit m_Edit_NI; CString m_NI; CAcUiNumericEdit m_Edit_NC; CString m_NC; CAcUiNumericEdit m_Edit_ND; CString m_ND; CAcUiNumericEdit m_Edit_CC; CString m_CC; CAcUiNumericEdit m_Edit_CE; CString m_CE; // Combo Box CComboBox m_Combo_ST; CString m_Id_ST; double m_IdST; // Botones (Sólo CAD) CAcUiPickButton m_PickButton_ST; CAcUiPickButton m_PickButton_LI; CAcUiPickButton m_PickButton_LC; CAcUiPickButton m_PickButton_LD; CAcUiPickButton m_PickButton_BI; CAcUiPickButton m_PickButton_BD; // Botones (Dialogo general) protected: virtual void DoDataExchange(CDataExchange* pDX); Compatibilidad con DDX/DDV afx_msg LRESULT OnAcadKeepFocus (WPARAM, LPARAM) ; afx_msg void OnKillfocusEdit_BI(); afx_msg void OnKillfocusEdit_BD(); afx_msg void OnKillfocusEdit_CC(); // 213  afx_msg void OnKillfocusEdit_CE(); // Combo Box (Cuando existan cambios en el combo) afx_msg void OnKillfocusComboST(); // Botones (Sólo CAD) afx_msg void OnButtonST(); afx_msg void OnButtonLI(); afx_msg void OnButtonLC(); afx_msg void OnButtonLD(); afx_msg void OnButtonBI(); afx_msg void OnButtonBD(); // Botones afx_msg void OnCommandAPLICAR(); // Botones Menú afx_msg void OnCommandSTN(); public: virtual BOOL OnInitDialog(); public: double OnButtonDistancia(); public: struct Vertex* long m_pSections;// buffer con las secciones transv. m_Sections_len; // Variables Socavación Adesk::Int32 m_Material, // Tipo de material, Cohesivo = 0, No Cohesivo = 1. m_CoefProb; // Ubicación en la lista (combo) coeficiente de probabilidad de gasto. double m_CoefMaterial; DECLARE_MESSAGE_MAP() }; // Peso específico ó diámetro medio del material de fondo. /*------------------------------------------------------------------*/ // Cuadro de diálogo de CPLEDERST1Dlg class CPLEDERST1Dlg : public CDialog { DECLARE_DYNAMIC(CPLEDERST1Dlg) public: CPLEDERST1Dlg(CWnd* pParent = NULL); virtual ~CPLEDERST1Dlg(); // Datos del cuadro de diálogo enum { IDD = IDD_HIDRA_NST }; // Cajas de texto CAcUiNumericEdit m_Edit_NST; // Constructor estándar 214 CString m_NST; protected: virtual void DoDataExchange(CDataExchange* pDX); // Compatibilidad con DDX/DDV public: afx_msg void OnBnClickedOk(); DECLARE_MESSAGE_MAP() };  215 ARCHIVOS Cpp: PLEDERFlujoPermanente.cpp #include "StdAfx.h" #include "PLEDERFlujoPermanente.h" #include "PLEDERSeccionesTransversales.h" #include "PLEDERHidraBuffer.h" #include "PLEDERRecursosCad.h" CPLEDERSeccionesTransversales CST; CRecursosCad RecursosFGV; CPLEDERFlujoPermanente::CPLEDERFlujoPermanente(void) { m_MetodoSf = 0; // Por defecto, método de la media aritmética. m_htexto = 0.50; } CPLEDERFlujoPermanente::~CPLEDERFlujoPermanente(void) { } int CPLEDERFlujoPermanente::FGVFlujoSubcritico(float Q, float h) /*-------------------------------------------------------------------- Ingreso : Q = Descarga del flujo a transitar. h = Tirante Inicial de las secciones transversales. Salida : RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Calcula los miveles de la superficie libre mediante el fluijo subcrítico. Observación: Los resultado los alamceno en una matriz cuya notación es como sigue: RHidraulicos[0] = HminL RHidraulicos[1] = Zsi1 -> Tirante del agua calculado. RHidraulicos[2] = Betai1. RHidraulicos[3] = ALF. RHidraulicos[4] = AMC. RHidraulicos[5] = ARF. RHidraulicos[6] = PLF. RHidraulicos[7] = PMC. RHidraulicos[8] = PRF. RHidraulicos[9] = KLF. RHidraulicos[10] = KMC. RHidraulicos[11] = KRF. RHidraulicos[12] = Qi. RHidraulicos[13] = hfi12. RHidraulicos[14] = hci12. --------------------------------------------------------------------*/ { double Ai, ALF, AMC, ARF, Pi, PLF, PMC, PRF, Ki, KLF, KMC, KRF, Betai, Qi; double Ai1, Pi1, Ki1, Betai1, Qi1, hfi12, hci12, Zlower, Zupper, Zsi, Zsi1; double nL, nC, nR, LL, LC, LR, CC, CE; long BL, BR; int i, j; double RHidraulicos[16], TextHight = 0.16, TopWith; AcGePoint3dArray Vertices;  216  AcGePoint3d Vertex; AcGePoint2dArray Poligon; // Poligono de la S.T. // Cálculos en la primera sección transversal (Dowstream) Qi = Q; for (i = 0; i < (m_pSections + m_Sections_len-1)->nVST ; i++) { // Vértices Vertex[X] = (m_pSections + m_Sections_len-1)->Vertice[i].x; Vertex[Y] = (m_pSections + m_Sections_len-1)->Vertice[i].y; Vertices.append(Vertex); } BL = (m_pSections + m_Sections_len-1)->BL; BR = (m_pSections + m_Sections_len-1)->BR; nL = (m_pSections + m_Sections_len-1)->nL; nC = (m_pSections + m_Sections_len-1)->nC; nR = (m_pSections + m_Sections_len-1)->nR; Zsi = (m_pSections + m_Sections_len-1)->HminL +h; // Cota del tirante CST.GetAreaPerimeter(Zsi, Vertices, BL, BR, &ALF, &AMC, &ARF, &PLF, &PMC, &PRF, &Ai, &Pi); // Cálculo de K laterales y central FGVGetConveyanceK(ALF, AMC, ARF, PLF, PMC, PRF,nL, nC, nR, &KLF, &KMC, &KRF , &Ki); // Cálculo del Coeficiente de Corrección (Betai) FGVGetCorrectionFactorBeta(ALF, AMC, ARF, KLF, KMC, KRF, &Betai); acutPrintf(_T("\nZsi = %0.3f"),Zsi); Poligon.removeAll(); FGVPlotLevelFreeSurface(Zsi, (m_pSections + m_Sections_len-1) >IdST , Q, Zsi - (m_pSections + m_Sections_len-1)->HminL, Poligon, &TopWith); acutPrintf(_T("\nSeccion = %0.3f"),(m_pSections + m_Sections_len-1)->IdST); // Guardo los valores en la matriz RHidraulicos[0] = (m_pSections + m_Sections_len-1)->HminL; RHidraulicos[1] = Zsi; RHidraulicos[2] = Betai; RHidraulicos[3] RHidraulicos[4] RHidraulicos[5] RHidraulicos[6] RHidraulicos[7] RHidraulicos[8] RHidraulicos[9] = ALF; = AMC; = ARF; = PLF; = PMC; = PRF; = KLF; RHidraulicos[10]= KMC; RHidraulicos[11]= KRF; RHidraulicos[12]= Qi; RHidraulicos[13]= 0.0; RHidraulicos[14]= 0.0; RHidraulicos[15]= TopWith; // Pérdida por fircción. // Pérdida local. // Espejo del Agua LC = (m_pSections + m_Sections_len-1)->LC; 217 // Crea la entidad personalizada PLEDERHydraulicResult desde ObjectDBX CPLEDERHydraulicResult *pResultados; // crear la nueva entidad try { pResultados = new CPLEDERHydraulicResult((m_pSections + m_Sections_len-1)->IdST, Poligon, RHidraulicos,LC, TextHight); } catch(const std::bad_alloc&) { acdbFail(_T("\nError de asignación de memoria.")); return RTERROR; } AcDbObjectId ID; // añadirla a la base de datos de AutoCAD if (RecursosFGV.AñadirEntidadBlockTableRecord((AcDbEntity*)pResulta dos, ID) != Acad::eOk) { if (pResultados) { delete pResultados; } acdbFail(_T("\nError al añadir la entidad a la Base de Datos [AñadirEntidadBlockTableRecord].")); return RTERROR; } // Restaurando los valores ALF = AMC = ARF = PLF = PMC = PRF = KLF = KMC = KRF =0.0; // Iterar en las siguientes secciones transversales. for (j = m_Sections_len - 2; j >= 0; j--) { Vertices.removeAll(); acutPrintf(_T("\nID Sección transversal Nº: %0.3f"),(m_pSections + j)->IdST); for (i = 0; i < (m_pSections + j)->nVST; i++) { // Vértices Vertex[X] = (m_pSections + j)->Vertice[i].x; Vertex[Y] = (m_pSections + j)->Vertice[i].y; Vertices.append(Vertex); } // for i Zlower = (m_pSections + j)->HminL; // Cota mínima. Zupper = Zsi + 5; // Corregir BL = (m_pSections + j)->BL; BR = (m_pSections + j)->BR; nL = (m_pSections + j)->nL; nC = (m_pSections + j)->nC; nR = (m_pSections + j)->nR; LL = (m_pSections + j)->LL; LC = (m_pSections + j)->LC; LR = (m_pSections + j)->LR; CC = (m_pSections + j)->CC; CE = (m_pSections + j)->CE;  218  RHidraulicos[0] = Zlower; FGVBiseccionMethod(Zlower, Zupper, Vertices, BL, BR, nL, nC, nR, LL, LC, LR, CC, CE, Betai, Qi,Ai, Zsi, Ki, RHidraulicos); // Reasigna los nuevos valores, para las sigueintes iteraciones. Betai = RHidraulicos[2]; // Betai1 Ai = RHidraulicos[3]+ RHidraulicos[4]+ RHidraulicos[5]; // ALF+AMC+ARF Zsi = RHidraulicos[1]; // Zsi1; Ki = RHidraulicos[9]+ RHidraulicos[10]+ RHidraulicos[11];// KLF+KMC+KRF acutPrintf(_T("\nZsi = %0.3f"),Zsi); Poligon.removeAll(); // Eliminar todos lo datos de esta natriz // Captura los vértices de la secciones transversal calculado FGVPlotLevelFreeSurface(Zsi, (m_pSections + j)->IdST, Q , Zsi-(m_pSections + j)->HminL, Poligon, &TopWith); RHidraulicos[15]= TopWith; // Espejo del Agua // Crea la entidad personalizada PLEDERHydraulicResult desde ObjectDBX CPLEDERHydraulicResult *pResultados; // crear la nueva entidad try { } pResultados = new CPLEDERHydraulicResult((m_pSections + j)->IdST, Poligon, RHidraulicos,LC, TextHight); catch(const std::bad_alloc&) { acdbFail(_T("\nError de asignación de memoria.")); return RTERROR; } AcDbObjectId ID; // añadirla a la base de datos de AutoCAD if (RecursosFGV.AñadirEntidadBlockTableRecord((AcDbEntity*)pRe sultados, ID) != Acad::eOk) { if (pResultados) { delete pResultados; } acdbFail(_T("\nError al añadir la entidad a la Base de Datos [AñadirEntidadBlockTableRecord].")); return RTERROR; } } // for j 219 return RTNORM; } int CPLEDERFlujoPermanente::FGVFlujoSupercritico(float Q, float h) /*-------------------------------------------------------------------- Ingreso : Q = Descarga del flujo a transitar. h = Tirante Inicial de las secciones transversales. Salida : RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Calcula los miveles de la superficie libre mediante el fluijo supercrítico. Observación: Los resultado los alamceno en una matriz cuya notación es como sigue: RHidraulicos[0] = HminL RHidraulicos[1] = Zsi1 -> Tirante del agua calculado. RHidraulicos[2] = Betai1. RHidraulicos[3] = ALF. RHidraulicos[4] = AMC. RHidraulicos[5] = ARF. RHidraulicos[6] = PLF. RHidraulicos[7] = PMC. RHidraulicos[8] = PRF. RHidraulicos[9] = KLF. RHidraulicos[10] = KMC. RHidraulicos[11] = KRF. RHidraulicos[12] = Qi. RHidraulicos[13] = hfi12. RHidraulicos[14] = hci12. --------------------------------------------------------------------*/ { double Ai, ALF, AMC, ARF, Pi, PLF, PMC, PRF, Ki, KLF, KMC, KRF, Betai, Qi; double Ai1, Pi1, Ki1, Betai1, Qi1, hfi12, hci12, Zlower, upper, Zsi, Zsi1; double nL, nC, nR, LL, LC, LR, CC, CE; long BL, BR; int i, j; double RHidraulicos[16], TextHight = 0.16, TopWith; AcGePoint3dArray Vertices; AcGePoint3d Vertex; AcGePoint2dArray Poligon; // Poligono de la S.T. // Cálculos en la primera sección transversal (Upstream) Qi = Q; for (i = 0; i < (m_pSections + m_Sections_len-1)->nVST ; i++) { // Vértices Vertex[X] = m_pSections->Vertice[i].x; Vertex[Y] = m_pSections->Vertice[i].y; Vertices.append(Vertex); } BL = m_pSections->BL; BR = m_pSections->BR; nL = m_pSections->nL; nC = m_pSections->nC; nR = m_pSections->nR;  220  Zsi = m_pSections->HminL +h; // Cota del tirante CST.GetAreaPerimeter(Zsi, Vertices, BL, BR, &ALF, &AMC, &ARF, &PLF, &PMC, &PRF, &Ai, &Pi); // Cálculo de K laterales y central FGVGetConveyanceK(ALF, AMC, ARF, PLF, PMC, PRF,nL, nC, nR, &KLF, &KMC, &KRF , &Ki); // Cálculo del Coeficiente de Corrección (Betai) FGVGetCorrectionFactorBeta(ALF, AMC, ARF, KLF, KMC, KRF, &Betai); acutPrintf(_T("\nZsi = %0.3f"),Zsi); Poligon.removeAll(); FGVPlotLevelFreeSurface(Zsi, m_pSections->IdST , Q, Zsi - m_pSections->HminL, Poligon, &TopWith); acutPrintf(_T("\nSeccion = %0.3f"),m_pSections->IdST); // Guardo los valores en la matriz RHidraulicos[0] = m_pSections->HminL; RHidraulicos[1] = Zsi; RHidraulicos[2] = Betai; RHidraulicos[3] RHidraulicos[4] RHidraulicos[5] RHidraulicos[6] RHidraulicos[7] RHidraulicos[8] RHidraulicos[9] = ALF; = AMC; = ARF; = PLF; = PMC; = PRF; = KLF; RHidraulicos[10]= KMC; RHidraulicos[11]= KRF; RHidraulicos[12]= Qi; RHidraulicos[13]= 0.0; RHidraulicos[14]= 0.0; RHidraulicos[15]= TopWith; LC = m_pSections->LC; // Pérdida por fircción. // Pérdida local. // Espejo del Agua // Crea la entidad personalizada PLEDERHydraulicResult desde ObjectDBX CPLEDERHydraulicResult *pResultados; // crear la nueva entidad try { pResultados = new CPLEDERHydraulicResult(m_pSections->IdST, Poligon, RHidraulicos,LC, TextHight); } catch(const std::bad_alloc&) { acdbFail(_T("\nError de asignación de memoria.")); return RTERROR; } AcDbObjectId ID; // añadirla a la base de datos de AutoCAD 221 if (RecursosFGV.AñadirEntidadBlockTableRecord((AcDbEntity*)pResultados, ID) != Acad::eOk) { if (pResultados) { delete pResultados; } acdbFail(_T("\nError al añadir la entidad a la Base de Datos [AñadirEntidadBlockTableRecord].")); return RTERROR; } // Restaurando los valores ALF = AMC = ARF = PLF = PMC = PRF = KLF = KMC = KRF =0.0; // Iterar en las siguientes secciones tranversales. for (j = 1; j < m_Sections_len; j++) { Vertices.removeAll(); acutPrintf(_T("\nID Sección transversal Nº: %0.3f"),(m_pSections + j)->IdST); for (i = 0; i < (m_pSections + j)->nVST; i++) { // Vértices Vertex[X] = (m_pSections + j)->Vertice[i].x; Vertex[Y] = (m_pSections + j)->Vertice[i].y; Vertices.append(Vertex); } // for i Zlower = (m_pSections + j)->HminL; // Cota mínima. Zupper = Zsi + 5; // Corregir BL = (m_pSections + j)->BL; BR = (m_pSections + j)->BR; nL = (m_pSections + j)->nL; nC = (m_pSections + j)->nC; nR = (m_pSections + j)->nR; LL = (m_pSections + j)->LL; LC = (m_pSections + j)->LC; LR = (m_pSections + j)->LR; CC = (m_pSections + j)->CC; CE = (m_pSections + j)->CE; RHidraulicos[0] = Zlower; FGVBiseccionMethod(Zlower, Zupper, Vertices, BL, BR, nL, nC, nR, LL, LC, LR, CC, CE, Betai, Qi, Ai, Zsi, Ki, RHidraulicos); // Reasigna los nuevos valores, para las sigueintes iteraciones. Betai = RHidraulicos[2]; // Betai1 Ai = RHidraulicos[3]+ RHidraulicos[4]+ RHidraulicos[5]; // ALF+AMC+ARF Zsi = RHidraulicos[1]; // Zsi1; Ki = RHidraulicos[9]+ RHidraulicos[10]+ RHidraulicos[11];// KLF+KMC+KRF acutPrintf(_T("\nZsi = %0.3f"),Zsi); Poligon.removeAll(); // Eliminar todos lo datos de esta natriz // Captura los vértices de la secciones transversal calculado  222 FGVPlotLevelFreeSurface(Zsi, (m_pSections + j)->IdST, Q , Zsi-(m_pSections + j)->HminL, Poligon, &TopWith); RHidraulicos[15]= TopWith; // Espejo del Agua // Crea la entidad personalizada PLEDERHydraulicResult desde ObjectDBX CPLEDERHydraulicResult *pResultados; // crear la nueva entidad try { pResultados = new CPLEDERHydraulicResult((m_pSections + j)->IdST, Poligon, RHidraulicos,LC, TextHight); } catch(const std::bad_alloc&) { acdbFail(_T("\nError de asignación de memoria.")); return RTERROR; } AcDbObjectId ID; // añadirla a la base de datos de AutoCAD if (RecursosFGV.AñadirEntidadBlockTableRecord((AcDbEntity*)pRe sultados, ID) != Acad::eOk) { if (pResultados) { delete pResultados; } acdbFail(_T("\nError al añadir la entidad a la Base de Datos [AñadirEntidadBlockTableRecord].")); return RTERROR; } } // for j return RTNORM; } int CPLEDERFlujoPermanente::FGVBiseccionMethod(double Zlower, double Zupper, AcGePoint3dArray Vertices,long BL, long BR, double nLF, double nMC, double nRF, double LLF, double LMC, double LRF, double CC, double CE, double Betai, double Qi, double Ai, double Zsi, double Ki, double *RHidraulicos) /*-------------------------------------------------------------------- Ingreso : Zlower = Extremo valor inferior ( Nivel mínimo del agua) Zupper = Extremo valor superior Salida : RHidraulicos[0] = HminL RHidraulicos[1] = Zsi1 -> Tirante del agua calculado. RHidraulicos[2] = Betai1. RHidraulicos[3] = ALF. RHidraulicos[4] = AMC.  223 RHidraulicos[5] = ARF. RHidraulicos[6] = PLF. RHidraulicos[7] = PMC. RHidraulicos[8] = PRF. RHidraulicos[9] = KLF. RHidraulicos[10] = KMC. RHidraulicos[11] = KRF. RHidraulicos[12] = Qi. RHidraulicos[13] = hfi12. RHidraulicos[14] = hci12. RHidraulicos[14] = TopWith. Propósito : Calcula El nivel del agua mediante el método de Bisección. --------------------------------------------------------------------*/ { double Zmiddle, // Cota promedio entre ambos cotas estremas de ingreso. Flower, // Cota inferior (siempre inicia desde la cota mínima o thalweg) Fmiddle, // Función que se evalúa con la cota promedio. Fupper, // Función que se evalúa con la cota superior hfi12, // Pérdida por fricción hci12, // Pérdida local Qi1, dX; double ALF, AMC, ARF, Ai1, PLF, PMC, PRF, Pi1, KLF, KMC, KRF, Ki1, Betai1; double Zsi1; Qi1 = Qi; // para este caso bool NOencontrado = true; int cont = 0; while(NOencontrado) { cont++; //acutPrintf(_T("\nIteracion en Biseccion = %d"),cont); Zmiddle = (Zlower + Zupper)/2; CST.GetAreaPerimeter(Zmiddle, Vertices, BL, BR, &ALF, &AMC,&ARF, &PLF, &PMC, &PRF , &Ai1, &Pi1); FGVGetConveyanceK(ALF, AMC, ARF, PLF, PMC, PRF, nLF, nMC, nRF, &KLF, &KMC, &KRF , &Ki1); FGVGetCorrectionFactorBeta(ALF, AMC, ARF, KLF, KMC, KRF, &Betai1); FGVGetLenghtDeltaX(LLF, LMC, LRF, ALF, AMC, ARF, &dX); FGVGetFrictionLosshf(dX, Qi1, Qi, Ki, Ki1, &hfi12); hci12 = 0.0; // Por el momento. Fmiddle = FGVFuncionF(Betai1, Betai, Qi1, Qi, Ai1, Ai, Zmiddle, Zsi, hfi12, hci12); // Primera verificación if (abs(Fmiddle) < TOL) { Zsi1 = Zmiddle;  224 NOencontrado = false; acutPrintf(_T("\nLo encontre en 01, en %d iteraciones"), cont); } // Preparando para la siguiente iteración Flower = FGVFuncionF(Betai1, Betai, Qi1, Qi, Ai1, Ai, Zlower , Zsi, hfi12, hci12); Fupper = FGVFuncionF(Betai1, Betai, Qi1, Qi, Ai1, Ai, Zupper , Zsi, hfi12, hci12); if( Fmiddle*Flower < 0.0) { Zupper = Zmiddle; } else { Zlower = Zmiddle; } // Segunda verificación if (abs(Zupper - Zlower) < TOL) { Zsi1 = (Zupper + Zlower)/2; NOencontrado = false; acutPrintf(_T("\nLo encontre en 02, en %d iteraciones"), cont); } } // While // Guardando los resultados en la matriz definida RHidraulicos[1] = Zsi1; RHidraulicos[2] = Betai1; RHidraulicos[3] = ALF; RHidraulicos[4] = AMC; RHidraulicos[5] = ARF; RHidraulicos[6] = PLF; RHidraulicos[7] = PMC; RHidraulicos[8] = PRF; RHidraulicos[9] = KLF; RHidraulicos[10]= KMC; RHidraulicos[11]= KRF; RHidraulicos[12]= Qi; RHidraulicos[13]= hfi12; RHidraulicos[14]= hci12; return RTNORM; } int CPLEDERFlujoPermanente::FGVGetConveyanceK(double ALF, double AMC, double ARF, double PLF, double PMC, double PRF, double nLF, double nMC, double nRF, double *KLF, double *KMC, double *KRF, double *K) /*-------------------------------------------------------------------- Ingreso : ALF = Area Left Floodplain. AMC = Area Main Channel. ARF = Area Right Floodplain. PLF = Perímetro Left Floodplain. PMC = Perímetro Main Channel. PRF = Perímetro Right Floodplain. nLF = Manning Left.  225 nMC = Manning Center. nRF = Manning Right. Salida : KLF = Conductividad Left Floodplain. KMC = Conductividad Main Channel. KRF = Conductividad Right Floodplain. K = Conductividad Total RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Calcula la conductividad --------------------------------------------------------------------*/ { double exp53 = 5.0/3.0, exp23 = 2.0/3.0; *KLF = 0.0; *KMC = 0.0; *KRF = 0.0; // Cálculo de la Conductividad KLF (Izquierdo) if (PLF != 0.0) { *KLF = pow(ALF,exp53)/ (nLF * pow(PLF,exp23)); } // Cálculo de la Conductividad KMC (Principal) if (PMC != 0.0) { *KMC = pow(AMC,exp53)/ (nMC * pow(PMC,exp23)); } // Cálculo de la Conductividad KRF (Derecha) if (PRF != 0.0) { *KRF = pow(ARF,exp53)/ (nRF * pow(PRF,exp23)); } // Conductividad Total (K) *K = *KLF + *KMC + *KRF; return RTNORM; } int CPLEDERFlujoPermanente::FGVGetCorrectionFactorBeta(double ALF, double AMC, double ARF, double KLF, double KMC, double KRF, double *Betai) /*-------------------------------------------------------------------- Ingreso : ALF = Area Left Floodplain. AMC = Area Main Channel. ARF = Area Right Floodplain. KLF = Conductividad Left Floodplain. KMC = Conductividad Main Channel. KRF = Conductividad Right Floodplain. Salida : Betai = Factor decorreción Beta (ver la teoría) RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Calcula El factor de correción Beta --------------------------------------------------------------------*/ { double BetaLF = 0.0, BetaMC = 0.0, BetaRF = 0.0, Ai = ALF + AMC + ARF, Ki = KLF + KMC + KRF;  226 // (Izquierdo) if (ALF != 0.0) { BetaLF = pow(KLF,3.0) / pow(ALF,2.0); } // (Principal) if (AMC != 0.0) { BetaMC = pow(KMC,3.0) / pow(AMC,2.0); } // (Derecha) if (ARF != 0.0) { BetaRF = pow(KRF,3.0) / pow(ARF,2.0); } *Betai = pow(Ai,2.0)/pow(Ki,3.0) * (BetaLF + BetaMC + BetaRF); return RTNORM; } int CPLEDERFlujoPermanente::FGVGetLenghtDeltaX(double LLF, double LMC, double LRF, double ALF, double AMC, double ARF, double *dX) /*-------------------------------------------------------------------- Ingreso : LLF = Longitud del banco izquierdo (Left bank length ). LMC = Longitud del canal central (Main Channel length). LRF = Longitud del banco derecho (Right banl length) ALF = Area Left Floodplain. AMC = Area Main Channel. ARF = Area Right Floodplain. Salida : dX = Es la distancia ponderada de la sección transversal RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Calcula la distancia ponderada entre una sección transversal. Promedia bajo el area de cada tramo (tres tramos) bajo el área total del flujo. --------------------------------------------------------------------*/ { *dX = (LLF*ALF + LMC*AMC + LRF*ARF) /(ALF + AMC + ARF); return RTNORM; } int CPLEDERFlujoPermanente::FGVGetFrictionLosshf(double dX, double Qi1, double Qi, double Ki, double Ki1, double *hfi12) /*-------------------------------------------------------------------- Ingreso : dX = Longitud ponderado para el tramo. Qi1 = Descarga del flujo en la estación i+1. Qi = Descarga del flujo en la estación i.  227 Ki1 = Factor de conductividad en la estación i+1. Ki = Factor de conductividad en la estación i. Salida : hfi12 = La pérdida de fricción calculado para este tramo. RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Calcula la pérdida de fricción en el tramo i-i+1 (hf12) --------------------------------------------------------------------*/ { switch (m_MetodoSf) { case 0: // Media Aritmética. { *hfi12 = 0.5*dX*( Qi1*abs(Qi1)/(Ki1*Ki1) + Qi*abs(Qi)/(Ki*Ki)); break; } case 1: // Media Armónica. { *hfi12 = 2.0*dX/(Ki1*Ki1 /(Qi1*abs(Qi1)) + Ki*Ki /(Qi*abs(Qi))); break; } case 2: // Ecuación de Factor de transporte Medio. { *hfi12 = dX*pow((Qi1 + Qi)/(Ki1 + Ki),2.0); break; } case 3: // Media Geométrica. { *hfi12 = dX *pow( Qi1*abs(Qi1)*Qi*abs(Qi)/(Ki1*Ki1 + Ki*Ki),0.5); break; } default: acutPrintf(_T("\nFuera de Rango")); } //switch (m_MetodoSf)) return RTNORM; } float CPLEDERFlujoPermanente::FGVFuncionF(double Bi1, double Bi, double Qi1, double Qi, double Ai1, double Ai, double Zsi1, double Zsi, double hfi12, double hci12) /*-------------------------------------------------------------------- Ingreso : Bi1 = Factor de Correción Beta en la estación i+1. Bi = Factor de Correción Beta en la estación i. Qi1 = Descarga del flujo en la estación i+1. Qi = Descarga del flujo en la estación i Ai1 = Area de la sección transversal en la estación i+1. Ai =Area de la sección transv. en la estación i.  228 Zi1 = Cota del nivel de agua en la estación i+1. (valor a encontrar) Zi = Cota del nivel de agua en la estación i. hfi12 = Pérdida por fricción en el tramo i+1/2. hci12 = Pérdida Local en el tramo i+1/2. Salida : F = Función del Flujo gradualmente variado. Propósito : Calcula la función F para la iteración utilizando el método de Bisección. --------------------------------------------------------------------*/ { double F; F = Bi1*Qi1*Qi1/(2*g*Ai1*Ai1) - Bi*Qi*Qi/(2*g*Ai*Ai) + Zsi1 -Zsi + hfi12 + hci12; return F; } int CPLEDERFlujoPermanente::FGVPlotLevelFreeSurface(double Zsi, double IdST, double Q, double h, AcGePoint2dArray& CSPoligon, double *TopWith) /*-------------------------------------------------------------------- Ingreso : Zis = Cota del nivel de agua en la estación i. IdST = Id de la sección transversal Q = Descarga del flujo (m3/s) h = Tirante (m) Salida : CSPoligon = Array para almacenar los datos del poligono o sección hidráulico. TopWith = Espejo de agua RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Dibuja los niveles de la superficie libre de las secciones transversales --------------------------------------------------------------------*/ { // Inicializa las variables de sistema. RecursosFGV.InicializarVariables(); // crear las capas del proyecto if (RecursosFGV.PlederCapas() != RTNORM) { RecursosFGV.RestaurarVariables(); return RTERROR; } double X1, Y1, LL, LC, LR, NL, NC, NR, CC, CE; long BL, BR, nVST; double CxL, CxG, CyG, Tw =0.0; TCHAR str[100] , strQ[100], strh[100]; AcGePoint2dArray GlobalVertices; AcGePoint2dArray LocalVertices; ads_point p1, p2, p3; p1[Z] = p2[Z] = p3[Z]= 0.0; // Coger los atributos de la S.T. desde su id CST.GetIdCrossSectionsAttributes(IdST, &nVST, LocalVertices, GlobalVertices, &LL, &LC, &LR, &NL, &NC, &NR, &BL, &BR, &CC, &CE); int j,k;  229  AcGePoint2dArray LVertices; local para reasignar los vértices. AcGePoint2dArray GVertices; Global para reasignar los vértices. AcGePoint2d Vertex; // Traslada los valores hacia la nueva lista YY, XX for (k = 0; k < LocalVertices.length(); k++) { Vertex[X] = LocalVertices[k].x; Vertex[Y] = LocalVertices[k].y; LVertices.append(Vertex); Vertex[X] = GlobalVertices[k].x; Vertex[Y] = GlobalVertices[k].y; GVertices.append(Vertex); } // Variable // Variable bool InundIzquierdo = false; // Por defecto NO Existe Inundación bool InundDerecho = false; // Por defecto NO Existe Inundación // Son condiciones para agregar vértices si el tirante es mayor a los // vértices de las S. T. (casos de inundaciones) // Inundación Margen Izquierda? if (Zsi > LocalVertices[0].y) { LVertices.removeAll(); GVertices.removeAll(); Vertex[X] = LocalVertices[0].x; Vertex[Y] = Zsi; LVertices.append(Vertex); Vertex[X] = GlobalVertices[0].x; Vertex[Y] = GlobalVertices[0].y + (Zsi - LocalVertices[0].y); GVertices.append(Vertex); for (k =0; k < LocalVertices.length(); k++) { Vertex[X] = LocalVertices[k].x; Vertex[Y] = LocalVertices[k].y; LVertices.append(Vertex); Vertex[X] = GlobalVertices[k].x; Vertex[Y] = GlobalVertices[k].y; GVertices.append(Vertex); } InundIzquierdo = true; } // Inundación Margen Derecha? 230 if (Zsi > LocalVertices[LocalVertices.length()-1].y) { Vertex[X] = LocalVertices[LocalVertices.length()-1].x; Vertex[Y] = Zsi; LVertices.append(Vertex); Vertex[X] = GlobalVertices[GlobalVertices.length()-1].x; Vertex[Y] = GlobalVertices[GlobalVertices.length()-1].y + (Zsi - LocalVertices[0].y); GVertices.append(Vertex); InundDerecho = true; } // Buscar los vértices (interpolando) recorrido con el mismo m étodo para el área // Inicio del recorrido de los vértices. for (int j = 0; j < LVertices.length()-1; j++) { // Condición para el extremo izquierdo if ((Zsi <= LVertices[j].y) && (Zsi >= LVertices[j+1].y)) { // Coordenada X En el extremo izquierdo CxL = LVertices[j+1].x - ((LVertices[j+1].x - LVertices[j].x )/(LVertices[j].y - LVertices[j+1].y))*(Zsi - LVertices[j+1].y); // Interpolación simple. if(InundIzquierdo) { CyG = GVertices[0].y; CxG = GVertices[0].x; } else { CyG = GVertices[j+1].y + ((GVertices[j].y - GVertices[j+1].y)/(LVertices[j].y - LVertices[j+1].y))*(Zsi- LVertices[j+1].y); CxG = GVertices[j+1].x + ((GVertices[j].x - GVertices[j+1].x)/(LVertices[j].x - LVertices[j+1].x))*(CxL- LVertices[j+1].x); } Vertex[X] = p1[X] = CxG; Vertex[Y] = p1[Y] = CyG; CSPoligon.append(Vertex); bool condicion = true; while (condicion) { j++; // Condición para los trapecios. //if (LVertices[j+1].y <= Zsi) //{ Vertex[X] = GVertices[j].x; Vertex[Y] = GVertices[j].y; CSPoligon.append(Vertex); //}  231 // Condición para el extremo derecho. if (LVertices[j+1].y >= Zsi) { // Coordenada X En el extremo derecho CxL = LVertices[j].x + ((LVertices[j+1].x - LVertices[j].x )/(LVertices[j+1].y - LVertices[j].y))*(Zsi - LVertices[j].y); // Interpolación simple. if(InundDerecho) { CxG = GVertices[GVertices.length() 1].x; } else { CxG = GVertices[j].x + ((GVertices[j+1].x - GVertices[j].x)/(LVertices[j+1].x - LVertices[j].x))*(CxL- LVertices[j].x); } Vertex[X] = p2[X] = CxG; Vertex[Y] = p2[Y] = p1[Y]; CSPoligon.append(Vertex); } if (LVertices[j+1].y < Zsi) {condicion = true; } else {condicion = false;} }//While //RecursosFGV.DibujarLinea(p1,p2,PLEDER_CAPA_NIVELES); //calcula el ancho o espejo de agua Tw = Tw + acutDistance(p1,p2); // Inserta el texto (caudal) p3[X] = (p1[X] + p2[X])/2; p3[Y] = p1[Y] + m_htexto/1.5; acdbRToS(Q, 2, 2, strQ); //Concatena el texto con 2 decimales. acdbRToS(h, 2, 2, strh); _stprintf(str, _T("h:%s%s, Q:%s%s" ), strh, _T("m"), strQ, _T("m3/s")); //RecursosFGV.DibujarTexto(p3, PLEDER_CAPA_NIVELES_TX, str, m_htexto, false, 1); } //if }//For j *TopWith = Tw; RecursosFGV.RestaurarVariables(); return RTNORM; } void CPLEDERFlujoPermanente::FreeAllFGVResultadosBufer(FGVResultadosBufer *theFirstResult)  232  /*-------------------------------------------------------------------- Ingreso : theFirstResult = puntero al primer elemento del buffer. Salida : Vacío. Propósito : Llamar a esta función para liberar un buffer FGVResultadosBufer --------------------------------------------------------------------*/ { if (!theFirstResult) return; FGVResultadosBufer *pResult = theFirstResult; FGVResultadosBufer *pResulNext = NULL; // liberar la ristra while (pResulNext = pResult->pRnext) { delete pResult; pResult = pResulNext; } delete pResult; theFirstResult = NULL; } PLEDERFlujoPermanenteDlg.cpp // PLEDERFlujoPermanenteDlg.cpp: archivo de implementación // #include "stdafx.h" #include "PLEDERFlujoPermanenteDlg.h" // Cuadro de diálogo de CPLEDERFlujoPermatenteDlg IMPLEMENT_DYNAMIC(CPLEDERFlujoPermanenteDlg, CDialog) CPLEDERFlujoPermanenteDlg::CPLEDERFlujoPermanenteDlg(CWnd* pParent /*=NULL*/) : CAdUiDialog(CPLEDERFlujoPermanenteDlg::IDD, pParent) { } m_TipoFlujo = 0; m_Ydowstream = _T("1.25"); m_Yupstream = _T("1.30"); m_Caudal = _T("100.00"); CPLEDERFlujoPermanenteDlg::~CPLEDERFlujoPermanenteDlg() { } void CPLEDERFlujoPermanenteDlg::DoDataExchange(CDataExchange* pDX) { CAdUiDialog::DoDataExchange(pDX); // Cajas de Texto. DDX_Control(pDX, IDC_EDIT_TDOW, m_Edit_Ydowstream); DDX_Control(pDX, IDC_EDIT_TUPS, m_Edit_Yupstream); DDX_Control(pDX, IDC_EDIT_CAUDAL, m_Edit_Caudal); 233  // Radio DDX_Radio(pDX, IDC_RADIO_FSUB, m_TipoFlujo); } BEGIN_MESSAGE_MAP(CPLEDERFlujoPermanenteDlg, CAdUiDialog) // Radios (cambios en los Radios) ON_BN_CLICKED(IDC_RADIO_FSUB, OnRadioFlujoSubcritico) ON_BN_CLICKED(IDC_RADIO_FSUP, OnRadioFlujoSupercritico) ON_BN_CLICKED(IDC_RADIO_FMIX, OnRadioFlujoMixto) ON_BN_CLICKED(IDOK, &CPLEDERFlujoPermanenteDlg::OnBnClickedOk) END_MESSAGE_MAP() // Controladores de mensajes de CPLEDERFlujoPermanenteDlg BOOL CPLEDERFlujoPermanenteDlg::OnInitDialog() { CDialog::OnInitDialog(); // Activar radio Fjujo Supcrítico CButton *pTipoFlujo; pTipoFlujo = (CButton *)GetDlgItem(IDC_RADIO_FSUB); pTipoFlujo->SetCheck(1); // Activa y desactiva para f. Sub por defecto m_Edit_Ydowstream.EnableWindow(1); m_Edit_Yupstream.EnableWindow(0); m_TipoFlujo = 0; // Inicializa Cajas de texto m_Edit_Ydowstream.SetWindowText(m_Ydowstream); m_Edit_Yupstream.SetWindowText(m_Yupstream); m_Edit_Caudal.SetWindowText(m_Caudal); return TRUE; } void CPLEDERFlujoPermanenteDlg::OnRadioFlujoSubcritico() { // Activa y desactiva las casillas de la ventana m_Edit_Ydowstream.EnableWindow(1); m_Edit_Yupstream.EnableWindow(0); m_TipoFlujo = 0; } void CPLEDERFlujoPermanenteDlg::OnRadioFlujoSupercritico() { // Activa las casillas de la ventana m_Edit_Ydowstream.EnableWindow(0); m_Edit_Yupstream.EnableWindow(1); m_TipoFlujo = 1; } void CPLEDERFlujoPermanenteDlg::OnRadioFlujoMixto() { // Activa las casillas de la ventana m_Edit_Ydowstream.EnableWindow(1); m_Edit_Yupstream.EnableWindow(1); m_TipoFlujo = 2; } 234  void CPLEDERFlujoPermanenteDlg::OnBnClickedOk() { // TODO : Add extra validation here m_Edit_Ydowstream.GetWindowText(m_Ydowstream); m_Edit_Yupstream.GetWindowText(m_Yupstream); m_Edit_Caudal.GetWindowText(m_Caudal); CDialog::OnOK(); } PLEDERHidraBuffer.cpp #include "StdAfx.h" #include "PLEDERHidraBuffer.h" /*Clase CrossSectionsBufer: Bufer para seciones transversales que se desaloja mediante la función FreeAllCrossSections()*/ CrossSectionsBufer::CrossSectionsBufer() { nbnext = NULL; m_IdST = 0; m_nVST = 0; } CrossSectionsBufer::CrossSectionsBufer(AcGePoint2d P1, double X1, double Y1, double IdST, long nVST, AcGePoint2dArray Vertice, double HminG, double HminL, double LL, double LC, double LR, double NL, double NC, double NR, long BL, long BR, double CC, double CE) { nbnext = NULL; m_P1[X] = P1[X]; m_P1[Y] = P1[Y]; m_X1 = X1; m_Y1 = Y1; m_HminG = HminG; m_HminL = HminL; m_IdST m_nVST m_LL = LL; m_LC = LC; m_LR = LR; m_NL = NL; m_NC = NC; m_NR = NR; m_BL = BL; m_BR = BR; m_CC = CC; m_CE = CE; = IdST; = nVST; // Vértices globales 235  for(int i=0; i < m_nV; i++) { m_ResultVertice[i].x = Vertice[i].x; m_ResultVertice[i].y = Vertice[i].y; m_ResultVertice[i].z = 0.0; //acutPrintf(_T("\nm_ResultVertice[%d], X = %0.3f , Y = %0.3f"), i, m_ResultVertice[i].x, m_ResultVertice[i].y ); } } // Destructor FGVResultadosBufer::~FGVResultadosBufer() { } //------------------------------------------------------------------- SeccionesBufer::SeccionesBufer() {  237 }  Siguiente = NULL; //Constructor que inicializa a CoorXX, CoordYY, ns y siguiente = NULL SeccionesBufer::SeccionesBufer(int nss, double CoordXX, double CoordYY, double Coefmanning) { Siguiente = NULL; ns = nss; CoordX = CoordXX; CoordY = CoordYY; manning = Coefmanning; } //Destructor SeccionesBufer::~SeccionesBufer() {} // Obtiene una copia del atributo Siguiente. SeccionesBufer* SeccionesBufer::ObtenerSiguiente() { return Siguiente; } //Pone el atributo Siguiente a p void SeccionesBufer::PonerSiguiente(SeccionesBufer *p) { Siguiente = p; } PerfilesBufer::PerfilesBufer() { SiguienteP = NULL; } PerfilesBufer::PerfilesBufer(int nST, ads_point v0, ads_point v1) { SiguienteP = NULL; start[X] = v0[X]; start[Y] = v0[Y]; start[Z] = v0[Z]; end[X] = v1[X]; end[Y] = v1[Y]; end[Z] = v1[Z]; } PerfilesBufer::~PerfilesBufer() { } PLEDERHidraSecTrasnv.cpp #include "StdAfx.h" #include "PLEDERHidraSecTrasnv.h" #include "PLEDERHidraBuffer.h" #include "PLEDERRecursosCad.h" 238 #include #include // Para exportar atributos #include #include //Constructor HidraSecTrasnv::HidraSecTrasnv(void) { // inicializar la clase pPrimerST = NULL; } //Destructor HidraSecTrasnv::~HidraSecTrasnv(void) { LiberarBufferSeccionesTransv(); } int HidraSecTrasnv::NumeroVerticesPolilinea(ads_name nombrep, long *nVST) /*--------------------------------------------------------------------------------------- Ingreso : nombrep = Nombre de la entidad polyline. Salida : Número de Vértices de una polilinea. RTCAN si la entidad no es una polyline o RTERROR en otro caso. Propósito : Retorna EL Número de Vértices de una polilinea ---------------------------------------------------------------------------------------*/ { unsigned int k, numVerts; AcDbObjectId ID; AcDbEntity *pEnt; *nVST = 0; // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, nombrep) != Acad::eOk) { acdbFail(_T("\nError al tomar el ObjectId de la entidad [acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pEnt, ID, AcDb::kForRead) != Acad::eOk) { acdbFail(_T("\nError al abrir el Objeto ")); return RTERROR; } // chequear el tipo de objeto if (pEnt->isKindOf(AcDbPolyline::desc()) != Adesk::kTrue) { pEnt->close(); acdbFail(_T("\nTipo de entidad inesperada ")); return RTCAN; } AcDbPolyline *pPolyline = (AcDbPolyline*)pEnt;  239 *nVST = pPolyline->numVerts(); // Toma el número de vértices de la polyline pPolyline->close(); return RTNORM; } int HidraSecTrasnv::LeerVerticesPolilineaConsola(ads_name nombrep, ads_point p1, double X1, double Y1, int contador) /*--------------------------------------------------------------------------------------- Ingreso : nombrep = Nombre de la entidad polyline. p1 = Punto de referencia para relacionar las coordenadas. X1 = Distancia X de la ST Y1 = Cota de la ST, contador = Para el conteo de número de secciones transversales (ST). para este caso no se da uso. Salida : RTNORM si no se produce ningún error. RTCAN si la entidad no es una polyline o RTERROR en otro caso. Propósito : Almacena las coordenadas de una polilinea (ST) en la consola con con transformaciones de coordenadas locales. ---------------------------------------------------------------------------------------*/ { ads_point v1, v2 ; v2[Z] = 0.0; AcGePoint2d pt ; unsigned int k, numVerts; long numof = 0; TCHAR str[256], str2[256]; double htexto = 0.2; double radio = 0.2; AcDbObjectId ID; AcDbEntity *pEnt; CRecursosCad Cad; // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, nombrep) != Acad::eOk) { acdbFail(_T("\nError al tomar el ObjectId de la entidad [acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pEnt, ID, AcDb::kForRead) != Acad::eOk) { acdbFail(_T("\nError al abrir el Objeto ")); return RTERROR; }  240 // chequear el tipo de objeto if (pEnt->isKindOf(AcDbPolyline::desc()) != Adesk::kTrue) { pEnt->close(); acdbFail(_T("\nTipo de entidad inesperada ")); return RTCAN; } AcDbPolyline *pPolyline = (AcDbPolyline*)pEnt; // chequear si la Polyline tiene elevación cero if (pPolyline->elevation() != 0) { pPolyline->close(); acutPrintf(_T("\nLa polyline no tiene elevación 0.")); return RTCAN; } numVerts = pPolyline->numVerts(); // Toma el número de vértices de la polyline if (numVerts <= 2) { pPolyline->close(); acdbFail(_T("\nPolyline no válida ")); return RTERROR; } //Accede a los vértices de la polilinea for (k = 0; k < numVerts; k++) { // Coge la coordenada en el punto pt pPolyline->getPointAt(k,pt) ; v1[X]= X1 + (pt[X] - p1[X]); // Suma la posición inicial X + la distancia X v1[Y]= Y1 - (p1[Y] - pt[Y]); // Resta la posición inicial Y - la distancia Y Cad.DibujarCirculos(pt[X], pt[Y], 0.00, PLEDER_CAPA_VERTICES, radio); v2[X]=pt[X]; v2[Y]=pt[Y]+ radio + htexto/2; //Configura el punto a ser insertado el texto acdbRToS(k+1, 2, 0, str); //Concatena el texto con 0 decimales Cad.DibujarTexto(v2, PLEDER_CAPA_VERTICES_TX, str, htexto, false, 1); acutPrintf (_T("\n%d %0.3f %0.3f"), k+1, v1[X], v1[Y] ); X1= v1[X]; Y1= v1[Y]; p1[X]= pt[X]; p1[Y]= pt[Y]; numof++;  241 } // for k pPolyline->close(); return RTNORM; } int HidraSecTrasnv::LeerVerticesPolilineaLista(ads_name nombrep, ads_point p1, double X1, double Y1, double* CX, double* CY) /*-------------------------------------------------------------------- Ingreso : nombrep = Nombre de la entidad polyline. p1 = Punto de referencia para relacionar las coordenadas. X1 = Distancia X de la ST Y1 = Cota de la ST, Salida : CX = Lista de las coordenadas X CY = Lista de las coordenadas Y RTNORM si no se produce ningún error. RTCAN si la entidad no es una polyline o RTERROR en otro caso. Propósito : Almacena las coordenadas de una polilinea (ST) en listas con transformaciones de coordenadas locales. -------------------------------------------------------------------*/ { ads_point v1, v2 ; v2[Z] = 0.0; AcGePoint2d pt ; unsigned int k, numVerts; long numof = 0; TCHAR str[256], str2[256]; double htexto = 0.2; double radio = 0.2; AcDbObjectId ID; AcDbEntity *pEnt; CRecursosCad Cad; // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, nombrep) != Acad::eOk) { acdbFail(_T("\nError al tomar el ObjectId de la entidad [acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pEnt, ID, AcDb::kForRead) != Acad::eOk) { acdbFail(_T("\nError al abrir el Objeto ")); return RTERROR; } // chequear el tipo de objeto if (pEnt->isKindOf(AcDbPolyline::desc()) != Adesk::kTrue) {  242  pEnt->close(); acdbFail(_T("\nTipo de entidad inesperada ")); return RTCAN; } AcDbPolyline *pPolyline = (AcDbPolyline*)pEnt; // chequear si la Polyline tiene elevación cero if (pPolyline->elevation() != 0) { pPolyline->close(); acutPrintf(_T("\nLa polyline no tiene elevación 0.")); return RTCAN; } numVerts = pPolyline->numVerts(); // Toma el número de vértices de la polyline if (numVerts <= 2) { pPolyline->close(); acdbFail(_T("\nPolyline no válida ")); return RTERROR; } //Accede a los vértices de la polilinea for (k = 0; k < numVerts; k++) { // Coge la coordenada en el punto pt pPolyline->getPointAt(k,pt) ; v1[X]= X1 + (pt[X] - p1[X]); // Suma la posición inicial X + la distancia X v1[Y]= Y1 - (p1[Y] - pt[Y]); // Resta la posición inicial Y - la distancia Y Cad.DibujarCirculos(pt[X], pt[Y], 0.00, PLEDER_CAPA_VERTICES, radio); v2[X]=pt[X]; v2[Y]=pt[Y]+ radio + htexto/2; //Configura el punto a ser insertado el texto acdbRToS(k+1, 2, 0, str); con 0 decimales //Concatena el texto Cad.DibujarTexto(v2, PLEDER_CAPA_VERTICES_TX, str, htexto, false, 1); ); } //acutPrintf (_T("\n%d %0.3f %0.3f"), k+1, v1[X], v1[Y] CX[k+1] = v1[X]; CY[k+1] = v1[Y]; X1= v1[X]; Y1= v1[Y]; p1[X]= pt[X]; p1[Y]= pt[Y]; numof++; // for k 243 pPolyline->close(); return RTNORM; } int HidraSecTrasnv::LeerVerticesPolilinea(ads_name nombrep, double* CX, double* CY) /*-------------------------------------------------------------------- Ingreso : nombrep = Nombre de la entidad polyline. p1 = Punto de referencia para relacionar las coordenadas. Salida : CX = Lista de las coordenadas X CY = Lista de las coordenadas Y RTNORM si no se produce ningún error. RTCAN si la entidad no es una polyline o RTERROR en otro caso. Propósito : Almacena las coordenadas de una polilinea (ST) en listas sin transformaciones de coordenadas. --------------------------------------------------------------------*/ { ads_point v1, v2 ; v2[Z] = 0.0; AcGePoint2d pt ; unsigned int k, numVerts; AcDbObjectId ID; AcDbEntity *pEnt; CRecursosCad Cad; // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, nombrep) != Acad::eOk) { acdbFail(_T("\nError al tomar el ObjectId de la entidad [acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pEnt, ID, AcDb::kForRead) != Acad::eOk) { acdbFail(_T("\nError al abrir el Objeto ")); return RTERROR; } // chequear el tipo de objeto if (pEnt->isKindOf(AcDbPolyline::desc()) != Adesk::kTrue) { pEnt->close(); acdbFail(_T("\nTipo de entidad inesperada ")); return RTCAN; } AcDbPolyline *pPolyline = (AcDbPolyline*)pEnt; // chequear si la Polyline tiene elevación cero if (pPolyline->elevation() != 0) { pPolyline->close();  244 acutPrintf(_T("\nLa polyline no tiene elevación 0.")); return RTCAN; } numVerts = pPolyline->numVerts(); // Toma el número de vértices de la polyline if (numVerts <= 2) { pPolyline->close(); acdbFail(_T("\nPolyline no válida ")); return RTERROR; } //Accede a los vértices de la polilinea for (k = 0; k < numVerts; k++) { // Coge la coordenada en el punto pt pPolyline->getPointAt(k,pt) ; CX[k+1] = pt[X]; CY[k+1] = pt[Y]; } // for k pPolyline->close(); return RTNORM; } int HidraSecTrasnv::ImportarSeccionesTransversales(const TCHAR *pNombreArchivo, long *NumeroVertST ) /*------------------------------------------------------------------ Ingreso : pNombreArchivo = Puntero a una zero terminated string con el nombre del archivo. NumeroVertST = Numero de vértices de las secciones transversales. Salida : RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Importar las Secciones Transversales desde un archivo. Guarda los datos en el Buffer SeccionesBufer, para luego llamar desde cualquier función. --------------------------------------------------------------------*/ { std::ifstream infile; char *buffer = NULL; char *token = NULL; char seps[] = PUNFILESEP; int n; long np = 0; double x=0, y=0, manning=0; if (!pNombreArchivo) { acdbFail(_T("\nArgumento de función no válido [ImportarSeccionesTransversales].")); return RTERROR; } acutPrintf(_T("\nLeyendo el fichero ascii ...\n"));  245  // abrir el fichero para lectura infile.open(pNombreArchivo); if (infile.fail() != 0) { *NumeroVertST = 0; acdbFail(_T("\nError de E/S al abrir el fichero [ImportarSeccionesTransversales][open].")); return RTERROR; } // crear un buffer para la lectura del fichero buffer = (char*)acad_malloc(GETLINEMAXBUFF * sizeof(char)); if (!buffer) { *NumeroVertST = 0; infile.close(); acdbFail(_T("\nError de asignación de memoria [Importar ST][buffer].")); return RTERROR; } // tomar primero el número de puntos que contiene el fichero // para poder valorar la longitud de la barra de progeso while (!infile.eof()) { infile.getline(buffer, GETLINEMAXBUFF, '\n'); if (infile.eof()) { // limpiar el flag eof infile.clear(); break; } np++; } // mover el puntero al principio del fichero infile.seekg(0, std::ios_base::beg); // colocar una barra de progreso acedSetStatusBarProgressMeter(_T("Insertando las secciones transversales: "), 0, (int)np); np = 0; // crear el buffer y añadir el primer Vértice como puntero try { } pPrimerST = new SeccionesBufer(); catch(const std::bad_alloc&) { acedRestoreStatusBar(); acdbFail(_T("\nError de asignación de memoria [Importar ST][pPrimerST].")); return RTERROR; } 246 SeccionesBufer *nST, *nbprevious = pPrimerST; // recorrer el fichero while (!infile.eof()) { // leer una línea del fichero infile.getline(buffer, GETLINEMAXBUFF, '\n'); if (infile.eof()) break; // separar los campos token = ::strtok(buffer, seps); if (!token) { *NumeroVertST = np; infile.close(); acad_free(buffer); acedRestoreStatusBar(); acdbFail(_T("\nFichero de Secciones Trasnv. No válido [Importar ST]")); return RTERROR; } n = atoi(token); // Coordenada x token = ::strtok(NULL, seps); if (!token) { *NumeroVertST = np; infile.close(); acad_free(buffer); acedRestoreStatusBar(); acdbFail(_T("\nFichero de Secciones Trasnv. No válido -n- [Importar ST]")); return RTERROR; } x = atof(token); // Coordenada y o Cota token = ::strtok(NULL, seps); if (!token) { *NumeroVertST = np; infile.close(); acad_free(buffer); acedRestoreStatusBar(); acdbFail(_T("\nFichero de Secciones Trasnv. No válido -x- [Importar ST]")); return RTERROR; } y = atof(token); // Coeficiente de Manning token = ::strtok(NULL, seps); if (!token)  247  { *NumeroVertST = np; infile.close(); acad_free(buffer); acedRestoreStatusBar(); acdbFail(_T("\nFichero de Secciones Trasnv. No válido -manning- [Importar ST]")); return RTERROR; } manning = atof(token); int contador = 1; // añadir los vértices de las secciones transv. al buffer try { nST = new SeccionesBufer(n, x, y, manning); } catch(const std::bad_alloc&) { LiberarBufferSeccionesTransv(); acedRestoreStatusBar(); acdbFail(_T("\nError de asignación de memoria [Importar ST][nST].")); return RTERROR; } nbprevious->Siguiente = nST; nbprevious = nST; // actualizar la barra de progreso acedSetStatusBarProgressMeterPos((int)np++); } // while infile.close(); acad_free(buffer); acedRestoreStatusBar(); *NumeroVertST = np; return RTNORM; } //Número de vértices totales int HidraSecTrasnv::ObtenerSeccionesTransversales() /*-------------------------------------------------------------------- Ingreso : Vacío. Salida Propósito : RTNORM si no se produce ningún error. RTERROR en otro caso. : Capta los datos del buffer SeccionesBufer, obtenidos al importar los datos de las secciones transversales. --------------------------------------------------------------------*/ { //Chequear los argumentos if (!pPrimerST) { acdbFail(_T("\nPuntero Nulo de la importación")); 248 }  return RTERROR; SeccionesBufer *pSeccTrasv; pPrimerST = pPrimerST->Siguiente; for (pSeccTrasv = pPrimerST; pSeccTrasv != NULL; pSeccTrasv = pSeccTrasv->Siguiente) { acutPrintf (_T("\n%d,%0.3f, %0.3f, %0.3f "), pSeccTrasv->ns , pSeccTrasv->CoordX, pSeccTrasv->CoordY, pSeccTrasv->manning); } return RTNORM; } void HidraSecTrasnv::LiberarBufferSeccionesTransv() /*------------------------------------------------------------------- Ingreso : Vacío. Salida Propósito : Vacío. : Libera el buffer en ristra SeccionesBufer al que apunta el miembro pPrimerST. Llamar a esta función para liberar el buffer con los vértives de las secciones transversales obtenidos mediante una llamada a la función ImportarSeccionesTransversales(). --------------------------------------------------------------------*/ { if (!pPrimerST) return; SeccionesBufer *nST = pPrimerST; SeccionesBufer *Siguiente = NULL; // liberar la ristra while (Siguiente = nST->Siguiente) { delete nST; nST = Siguiente; } delete nST; pPrimerST = NULL; } PLEDERRecursosSuperficieLibre.cpp #include "StdAfx.h" #include "PLEDERRecursosSuperficieLibre.h" CRecursosSuperficieLibre::CRecursosSuperficieLibre(void) { } CRecursosSuperficieLibre::~CRecursosSuperficieLibre(void) { } int CRecursosSuperficieLibre::NumeroVerticesCadaST(float *V, int n, int nST, float *nVert) 249 /*-------------------------------------------------------------------- Ingreso : V = Lista de Vértices de las S. T. Totales n = Número de vértices de las secciones transversales. nST = Número de Secciones Transversales. nVert = Lista de Números de los Vértices de las Secciones Transversales. Ingresa vacío, para luego ser almacenado (leer Propósito). Salida : RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Calcula los números de los Vértices para cada Secciones Transversales y los almacena en una lista (nVert) de dimensiones nST. -------------------------------------------------------------------*/ { int i, cont = 1, contador = 1; for( i = 2; i < n; i++) { if (V[i] ==1) { nVert[contador]= cont; contador++; cont = 0; } cont++; } //For i nVert[nST] = V[n]; // Lista que contiene los números de vértices. return RTNORM; } int CRecursosSuperficieLibre::VerticesMaximosMinimos(float *ListaC, int nST, float *nVert, float *Vminimo, float *Vmaximo) /*-------------------------------------------------------------------- Ingreso : ListaC= Lista de Coordenadas de las S. T. Totales nST = Número de Secciones Transversales. nVert = Lista de Números de los Vértices de las Secciones Transversales. Vmin = Lista de Los Vértices Mínimos de las S. T. Vmax = Lista de Los Vértices Máximos de las S. T. Salida : RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Busca los Vértices Mínimos y Máximos de una lista. Los almacena en las listas Vmin[] y Vmax[], de dimensión nST. --------------------------------------------------------------------*/ { int i, j, inicio = 1, // Principio para la interación. fin = nVert[1]; // Final de la iteración. float Mayor, Menor; for (i = 1; i <= nST; i++) { inicio = inicio; fin = fin; Mayor = ListaC[inicio]; Menor = ListaC[inicio]; for (j = (inicio +1); j <= fin; j++)  250 { if ( Menor > ListaC[j]) { Menor = ListaC[j]; } if(Mayor < ListaC[j]) { Mayor = ListaC[j]; } Vminimo[i] = Menor;// Lista que contiene los vértices mínimos. Vmaximo[i] = Mayor; // Lista que contiene los vértices máximos. }//For j inicio = inicio + nVert[i]; if (i < nST)// Prevee que en la última iteración tome un valor NULO { fin = fin + nVert[i+1]; } }//For i return RTNORM; } double CRecursosSuperficieLibre::PendienteMotrizSfm(float K1,float K2, float Q, float nn, int MetodoSfm) /*-------------------------------------------------------------------- Ingreso : K1 = Factor de Transporte en la primera sección de análisis. K2 = Factor de Transporte en la segunda sección de análisis. Q = Caudal del flujo. nn = Coeficiente de Manning. MetodoSfm = Método a usar Salida : Sfm = Pendiente Motriz. Propósito : Calcula la Pendiente Motriz entre dos secciones transversales por los para los cuatro métodos. --------------------------------------------------------------------*/ { double Sfm, I1, I2; I1 = pow(Q/K1,2); I2 = pow(Q/K2,2); switch (MetodoSfm) { case 1: // Ecuación de Factor de transporte Medio. { Sfm = pow(((Q+Q)/(K1+K2)),2); break; } case 2: // Media Aritmética. { Sfm = (I1+I2)/2;  251 break; } case 3: // Media Geométrica. { Sfm = sqrt(I1*I2); break; } case 4: // Media Armónica. { Sfm = 2*I1*I2/(I1+I2); break; } default: acutPrintf(_T("\nFuera de Rango")); } //switch (MetodoSfm) return Sfm; } float CRecursosSuperficieLibre::NumeroFroude(float Q, float A, float dA ) /*-------------------------------------------------------------------- Ingreso : Q = Caudal del flujo. A = Área Transversal de la sección. dA = Derivada del Área Transversal de la sección. Salida : NF = Número de Froude. Propósito : Calcula el Número de Froude --------------------------------------------------------------------*/ { float NF; NF = (Q*Q / g*A*A*A)*dA; return NF; } int CRecursosSuperficieLibre::AreaPerimetro(int inicio, int fin, float CotaTirante, float *CX, float *CY, double *Area, double *Perimetro) /*-------------------------------------------------------------------- Ingreso : inicio = Principio para la interación. fin = Final de la iteración. CotaTirante = Cota del tirante de la sección transversal. Dato importante para determinar el área y el perímetro de la S.T. CX = Datos de las Distancicias (eje X). CY = Datos de las cotas (eje Y). Salida : Area = Área Transversal para un tirante que se ingresó (CotaTirante). Perímetro = Perímetro Transversal para un tirante que se ingresó (CotaTirante). RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Calcula el Área y el Perímetro de una sección transversal a partir de una cota tirante. -------------------------------------------------------------------*/  252 { int j,k; float Xi, Xd; double Ai = 0, // Área en la sección Izquierda. At = 0, // Área en los trapecios. Ad = 0, // Área en la sección derecha. Pi = 0, // Perímetro en la sección Izquierda. Pt = 0, // Perímetro en los trapecios. Pd = 0; // Perímetro en la sección derecha. float YY[1000]; // Variable local para reasignar las coordenadas en Y float XX[1000]; // Variable local para reasignar las coordenadas en X int star = 1, end, cont; end = fin - inicio + 1; // Traslada los valores hacia la nueva lista YY , XX cont = inicio; for (k = star; k <= end; k++) { YY[k] = CY[cont]; XX[k] = CX[cont]; cont++; } bool InundIzquierdo = false; // Por defecto NO Existe Inundación bool InundDerecho = false; // Por defecto NO Existe Inundación // Son condiciones para agregar vértices si el tirante es mayor a los // vértices de las S. T. (casos de inundaciones) // Inundación Margen Izquierda? if (CotaTirante > CY[inicio]) { YY[1] = CotaTirante; XX[1] = CX[inicio]; cont = 2; for (k =inicio; k <= fin; k++) { YY[cont] = CY[k]; XX[cont] = CX[k]; cont++; } end++; InundIzquierdo = true; } // Inundación Margen Derecha? if (CotaTirante > CY[fin]) { YY[end+1] = CotaTirante; XX[end+1] = CX[fin]; //acutPrintf(_T("\nNuevos Valores de Y: %0.3f"), Y[k-1]); end++;  253 InundDerecho = true; } // Inicio del recorrido de los vértices. for (j = star; j <= (end - 1); j++) { // Condición para calcular en el triángulo izquierdo if ((CotaTirante <= YY[j]) && (CotaTirante >= YY[j+1])) { // Cálculo: Area del triángulo izquierdo Ai = Ai + pow((CotaTirante-YY[j+1]),2)*(XX[j+1] XX[j])/(2.0*(YY[j]-YY[j+1])); // Cálculo: Perímetro del triángulo izquierdo Pi = Pi + sqrt(pow((CotaTirante - YY[j+1]),2)+ pow((CotaTirante-YY[j+1])*(XX[j+1]-XX[j])/(YY[j]-YY[j+1]),2)); bool condicion = true; while (condicion) { j++; // Condición para calcular en los trapecios. if (YY[j+1] <= CotaTirante) { // Cálculo: Area del trapecio At= At + ((2.0*CotaTirante - YY[j]- YY[j+1])/2.0)*(XX[j+1]-XX[j]); // Cálculo: Perímetro del trapecio Pt = Pt + sqrt(pow((XX[j+1]- XX[j]),2) + pow((YY[j+1] - YY[j]),2)); } // Condición para calcular en el triángulo derecho. if (YY[j+1] >= CotaTirante) { // Cálculo: Area del triángulo derecho. Ad = Ad + pow((CotaTirante-YY[j]),2)*(XX[j+1] XX[j])/(2.0*(YY[j+1]-YY[j])); //acutPrintf(_T("\nValores de Area Derecha: %0.6f"), Ad); // Cálculo: Perímetro del triángulo derecho. Pd = Pd + sqrt(pow((CotaTirante - YY[j]),2)+ pow((CotaTirante-YY[j])*(XX[j+1]-XX[j])/(YY[j+1]-YY[j]),2)); } if (YY[j+1] < CotaTirante) { condicion = true; } else { condicion = false; }  254 }//While } //if }//For j *Area = Ai + At + Ad; // Area Total *Perimetro = Pi + Pt + Pd; // Perímetro Total return RTNORM; } int CRecursosSuperficieLibre::AreaPerimetroDerivadas(int inicio, int fin, float CotaTirante, float *CX, float *CY, double *Area, double *Perimetro, double *dArea, double *dPerimetro) /*-------------------------------------------------------------------- Ingreso : inicio = Principio para la interación. fin = Final de la iteración. CotaTirante = Cota del tirante de la sección transversal. Dato importante para determinar el área y el perímetro de la S.T. CX = Datos de las Distancicias (eje X). CY = Datos de las cotas (eje Y). Salida : Area = Área Transversal para un tirante que se ingresó (CotaTirante). dArea = Derivada del Área Transversal. Perímetro = Perímetro Transversal para un tirante que se ingresó (CotaTirante). dPerímetro = Derivada del Perímetro Transversal. RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Calcula el Área,el Perímetro, la derivada del área y la derivada del perímetro de una sección transversal a partir de una cota tirante. --------------------------------------------------------------------*/ { int j,k; float Xi, Xd; double Ai = 0, // Área en la sección Izquierda. At = 0, // Área en los trapecios. Ad = 0, // Área en la sección derecha. dAi = 0, // Derivada del Área en la sección Izquierda. dAt = 0, // Derivada del Área en los trapecios. dAd = 0, // Derivada del Área en la sección derecha. Pi = 0, // Perímetro en la sección Izquierda. Pt = 0, // Perímetro en los trapecios. Pd = 0, // Perímetro en la sección derecha. dPi = 0, // Derivada del Perímetro en la sección Izquierda.  255  dPt = 0, dPd = 0; float YY[1000]; float XX[1000]; // Derivada del Perímetro en los trapecios. // Derivada del Perímetro en la sección derecha. // Variable local para reasignar las coordenadas en Y // Variable local para reasignar las coordenadas en X int star = 1, end, cont; end = fin - inicio + 1; // Traslada los valores hacia la nueva lista YY , XX cont = inicio; for (k = star; k <= end; k++) { YY[k] = CY[cont]; XX[k] = CX[cont]; cont++; //acutPrintf(_T("\nNuevos Valores de Y: %0.3f"), Y[k-1]); } bool InundIzquierdo = false; // Por defecto NO Existe Inundación bool InundDerecho = false; // Por defecto NO Existe Inundación // Son condiciones para agregar vértices si el tirante es mayor a los // vértices de las S. T. (casos de inundaciones) // Inundación Margen Izquierda? if (CotaTirante > CY[inicio]) { YY[1] = CotaTirante; XX[1] = CX[inicio]; cont = 2; for (k =inicio; k <= fin; k++) { YY[cont] = CY[k]; XX[cont] = CX[k]; cont++; } end++; InundIzquierdo = true; } // Inundación Margen Derecha? if (CotaTirante > CY[fin]) { YY[end+1] = CotaTirante; XX[end+1] = CX[fin]; //acutPrintf(_T("\nNuevos Valores de Y: %0.3f"), Y[k-1]); end++; InundDerecho } = true; // Inicio del recorrido de los vértices. for (j = star; j <= (end - 1); j++) { // Condición para calcular en el triángulo izquierdo if ((CotaTirante <= YY[j]) && (CotaTirante >= YY[j+1])) 256 { // Interpolación para el triágulo izquierdo 'Xi' //Xi = XX[j+1] -(XX[j+1]-XX[j])*(CotaTirante YY[j+1])/(YY[j]-YY[j+1]); // Cálculo: Area del triángulo izquierdo Ai = Ai + pow((CotaTirante-YY[j+1]),2)*(XX[j+1] XX[j])/(2.0*(YY[j]-YY[j+1])); //acutPrintf(_T("\nValores de Area Izquierdo: %0.6f"), Ai); // Cálculo: Derivada del Area con respecto a Y del triángulo izquierdo dAi = dAi + 2.0*Ai/(CotaTirante - YY[j+1]); // Cálculo: Perímetro del triángulo izquierdo Pi = Pi + sqrt(pow((CotaTirante - YY[j+1]),2)+ pow((CotaTirante-YY[j+1])*(XX[j+1]-XX[j])/(YY[j]-YY[j+1]),2)); // Cálculo: Derivada del Perímetro con respecto a Y del triángulo izquierdo dPi = dPi + Pi/(CotaTirante - YY[j+1]); bool condicion = true; while (condicion) { j++; // Condición para calcular en los trapecios. if (YY[j+1] <= CotaTirante) { // Cálculo: Area del trapecio At= At + ((2.0*CotaTirante - YY[j]- YY[j+1])/2.0)*(XX[j+1]-XX[j]); //acutPrintf(_T("\nValores de Area Trapecio: %0.6f"), At); // Cálculo: Derivada del Area con respecto a Y de los trapecios dAt = dAt + XX[j+1] - XX[j]; // Cálculo: Perímetro del trapecio Pt = Pt + sqrt(pow((XX[j+1]- XX[j]),2) + pow((YY[j+1] - YY[j]),2)); } // Condición para calcular en el triángulo derecho. if (YY[j+1] >= CotaTirante) { // Interpolación para el triágulo derecho 'Xd' //Xd = XX[j] +(XX[j+1]- XX[j])*(CotaTirante - YY[j])/(YY[j+1]-YY[j]); // Interpolación de segmento derecho // |(Xi+1 - Xi)(Y - Yi) | // X = |---------------------| + Xi / | (Yi+1 - Yi) |  257 // Cálculo: Area del triángulo derecho. Ad = Ad + pow((CotaTirante-YY[j]),2)*(XX[j+1] XX[j])/(2.0*(YY[j+1]-YY[j])); //acutPrintf(_T("\nValores de Area Derecha: %0.6f"), Ad); // Cálculo: Derivada del Area con respecto a Y del triángulo derecho dAd = dAd + 2.0*Ad/(CotaTirante - YY[j]); // Cálculo: Perímetro del triángulo derecho. Pd = Pd + sqrt(pow((CotaTirante - YY[j]),2)+ pow((CotaTirante-YY[j])*(XX[j+1]-XX[j])/(YY[j+1]-YY[j]),2)); // Cálculo: Derivada del Perimetro con respecto a Y del triángulo derecho dPd = dPd + Pd/(CotaTirante - YY[j]); } if (YY[j+1] < CotaTirante) { condicion = true; } else { condicion = false; } }//While } //if }//For j *Area = Ai + At + Ad; // Area Total *dArea = dAi + dAt + dAd; // Derivada del Area Total *Perimetro = Pi + Pt + Pd; // Perímetro Total *dPerimetro = dPi + dPt + dPd; // Derivada del Perímetro Total return RTNORM; } PLEDERResutadosDlg.cpp #include "StdAfx.h" #include "resource.h" #include "PLEDERResutadosDlg.h" #include "PLEDERHidraBuffer.h" #include "PLEDERRecursosCad.h" #include "axlock.h" // Tabla CRecursosCad RecursosR; //-------------------------------------------------------------------- IMPLEMENT_DYNAMIC (CPLEDERResutadosDlg, CAdUiDialog) //-------------------------------------------------------------------- CPLEDERResutadosDlg::CPLEDERResutadosDlg (CWnd *pParent /*=NULL*/, HINSTANCE hInstance /*=NULL*/)  258  : CAdUiDialog (CPLEDERResutadosDlg::IDD, pParent, hInstance) { m_bFullRow = TRUE; m_bGridLines = TRUE; m_bCheckboxes = TRUE; m_Rx = _T("0.00"); m_Ry = _T("0.00"); } CPLEDERResutadosDlg::~CPLEDERResutadosDlg() { } //-------------------------------------------------------------------- void CPLEDERResutadosDlg::DoDataExchange (CDataExchange *pDX) { CAdUiDialog::DoDataExchange (pDX) ; // Cajas de Texto. DDX_Control(pDX, IDC_EDIT_Rx, m_Edit_Rx); DDX_Control(pDX, IDC_EDIT_Ry, m_Edit_Ry); // List DDX_Control(pDX, IDC_LIST_RESULTADOS, m_wndListR); // Botones (Sólo CAD) DDX_Control(pDX, IDC_BUTTON_RPunto, m_PickButton_RPunto); } LRESULT CPLEDERResutadosDlg::OnAcadKeepFocus (WPARAM, LPARAM) { return (TRUE); } BEGIN_MESSAGE_MAP(CPLEDERResutadosDlg, CAdUiDialog) ON_MESSAGE(WM_ACAD_KEEPFOCUS, OnAcadKeepFocus) // Botones incluidos cad ON_BN_CLICKED(IDC_BUTTON_RPunto, OnButtonRPunto) ON_BN_CLICKED(IDOK, &CPLEDERResutadosDlg::OnBnClickedOk) END_MESSAGE_MAP() BOOL CPLEDERResutadosDlg::OnInitDialog() { CDialog::OnInitDialog(); m_Edit_Rx.SetWindowText(m_Rx); m_Edit_Ry.SetWindowText(m_Ry); m_PickButton_RPunto.AutoLoad(); // Insertando las grillas m_wndListR.SetHeadings(_T("ID, 50; Caudal(m3/s), 90; Tirante(m), 80; Cota Tirante(m), 100; Area Total(m2), 90; ALF(m2), 80; AMC(m2), 80; ARF(m2), 80; Perímetro(m), 100; Velocidad(m/s), 100; Nº Froude , 100; Espejo(m), 90; K , 80; Beta , 80; Hf (m/m), 80; hc,80 ")); for (int i = 0; i < 500; i++) 259 { m_wndListR.InsertItem(0, _T(""), _T(""),_T(""),_T(""), _T(""), _T(""),_T(""),_T(""), _T(""), _T(""),_T(""),_T(""), _T(""), _T(""),_T(""),_T(""), _T(""), _T(""),_T(""),_T("")); } m_wndListR.SetGridLines(TRUE); //m_wndListR.SetCheckboxes(TRUE); // Borra todo los datos de la grilla. m_wndListR.DeleteAllItems(ItemdataProc, (LPARAM)this); double Kt, At, Pt, Vm, Fr; TCHAR strId[10], strQ[10], strh[10], strZs[10], strA[10], strALF[10], strAMC[10], strARF[10], strP[10], strPLF[10], strPMC[10], strPRF[10], strV[10], strF[10], strT[10], strK[10], strKLF[10], strKMC[10], strKRF[10], strBeta[10], strhf12[10], strhc12[10]; // Inserta los resultado en la grilla for (int i=0; i< m_Result_len; i++) { At = (m_pRHidraulicos + i)->ALF +(m_pRHidraulicos + i)->AMC + (m_pRHidraulicos + i)->ARF; Pt = (m_pRHidraulicos + i)->PLF +(m_pRHidraulicos + i)->PMC + (m_pRHidraulicos + i)->PRF; Kt = (m_pRHidraulicos + i)->KLF +(m_pRHidraulicos + i)->KMC + (m_pRHidraulicos + i)->KRF; // Cálculo de la velocidad media Vm = ((m_pRHidraulicos + i)->Q) / At; // Cálculo del Número de Froude Fr = Vm/ pow(g*(m_pRHidraulicos + i)->h , 0.5); acdbRToS((m_pRHidraulicos + i)->IdST , 2, 3, strId); acdbRToS((m_pRHidraulicos + i)->Q , 2, 3, strQ); acdbRToS((m_pRHidraulicos + i)->h , 2, 3, strh); acdbRToS((m_pRHidraulicos + i)->Zs , 2, 3, strZs); acdbRToS(At , 2, 3, strA); acdbRToS((m_pRHidraulicos + i)->ALF , 2, 3, strALF); acdbRToS((m_pRHidraulicos + i)->AMC , 2, 3, strAMC); acdbRToS((m_pRHidraulicos + i)->ARF , 2, 3, strARF); acdbRToS(Pt , 2, 3, strP); acdbRToS(Vm , 2, 3, strV); acdbRToS(Fr , 2, 3, strF); acdbRToS((m_pRHidraulicos + i)->TopW , 2, 3, strT); acdbRToS(Kt , 2, 3, strK); //acdbRToS((m_pRHidraulicos + i)->KLF , 2, 3, strKLF); //acdbRToS((m_pRHidraulicos + i)->KMC , 2, 3, strKMC);  260 //acdbRToS((m_pRHidraulicos + i)->KRF , 2, 3, strKRF); acdbRToS((m_pRHidraulicos + i)->Beta , 2, 3, strBeta); acdbRToS((m_pRHidraulicos + i)->hf12 , 2, 5, strhf12); acdbRToS((m_pRHidraulicos + i)->hc12 , 2, 3, strhc12); m_wndListR.InsertItem( m_Result_len, strId, strQ, strh, strZs, strA, strALF, strAMC, strARF, strP, strV, strF, strT, strK, strBeta, strhf12, strhc12); } return TRUE; } void CPLEDERResutadosDlg::OnButtonRPunto() { //Clase que habilita CAD //AcAxDocLock docLock; CAcModuleResourceOverride resourceOverride; // Esconde el diálogo BeginEditorCommand(); ads_point p1; // Coge el Punto P1 if (acedGetPoint (NULL, _T("\nPique un Punto para la tabla [Resultados PLEDER]"), p1) != RTNORM ) { acutPrintf(_T("\nError al ingresar el Punto")); // si no cancela el comando(incluyendo el diálogo) // CancelEditorCommand(); CompleteEditorCommand(); return; } CompleteEditorCommand(); m_Rx.Format(_T("%g"), p1[X] ); m_Edit_Rx.SetWindowText(m_Rx); m_Ry.Format(_T("%g"), p1[Y] ); m_Edit_Ry.SetWindowText(m_Ry); } BOOL CPLEDERResutadosDlg::ItemdataProc(DWORD dwData, LPARAM lParam) { // TODO: Process your item data here // Please return TRUE to proceed the deletion, return FALSE to abort. return TRUE; } void CPLEDERResutadosDlg::OnBnClickedOk() { // Coge los valores despues de pulsar OK  261 // Cajas de texto m_Edit_Rx.GetWindowText(m_Rx); m_Edit_Ry.GetWindowText(m_Ry); CDialog::OnOK(); RecursosR.T_pRHidraulicos = m_pRHidraulicos; //...............RESULTADOS TABLA.......................................... float PX, PY; PX =_wtof(m_Rx); PY =_wtof(m_Ry); ads_point p1; p1[X] = PX; p1[Y] = PY; p1[Z] = 0.0; //Clase que habilita CAD AcAxDocLock docLock; CString strTableStyle = _T("Standard"); strTableStyle.ReleaseBuffer(); CString strNameBlock = _T("RESULTADOS HIDRAULICOS"); strNameBlock.ReleaseBuffer(); // Para almacenar los datos de la tabla RowData *pRwData = new RowData(); if (Acad::eOk == RecursosR.GenerarTablaHidraulicodesdeBlock((TCHAR *)strNameBlock.GetBuffer(), pRwData, m_Result_len)) { // Crear la tabla AcDbTable *pTbl = NULL; // Notar que la primera, segunda columna contiene datos para los títulos y cabecera // Aquí usa la tercera fila para la correcta longitud de la columna. if(Acad::eOk == RecursosR.CrearTabla(pTbl,(TCHAR *)strTableStyle.GetBuffer(),pRwData->at(2)->length(),pRwData >length())) { // Habilitar la tabla con datos RecursosR.HabilitarTabla(pTbl, pRwData); // Agrega el Object Table hacia el Model Space del actual dibujo. if(Acad::eOk == RecursosR.AgregarEnDwg(acdbHostApplicationServices() >workingDatabase(),pTbl)) { // Unir las Celdas //mergeCellsForTitleAndHeader(pTbl,pBlkName); // Ajustar las columnas. RecursosR.AjustarAnchoColumna(pTbl,200); // 200 - valor arbitrario limite superior.  262 // Ajustar las filas. RecursosR.AjustarAlturaFila(pTbl,50); // 50 - valor arbitrario limite superior. pTbl->setPosition(AcGePoint3d(p1[X], p1[Y], p1[Z])); // Cierra la tabla pTbl->close(); } //if else { // Limpiar, si pTbl no es agregado al model space delete pTbl; } } //if else { acutPrintf(_T("\nNo se pudo crear la tabla")); } } //if acedRestoreStatusBar(); } //-------------------------------------------------------------------- // Funciones extras para los resultados void CPLEDERResutadosDlg::FreeAllResultBufs() /*-------------------------------------------------------------------- Ingreso : theFirstResult = puntero al primer elemento del buffer. Salida : Vacío. Propósito : Llamar a esta función para liberar un buffer FGVResultadosBufer --------------------------------------------------------------------*/ { if (!m_theFirstR) return; FGVResultadosBufer *pResult = m_theFirstR; FGVResultadosBufer *pResulNext = NULL; // liberar la ristra while (pResulNext = pResult->pRnext) { delete pResult; pResult = pResulNext; } delete pResult; m_theFirstR = NULL; }  263  int CPLEDERResutadosDlg::AcquireLevelFreeSurface(long *numberL) /*-------------------------------------------------------------------- Ingreso : numberof = Puntero a Long para sobreescribir el Resultado Salida Propósito : numberof = Representa el número de Secciones Transversales que se encontraron. RTNORM si no se produce ningún error. RTERROR en otro caso. : Lee el conjunto de Secciones transversales definidas en el drawing. Llamar a esta función para obtener el puntero al buffer CrossSectionsBuf con la nube de S.T. El buffer quedará apuntado por el miembro m_theFirstST. Para desalojar el buffer se deberá llamar a la función FreeAllCrossSectionsBufs(). Las S.T. que se añadan al buffer no estarán ordenados por su número de orden. Se toman las S.T. en bruto. -------------------------------------------------------------------*/ { FreeAllResultBufs(); struct resbuf *filter; // resbufs // preparar el filtro para los niveles calculados filter = acutBuildList( RTDXF0, _T("PLEDERHydraulicResult"), 8, 0); if (filter == NULL) { PLEDER_CAPA_NIVELES, acdbFail(_T("\nError al construir el filtro [AcquireLevelFreeSurface][acutBuildList].")); return RTERROR; } ads_name long ss; // ss sslen = 0; // longitud del ss // seleccionar las secciones transversales definidas if (acedSSGet(_T("_X"), NULL, NULL, filter, ss) != RTNORM) { //acutPrintf(_T("\nNo hay Niveles calculados en el drawing")); } *numberL = 0; acutRelRb(filter); return RTNORM; acutRelRb(filter); // tomar la longitud del ss if (acedSSLength(ss, &sslen) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar la longitud del conjunto de selección [AcquireLevelFreeSurface][acedSSLength].")); return RTERROR; } CPLEDERHydraulicResult *pResult; ads_name ename; AcDbObjectId ID; 264  long AcGePoint2d P1; nL = 0; // colocar una barra de progreso acedSetStatusBarProgressMeter(_T("Adquiriendo los niveles calculados: "), 0, (int)sslen); // tomar el nombre de la primera entidad if (acedSSName(ss, 0, ename) != RTNORM) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el nombre de la entidad CPLEDERHydraulicResult [AcquireLevelFreeSurface][acedSSName].")); return RTERROR; } // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, ename) != Acad::eOk) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el ObjectId de la entidad CPLEDERCrossSections [AcquireCrossSections][acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pResult, ID, AcDb::kForRead) != Acad::eOk) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError al abrir el Objeto CPLEDERCrossSections [AcquireCrossSections][acdbOpenObject].")); return RTERROR; } Adesk::Int32 double double nV; IdST; // Id h , // Tirante. Zs, // Cota Tirante. Beta, // Coeciente de corrección. ALF, // Area llanura Izquierda. AMC, ARF, PLF, izquierdo. izquierdo. central. derecho PMC, PRF, KLF, KMC, KRF, Q // Area Canal central. // Area llanura derecha. // Perímetro llanura // Perímetro canal central. // Perímetro llanura derecho // Conductividad llanura // Conductividad canal // Conductividad llanura , // Descarga del flujo. hf12, // Pérdida por fircción. hc12, // Pérdida local. TopW, // Espejo de agua LMC; // Longitud del canal central 265  // tomar las propiedades pResult->IdCrossSections(IdST); pResult->NumberVertex(nV); pResult->Depth(h); pResult->WaterElevation(Zs); pResult->BetaCoeficient(Beta); pResult->LeftArea(ALF); pResult->MainArea(AMC); pResult->RightArea(ARF); pResult->LeftPerimeter(PLF); pResult->MainPerimeter(PMC); pResult->RightPerimeter(PRF); pResult->LeftConveyance(KLF); pResult->MainConveyance(KMC); pResult->RightConveyance(KRF); pResult->WaterFlow(Q); pResult->FrictionLess(hf12); pResult->LocalLess(hc12); pResult->TopWidth(TopW); pResult->LengthMainChannel(LMC); AcGePoint2dArray vertexArray; AcGePoint2d vertex; //for(int i =0; i< pResult->m_nV; i++) for(int i =0; i< nV; i++) { vertex[X] = pResult->m_GVerts[i].x; vertex[Y] = pResult->m_GVerts[i].y; vertexArray.append(vertex); } pResult->close(); // crear el buffer y añade la primera sección transversal try { m_theFirstR = new FGVResultadosBufer(nV, vertexArray, IdST, h, Zs, Beta, ALF, AMC, ARF, PLF, PMC, PRF, KMC, KRF, Q, hf12, hc12, TopW, LMC); } catch(const std::bad_alloc&) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError de asignación de memoria [AcquireCrossSections][m_theFirstNode].")); return RTERROR; } FGVResultadosBufer *nR, *nRprevious = m_theFirstR; // actualizar la barra de progreso acedSetStatusBarProgressMeterPos((int)nL++); KLF, 266  vertexArray.removeAll(); // recorrer el ss for (int i = 1; i < sslen; i++) { // tomar el nombre de la entidad if (acedSSName(ss, i, ename) != RTNORM) { acedSSFree(ss); FreeAllResultBufs(); acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el nombre de la entidad PLEDERCrossSections [AcquireCrossSections][acedSSName].")); return RTERROR; } // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, ename) != Acad::eOk) { acedSSFree(ss); FreeAllResultBufs(); acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el ObjectId de la entidad PLEDERCrossSections [AcquireCrossSections][acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pResult, ID, AcDb::kForRead) != Acad::eOk) { acedSSFree(ss); FreeAllResultBufs(); acedRestoreStatusBar(); acdbFail(_T("\nError al abrir el Objeto PLEDERCrossSections [AcquireCrossSections][acdbOpenObject].")); return RTERROR; } // tomar las propiedades pResult->IdCrossSections(IdST); pResult->NumberVertex(nV); pResult->Depth(h); pResult->WaterElevation(Zs); pResult->BetaCoeficient(Beta); pResult->LeftArea(ALF); pResult->MainArea(AMC); pResult->RightArea(ARF); pResult->LeftPerimeter(PLF); pResult->MainPerimeter(PMC); pResult->RightPerimeter(PRF); pResult->LeftConveyance(KLF); pResult->MainConveyance(KMC); pResult->RightConveyance(KRF); pResult->WaterFlow(Q); pResult->FrictionLess(hf12); pResult->LocalLess(hc12); pResult->TopWidth(TopW); pResult->LengthMainChannel(LMC); 267  for(int i =0; i< nV; i++) { vertex[X] = pResult->m_GVerts[i].x; vertex[Y] = pResult->m_GVerts[i].y; vertexArray.append(vertex); } pResult->close(); // añadir las secciones transversales al buffer try { nR Zs, Beta, = new FGVResultadosBufer(nV, vertexArray, IdST, h, ALF, AMC, ARF, PLF, PMC, PRF, KLF, KMC, KRF, Q, hf12, hc12, TopW, LMC); } catch(const std::bad_alloc&) { acedSSFree(ss); FreeAllResultBufs(); acedRestoreStatusBar(); acdbFail(_T("\nError de asignación de memoria [AcquireCrossSections][nb].")); return RTERROR; } nRprevious->pRnext = nR; nRprevious = nR; // actualizar la barra de progreso acedSetStatusBarProgressMeterPos((int)nL++); vertexArray.removeAll(); } // for i acedSSFree(ss); acedRestoreStatusBar(); *numberL = nL; return RTNORM; } // Adquirir o tomar los niveles calculados int CPLEDERResutadosDlg::DeleteLevelFreeSurface(bool prompt) /*-------------------------------------------------------------------- Ingreso : prompt Salida = si es verdadero solicita confimación. : RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Elimina los niveles calculados --------------------------------------------------------------------*/ { TCHAR result[131]; // si procede preguntar al usuario si desea eliminar los niveles if (prompt) { 268 acedInitGet(RSG_NONULL, _T("S N")); if (acedGetKword(_T("\n¿Seguro que desea eliminar los niveles S/N? : "), result) == RTCAN) return RTCAN; if ((result[0] == 'n') || (result[0] == 'N')) return RTCAN; } struct resbuf *filter; // resbufs // preparar el filtro para seleccionar los niveles filter = acutBuildList( RTDXF0, _T("PLEDERHydraulicResult"), 8, PLEDER_CAPA_NIVELES, 0); if (!filter) { acdbFail(_T("\nError al construir el filtro [DeleteLevelFreeSurface][acutBuildList].")); return RTERROR; } ads_name ss; // ss long sslen = 0; // longitud del ss // seleccionar los niveles definidos if (acedSSGet(_T("_X"), NULL, NULL, filter, ss) != RTNORM) { // no hay niveles en el drawing acutRelRb(filter); return RTNORM; } acutRelRb(filter); // tomar la longitud del ss if (acedSSLength(ss, &sslen) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar la longitud del conjunto de selección [acedSSLength].")); return RTERROR; } CPLEDERHydraulicResult *pResult; ads_name ename; AcDbObjectId ID; long n, np, progress = 0; np = 100; // colocar una barra de progreso acedSetStatusBarProgressMeter(_T("Eliminando los niveles: "), 0, (int)np); // recorrer el ss  269  for (int i = 0; i < sslen; i++) { // tomar el nombre de la entidad if (acedSSName(ss, i, ename) != RTNORM) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el nombre de la entidas [acedSSName].")); } return RTERROR; // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, ename) != Acad::eOk) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el ObjectId de la entidad [acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pResult, ID, AcDb::kForRead) != Acad::eOk) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError al abrir el Objeto [acdbOpenObject].")); return RTERROR; } pResult->close(); // borrar la entidad acdbEntDel(ename); // actualizar la barra de progreso acedSetStatusBarProgressMeterPos((int)progress++); } // for i acedSetStatusBarProgressMeterPos((int)np); acedSSFree(ss); acedRestoreStatusBar(); return RTNORM; } PLEDERSeccionesTransversales.cpp #include "StdAfx.h" #include "PLEDERSeccionesTransversales.h" #include "PLEDERRecursosCad.h" #include "PLEDERHidraBuffer.h" CPLEDERSeccionesTransversales::CPLEDERSeccionesTransversales(void) 270  { } // inicializar la clase m_theFirstST = NULL; m_theFirstSOC = NULL; m_STTextHeight = 0.20; m_STDiameter = 0.20; CPLEDERSeccionesTransversales::~CPLEDERSeccionesTransversales(void) { FreeAllCrossSectionsBufs(); FreeAllCrossSectionsSocavacionBufs(); } void CPLEDERSeccionesTransversales::FreeAllCrossSectionsBufs() /*-------------------------------------------------------------------- Ingreso : Vacío. Salida Propósito : Vacío. : Libera el buffer en ristra CrossSectionsBuf al que apunta el miembro m_theFirstST. Llamar a esta función para liberar el buffer con las S.T. obtenidas mediante una llamada a la función AcquireCrossSections(). -------------------------------------------------------------------*/ { if (!m_theFirstST) return; CrossSectionsBufer *nb = m_theFirstST; CrossSectionsBufer *nbnext = NULL; // liberar la ristra while (nbnext = nb->nbnext) { delete nb; nb = nbnext; } delete nb; m_theFirstST = NULL; } void CPLEDERSeccionesTransversales::FreeAllCrossSectionsSocavacionBufs() /*-------------------------------------------------------------------- Ingreso : Vacío. Salida Propósito : Vacío. : Libera el buffer en ristra CrossSectionsSocavacionBuf al que apunta el miembro m_theFirstSOC. Llamar a esta función para liberar el buffer con las S.T. obtenidas mediante una llamada a la función AcquireCrossSectionsSocavacion(). --------------------------------------------------------------------*/ { if (!m_theFirstSOC) return; CrossSectionsSocavacionBufer *nb = m_theFirstSOC; CrossSectionsSocavacionBufer *nbnext = NULL; 271  // liberar la ristra while (nbnext = nb->nbnext) { delete nb; nb = nbnext; } delete nb; m_theFirstSOC = NULL; } int CPLEDERSeccionesTransversales::AcquireCrossSections(long *numberof) /*-------------------------------------------------------------------- Ingreso : numberof = Puntero a Long para sobreescribir el resultado Salida : numberof = Representa el número de Secciones Transversales que se encontraron. RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Lee el conjunto de Secciones transversales definidas en el drawing. Llamar a esta función para obtener el puntero al buffer CrossSectionsBuf con la nube de S.T. El buffer quedará apuntado por el miembro m_theFirstST. Para desalojar el buffer se deberá llamar a la función FreeAllCrossSectionsBufs(). Las S.T. que se añadan al buffer no estarán ordenados por su número de orden. Se toman las S.T. en bruto. -------------------------------------------------------------------*/ { FreeAllCrossSectionsBufs(); struct resbuf *filter; // resbufs // preparar el filtro para seleccionar las S.T. filter = acutBuildList( RTDXF0, _T("CPLEDERCrossSections"), 8, 0); if (filter == NULL) { PLEDER_CAPA_SECCIONTRANSVERSAL, acdbFail(_T("\nError al construir el filtro [AcquireCrossSections][acutBuildList].")); return RTERROR; } ads_name long ss; // ss sslen = 0; // longitud del ss // seleccionar las secciones transversales definidas if (acedSSGet(_T("_X"), NULL, NULL, filter, ss) != RTNORM) { // no hay Secciones Transv. en el drawing *numberof = 0; acutRelRb(filter); return RTNORM; } 272  acutRelRb(filter); // tomar la longitud del ss if (acedSSLength(ss, &sslen) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar la longitud del conjunto de selección [AcquireCrossSections][acedSSLength].")); return RTERROR; } CPLEDERCrossSections ads_name AcDbObjectId long double AcGePoint2d P1; double *pSecciones; ename; ID; nVST, np = 0; IdST; X1, Y1, LL, LC, LR, NL, NC, NR, CC, CE, HminG, HminL; long BL, BR; // colocar una barra de progreso acedSetStatusBarProgressMeter(_T("Adquiriendo las secciones transverales: "), 0, (int)sslen); // tomar el nombre de la primera entidad if (acedSSName(ss, 0, ename) != RTNORM) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el nombre de la entidad CPLEDERCrossSections [AcquireCrossSections][acedSSName].")); return RTERROR; } // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, ename) != Acad::eOk) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el ObjectId de la entidad CPLEDERCrossSections [AcquireCrossSections][acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pSecciones, ID, AcDb::kForRead) != Acad::eOk) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError al abrir el Objeto CPLEDERCrossSections [AcquireCrossSections][acdbOpenObject].")); return RTERROR; } // tomar las propiedades pSecciones->ReferencePoint(P1); pSecciones->ReferenceX(X1); pSecciones->ReferenceY(Y1); 273  pSecciones->MinVerticeGlobal(HminG); pSecciones->MinVerticeLocal(HminL); pSecciones->IdCrossSections(IdST); pSecciones->nVST(nVST); pSecciones->LengthLeft(LL); pSecciones->LengthCenter(LC); pSecciones->LengthRight(LR); pSecciones->ManningLeft(NL); pSecciones->ManningCenter(NC); pSecciones->ManningRight(NR); pSecciones->BankLeft(BL); pSecciones->BankRight(BR); pSecciones->CoeficentCont(CC); pSecciones->CoeficentExp(CE); AcGePoint2dArray vertexArray; AcGePoint2d vertex; for(int i =0; ipVerts[i].x; vertex[Y] = pSecciones->pVerts[i].y; vertexArray.append(vertex); } pSecciones->close(); // crear el buffer y añade la primera sección transversal try { m_theFirstST = new CrossSectionsBufer(P1, X1, Y1, IdST, nVST, vertexArray, HminG, HminL, LL, LC, LR, NL, NC, NR, BL, BR, CC, CE); } catch(const std::bad_alloc&) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError de asignación de memoria [AcquireCrossSections][m_theFirstNode].")); return RTERROR; } CrossSectionsBufer *nb, *nbprevious = m_theFirstST; // actualizar la barra de progreso acedSetStatusBarProgressMeterPos((int)np++); vertexArray.removeAll(); // recorrer el ss for (int i = 1; i < sslen; i++) 274  { // tomar el nombre de la entidad if (acedSSName(ss, i, ename) != RTNORM) { acedSSFree(ss); FreeAllCrossSectionsBufs(); acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el nombre de la entidad PLEDERCrossSections [AcquireCrossSections][acedSSName].")); return RTERROR; } // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, ename) != Acad::eOk) { acedSSFree(ss); FreeAllCrossSectionsBufs(); acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el ObjectId de la entidad PLEDERCrossSections [AcquireCrossSections][acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pSecciones, ID, AcDb::kForRead) != Acad::eOk) { acedSSFree(ss); FreeAllCrossSectionsBufs(); acedRestoreStatusBar(); acdbFail(_T("\nError al abrir el Objeto PLEDERCrossSections [AcquireCrossSections][acdbOpenObject].")); return RTERROR; } // tomar las propiedades pSecciones->ReferencePoint(P1); pSecciones->ReferenceX(X1); pSecciones->ReferenceY(Y1); pSecciones->MinVerticeGlobal(HminG); pSecciones->MinVerticeLocal(HminL); pSecciones->IdCrossSections(IdST); pSecciones->nVST(nVST); pSecciones->LengthLeft(LL); pSecciones->LengthCenter(LC); pSecciones->LengthRight(LR); pSecciones->ManningLeft(NL); pSecciones->ManningCenter(NC); pSecciones->ManningRight(NR); pSecciones->BankLeft(BL); pSecciones->BankRight(BR); pSecciones->CoeficentCont(CC); pSecciones->CoeficentExp(CE); 275  for(int j =0; jpVerts[j].x; vertex[Y] = pSecciones->pVerts[j].y; vertexArray.append(vertex); } pSecciones->close(); // añadir las secciones transversales al buffer try { nb = new CrossSectionsBufer(P1, X1, Y1, IdST, nVST, vertexArray, HminG, HminL, LL, LC, NC, NR, BL, BR, CC, CE); } catch(const std::bad_alloc&) { acedSSFree(ss); FreeAllCrossSectionsBufs(); acedRestoreStatusBar(); acdbFail(_T("\nError de asignación de memoria [AcquireCrossSections][nb].")); return RTERROR; } nbprevious->nbnext = nb; nbprevious = nb; // actualizar la barra de progreso acedSetStatusBarProgressMeterPos((int)np++); vertexArray.removeAll(); } // for i acedSSFree(ss); acedRestoreStatusBar(); *numberof = np; return RTNORM; } LR, NL, int CPLEDERSeccionesTransversales::AcquireCrossSectionsSocavacion(long *numberof) /*-------------------------------------------------------------------- Ingreso : numberof = Puntero a Long para sobreescribir el resultado Salida : numberof = Representa el número de Secciones Transversales que se encontraron. RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito el drawing. : Lee el conjunto de Secciones transversales definidas en Llamar a esta función para obtener el puntero al buffer CrossSectionsBuf con la nube de S.T. El buffer quedará apuntado por el miembro m_theFirstST. Para desalojar el buffer se deberá llamar a la función FreeAllCrossSectionsBufs(). Las S.T. que se añadan al buffer no estarán ordenados por su número de orden. Se toman las S.T. en bruto. -------------------------------------------------------------------*/ { 276 FreeAllCrossSectionsSocavacionBufs(); struct resbuf *filter; // resbufs // preparar el filtro para seleccionar las S.T. filter = acutBuildList( RTDXF0, _T("CPLEDERCrossSections"), 8, PLEDER_CAPA_SECCIONTRANSVERSAL, 0); if (filter == NULL) { acdbFail(_T("\nError al construir el filtro [AcquireCrossSections][acutBuildList].")); return RTERROR; } ads_name ss; // ss long sslen = 0; // longitud del ss // seleccionar las secciones transversales definidas if (acedSSGet(_T("_X"), NULL, NULL, filter, ss) != RTNORM) { // no hay Secciones Transv. en el drawing *numberof = 0; acutRelRb(filter); return RTNORM; } acutRelRb(filter); // tomar la longitud del ss if (acedSSLength(ss, &sslen) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar la longitud del conjunto de selección [AcquireCrossSections][acedSSLength].")); return RTERROR; } CPLEDERCrossSections *pSecciones; ads_name ename; AcDbObjectId ID; long nVST, np = 0; double IdST; Adesk::Int32 Material, CoefProb; double CoefMaterial; // colocar una barra de progreso acedSetStatusBarProgressMeter(_T("Adquiriendo las secciones transverales: "), 0, (int)sslen); // tomar el nombre de la primera entidad if (acedSSName(ss, 0, ename) != RTNORM) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el nombre de la entidad CPLEDERCrossSections [AcquireCrossSections][acedSSName]."));  277 }  return RTERROR; // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, ename) != Acad::eOk) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el ObjectId de la entidad CPLEDERCrossSections [AcquireCrossSections][acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pSecciones, ID, AcDb::kForRead) != Acad::eOk) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError al abrir el Objeto CPLEDERCrossSections [AcquireCrossSections][acdbOpenObject].")); return RTERROR; } // tomar las propiedades pSecciones->IdCrossSections(IdST); pSecciones->TipoMaterial(Material); pSecciones->CoeficienteProb(CoefProb); pSecciones->CoeficienteMaterial(CoefMaterial); pSecciones->close(); // crear el buffer y añade la primera sección transversal try { m_theFirstSOC = new CrossSectionsSocavacionBufer(IdST, Material, CoefProb , CoefMaterial); } catch(const std::bad_alloc&) { acedSSFree(ss); acedRestoreStatusBar(); acdbFail(_T("\nError de asignación de memoria [AcquireCrossSections][m_theFirstNode].")); return RTERROR; } CrossSectionsSocavacionBufer *nb, *nbprevious = m_theFirstSOC; // actualizar la barra de progreso acedSetStatusBarProgressMeterPos((int)np++); // recorrer el ss for (int i = 1; i < sslen; i++) { // tomar el nombre de la entidad if (acedSSName(ss, i, ename) != RTNORM) { acedSSFree(ss); FreeAllCrossSectionsSocavacionBufs(); 278  acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el nombre de la entidad PLEDERCrossSections [AcquireCrossSections][acedSSName].")); return RTERROR; } // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, ename) != Acad::eOk) { acedSSFree(ss); FreeAllCrossSectionsSocavacionBufs(); acedRestoreStatusBar(); acdbFail(_T("\nError al tomar el ObjectId de la entidad PLEDERCrossSections [AcquireCrossSections][acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pSecciones, ID, AcDb::kForRead) != Acad::eOk) { acedSSFree(ss); FreeAllCrossSectionsSocavacionBufs(); acedRestoreStatusBar(); acdbFail(_T("\nError al abrir el Objeto PLEDERCrossSections [AcquireCrossSections][acdbOpenObject].")); return RTERROR; } // tomar las propiedades pSecciones->IdCrossSections(IdST); pSecciones->TipoMaterial(Material); pSecciones->CoeficienteProb(CoefProb); pSecciones->CoeficienteMaterial(CoefMaterial); pSecciones->close(); // añadir las secciones transversales al buffer try { nb = new CrossSectionsSocavacionBufer(IdST, Material, CoefProb, CoefMaterial); } catch(const std::bad_alloc&) { acedSSFree(ss); FreeAllCrossSectionsSocavacionBufs(); acedRestoreStatusBar(); acdbFail(_T("\nError de asignación de memoria [AcquireCrossSections][nb].")); return RTERROR; } nbprevious->nbnext = nb; nbprevious = nb; // actualizar la barra de progreso acedSetStatusBarProgressMeterPos((int)np++); } // for i 279  acedSSFree(ss); acedRestoreStatusBar(); *numberof = np; return RTNORM; } int CPLEDERSeccionesTransversales::GetFirstNumberCrossSections(long *nfirst) /*-------------------------------------------------------------------- Ingreso : nfirst resultado Salida : nfirst = Puntero a Long para sobreescribir el = número de orden de la primera S.T. Si no hay Secciones Transv. definidos tomará el valor de cero. RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Busca el número de orden el último nombre de la S.T. en el Drawing. Nos podríamos basar en el buffer, pero para asegurar la búsqueda nos basaremos en el drawing, ya que el buffer puede no estar actualizado -------------------------------------------------------------------*/ { struct resbuf *filter; // resbufs // preparar el filtro para seleccionar las S.T. filter = acutBuildList( RTDXF0, _T("CPLEDERCrossSections"), 8, 0); if (filter == NULL) { PLEDER_CAPA_SECCIONTRANSVERSAL, acdbFail(_T("\nError al construir el filtro [GetFirstNumberCrossSections][acutBuildList].")); return RTERROR; } ads_name long ss; // ss sslen = 0; // longitud del ss // seleccionar las secciones transversales definidas if (acedSSGet(_T("X"), NULL, NULL, filter, ss)!= RTNORM) { acdbFail(_T("\nNo hay Secciones Transversales definifos en el drawinG")); *nfirst = 0; acutRelRb(filter); return RTNORM; } acutRelRb(filter); // tomar la longitud del ss if (acedSSLength(ss, &sslen) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar la longitud del conjunto de selección [GetFirstNumberCrossSections][acedSSLength].")); return RTERROR; 280 } CPLEDERCrossSections *pSecciones; ads_name ename; AcDbObjectId ID; long np = 0; double n; // tomar la última sección transversal if (GetLastNumberCrossSections(&np) != RTNORM) { acedSSFree(ss); return RTERROR; } // recorrer el ss for (int i = 0; i < sslen; i++) { // tomar el nombre de la entidad if (acedSSName(ss, i, ename) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar el nombre de la entidad CPLEDERCrossSections [GetFirstNumberCrossSections][acedSSName].")); return RTERROR; } // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, ename) != Acad::eOk) { acedSSFree(ss); acdbFail(_T("\nError al tomar el ObjectId de la entidad CPLEDERCrossSections [GetFirstNumberCrossSections][acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pSecciones, ID, AcDb::kForRead) != Acad::eOk) { acedSSFree(ss); acdbFail(_T("\nError al abrir el Objeto CPLEDERCrossSections [GetFirstNumberCrossSections][acdbOpenObject].")); return RTERROR; } // tomar el número de orden pSecciones->IdCrossSections(n); pSecciones->close(); // chequearlo if (n > np) np = n; } // for i acedSSFree(ss); *nfirst = np;  281 return RTNORM; } int CPLEDERSeccionesTransversales::GetLastNumberCrossSections(long *nlast) /*-------------------------------------------------------------------- Ingreso : nlast= Puntero a Long para sobreescribir el resultado Salida : nlast= número de orden del último S.T. Si no hay Secciones Transv. definidos tomará el valor de cero. RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Busca el número de orden el último nombre de la S.T. en el Drawing. -------------------------------------------------------------------*/ { struct resbuf *filter; // resbufs // preparar el filtro para seleccionar las S.T. filter = acutBuildList( RTDXF0, _T("CPLEDERCrossSections"), 8, PLEDER_CAPA_SECCIONTRANSVERSAL, 0); if (filter == NULL) { acdbFail(_T("\nError al construir el filtro [GetLastNumberCrossSections][acutBuildList].")); return RTERROR; } ads_name ss; // ss long sslen = 0; // longitud del ss // seleccionar los puntos definidos if (acedSSGet(_T("_X"), NULL, NULL, filter, ss) != RTNORM) { // no hay Secciones Transversales definifos en el drawing *nlast = 0; acutRelRb(filter); return RTNORM; } acutRelRb(filter); // tomar la longitud del ss if (acedSSLength(ss, &sslen) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar la longitud del conjunto de selección [GetLastNumberCrossSections][acedSSLength].")); return RTERROR; } CPLEDERCrossSections *pSecciones; ads_name ename; AcDbObjectId ID; long np = 0; double n;  282  // recorrer el ss for (int i = 0; i < sslen; i++) { // tomar el nombre de la entidad if (acedSSName(ss, i, ename) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar el nombre de la entidad CPLEDERCrossSections [GetLastNumberCrossSections][acedSSName].")); return RTERROR; } // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, ename) != Acad::eOk) { acedSSFree(ss); acdbFail(_T("\nError al tomar el ObjectId de la entidad CPLEDERCrossSections [GetLastNumberCrossSections][acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pSecciones, ID, AcDb::kForRead) != Acad::eOk) { acedSSFree(ss); acdbFail(_T("\nError al abrir el Objeto CPLEDERCrossSections [GetLastNumberCrossSections][acdbOpenObject].")); return RTERROR; } // tomar el número de orden pSecciones->IdCrossSections(n); pSecciones->close(); // chequearlo if (n > np) np = n; } // for i acedSSFree(ss); *nlast = np; return RTNORM; } int CPLEDERSeccionesTransversales::GetNumberofCrossSections(long *numberof) /*-------------------------------------------------------------------- Ingreso : numberof = Puntero a Long para sobreescribir el resultado Salida : numberof = (Out) el número de secciones transversales que se encontraron. RTNORM si no se produce ningún error. RTERROR en otro caso. 283  Propósito : Contabiliza el número de Secciones Transversales en el Drawing. Nos podríamos basar en el buffer, pero para asegurar la búsqueda nos basaremos en el Drawing,ya que el buffer puede no estar actualizado. -------------------------------------------------------------------*/ { struct resbuf *filter; // resbufs // preparar el filtro para seleccionar las secciones transversales. filter = acutBuildList( RTDXF0, 8, 0); if (filter == NULL) { _T("CPLEDERCrossSections"), PLEDER_CAPA_SECCIONTRANSVERSAL, acdbFail(_T("\nError al construir el filtro [GetNumberofCrossSections][acutBuildList].")); return RTERROR; } ads_name ss; long // ss sslen = 0; // longitud del ss // seleccionar las secciones transversales definidos if (acedSSGet(_T("_X"), NULL, NULL, filter, ss) != RTNORM) { // no hay secciones transversales definifos en el drawing *numberof = 0; acutRelRb(filter); return RTNORM; } acutRelRb(filter); // tomar la longitud del ss if (acedSSLength(ss, &sslen) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar la longitud del conjunto de selección [GetNumberofCrossSections][acedSSLength].")); return RTERROR; } acedSSFree(ss); *numberof = sslen; return RTNORM; } int CPLEDERSeccionesTransversales::GetCrossSectionsAttributes() /*-------------------------------------------------------------------- Ingreso : vacío Salida Propósito : RTNORM si no se produce ningún error. RTERROR en otro caso. : Obtiene el valor del diámetro de los círculos y la altura del texto de las entidades Secciones transversales. Los valores son alojados en las variables miembro m_STDiameter y m_STTextHeight. -------------------------------------------------------------------*/ 284 {  struct resbuf *filter; // resbufs // preparar el filtro para seleccionar las secciones transversales. filter = acutBuildList( RTDXF0, 8, 0); if (filter == NULL) { _T("CPLEDERCrossSections"), PLEDER_CAPA_SECCIONTRANSVERSAL, acdbFail(_T("\nError al construir el filtro [GetCrossSectionsAttributes][acutBuildList].")); return RTERROR; } ads_name long ss; // ss sslen = 0; // longitud del ss // seleccionar las secciones transversales definidos if (acedSSGet(_T("_X"), NULL, NULL, filter, ss) != RTNORM) { // no hay secciones transversales definifos en el drawing m_STTextHeight = 0.2; m_STDiameter = 0.2; acutRelRb(filter); return RTNORM; } acutRelRb(filter); // tomar la longitud del ss if (acedSSLength(ss, &sslen) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar la longitud del conjunto de selección [GetCrossSectionsAttributes][acedSSLength].")); return RTERROR; } CPLEDERCrossSections ads_name AcDbObjectId *pSecciones; ename; ID; // tomar el valor de los atributos de la primera S.T. // tomar el nombre de la entidad if (acedSSName(ss, 0, ename) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar el nombre de la entidad CPLEDERCrossSections [GetCrossSectionsAttributes][acedSSName].")); return RTERROR; } acedSSFree(ss); // cambiar el nombre por el ObjectId 285  if (acdbGetObjectId(ID, ename) != Acad::eOk) { acdbFail(_T("\nError al tomar el ObjectId de la entidad CPLEDERCrossSections [GetCrossSectionsAttributes][acdbGetObjectId].")); return RTERROR; } // abrir el objeto para lectura if (acdbOpenObject(pSecciones, ID, AcDb::kForRead) != Acad::eOk) { acdbFail(_T("\nError al abrir el Objeto CPLEDERCrossSections [GetCrossSectionsAttributes][acdbOpenObject].")); return RTERROR; } // tomar el Diámetro if (pSecciones->diameter(m_STDiameter) != Acad::eOk) { pSecciones->close(); acdbFail(_T("\nError al tomar los atributos del nodo [GetCrossSectionsAttributes].")); return RTERROR; } // tomar la altura del texto if (pSecciones->textHeight(m_STTextHeight) != Acad::eOk) { pSecciones->close(); acdbFail(_T("\nError al tomar los atributos del nodo [GetCrossSectionsAttributes].")); return RTERROR; } pSecciones->close(); return RTNORM; } int CPLEDERSeccionesTransversales::ZoomCrossSections(double IdnST) /*-------------------------------------------------------------------- Ingreso : IdnST: Salida Nombre o Id de la sección trasnversal : RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito solicitada. : Realiza un encuadre o zoom de la sección transversal -------------------------------------------------------------------*/ { long numof; // Adquirir las secciones transverales if (AcquireCrossSections(&numof) != RTNORM) { acutPrintf(_T("\nERROR PLEDER: [AcquireCrossSections]")); return RTERROR; } if (!m_theFirstST) { acutPrintf(_T("\nERROR PLEDER: No hay secciones transversales definidos.")); 286 return RTERROR; } CrossSectionsBufer *nb; bool encontrado; encontrado = false; // Buscar la sección transversal for (nb = m_theFirstST; nb != NULL; nb = nb->nbnext) { if (nb->m_IdST == IdnST) { encontrado = true; break; } } if (!encontrado) { acutPrintf(_T("\nPLEDER ERROR: Sección transveral no encontrado.")); FreeAllCrossSectionsBufs(); return RTERROR; } // Encuadrar la seción transversal en una ventana +- 2 metros ads_point p1, p2; p1[X] = (nb->m_GlobalVertice[0].x - 5); p1[Y] = (nb->m_GlobalVertice[0].y + 2); p2[X] = (nb->m_GlobalVertice[nb->m_nVST-1].x + 5); p2[Y] = nb->m_HminG -2; // Punto mínimo. struct resbuf *rb; // Invocar el comando zoom window rb = acutBuildList ( RTSTR, _T("_zoom"), RTSTR, _T("_w"), RTPOINT, p1, RTPOINT, p2, 0); if (rb != NULL) { acedCmd(rb); acutRelRb(rb); } FreeAllCrossSectionsBufs(); return RTNORM; } int CPLEDERSeccionesTransversales::GetIdCrossSectionsAttributes(double IdST, long *nVST, AcGePoint2dArray& LvertexArray, AcGePoint2dArray& GvertexArray, double *LL, double *LC, double *LR,  287  double *NL,double *NC, double *NR, long *BL, long *BR, double *CC, double *CE) /*-------------------------------------------------------------------- Ingreso : IdnST: Salida Nombre o Id de la sección transversal : RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito su ID : Recepciona los atributos de la sección transversal desde --------------------------------------------------------------------*/ { long numof; // Adquirir las secciones transverales if (AcquireCrossSections(&numof) != RTNORM) { acutPrintf(_T("\nERROR PLEDER:[AcquireCrossSections]")); return RTERROR; } if (!m_theFirstST) { acutPrintf(_T("\nERROR PLEDER: No hay secciones transversales definidos.")); return RTERROR; } CrossSectionsBufer *nb; bool encontrado; encontrado = false; // Buscar la sección transversal for (nb = m_theFirstST; nb != NULL; nb = nb->nbnext) { if (nb->m_IdST == IdST) { encontrado = true; break; } } if (!encontrado) { acutPrintf(_T("\nPLEDER ERROR: Sección Transversal no encontrado.")); FreeAllCrossSectionsBufs(); return RTERROR; } // Guarda los atributos de la sección transversal de la posición encontrada (nb) *nVST = nb->m_nVST; *LL = nb->m_LL; *LC = nb->m_LC; *LR = nb->m_LR; *NL = nb->m_NL; *NC = nb->m_NC; 288  *NR = nb->m_NR; *BL = nb->m_BL; *BR = nb->m_BR; *CC = nb->m_CC; *CE = nb->m_CE; AcGePoint2d vertex; // Guardar los vértices for(int i =0; i < *nVST; i++) { // Vértices globales vertex[X] = nb->m_GlobalVertice[i].x; vertex[Y] = nb->m_GlobalVertice[i].y; GvertexArray.append(vertex); // Vértices locales vertex[X] = nb->m_LocalVertice[i].x; vertex[Y] = nb->m_LocalVertice[i].y; LvertexArray.append(vertex); } FreeAllCrossSectionsBufs(); return RTNORM; } int CPLEDERSeccionesTransversales::GetIdCrossSectionsAttributesSocavacion( double IdST, int *Material, int *CoefProb, : IdnST: double *CoefMaterial) /*-------------------------------------------------------------------- Ingreso Nombre o Id de la sección transversal Salida Propósito su ID : RTNORM si no se produce ningún error. RTERROR en otro caso. : Recepciona los atributos de la sección transversal desde -------------------------------------------------------------------*/ { long numof; // Adquirir las secciones transverales if (AcquireCrossSectionsSocavacion(&numof) != RTNORM) { acutPrintf(_T("\nERROR PLEDER:[AcquireCrossSectionsSocavacion]")); return RTERROR; } if (!m_theFirstSOC) { acutPrintf(_T("\nERROR PLEDER: No hay secciones transversales definidos.")); return RTERROR; } CrossSectionsSocavacionBufer *nb; bool encontrado = false; 289 // Buscar la sección transversal for (nb = m_theFirstSOC; nb != NULL; nb = nb->nbnext) { if (nb->m_IdST == IdST) { encontrado = true; break; } } if (!encontrado) { acutPrintf(_T("\nPLEDER ERROR: Sección Transversal no encontrado.")); FreeAllCrossSectionsSocavacionBufs(); return RTERROR; } // Guarda los atributos de la sección transversal de la posición encontrada (nb) *Material = nb->m_Material; *CoefProb = nb->m_CoefProb; *CoefMaterial = nb->m_CoefMaterial; FreeAllCrossSectionsSocavacionBufs(); return RTNORM; } int CPLEDERSeccionesTransversales::GetMinVertice(double *VerticeY, long nVert, double *Hmin) /*-------------------------------------------------------------------- Ingreso : VerticeY = Lista de Coordenadas de las S. T. Totales nVert = Lista de Números de los Vértices de las Secciones Transversales. Hmin = Lista de Los Vértices Mínimos de las S. T. Salida : RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Busca los Vértices Mínimos y Máximos de una lista. -------------------------------------------------------------------*/ { int j; float Mayor, Menor; Mayor = VerticeY[1]; Menor = VerticeY[1]; for (j = 1; j <= nVert; j++) { if ( Menor > VerticeY[j]) { Menor = VerticeY[j]; } if(Mayor < VerticeY[j]) { Mayor = VerticeY[j]; } *Hmin = Menor; // vértice mínimo. //Hmax = Mayor; //  290 }//For j return RTNORM; } int CPLEDERSeccionesTransversales::GetAreaPerimeter(double CotaTirante, AcGePoint3dArray LvertexArray, long BL, long BR, double *ALF , double *AMC, double *ARF, double *PLF, double *PMC, double *PRF, double *A, double *P) /*-------------------------------------------------------------------- Ingreso : CotaTirante = Cota del tirante de la sección transversal. Dato importante para determinar el área y el perímetro de la S.T. LvertexArray = Vértices de la sección transversal (X, Y, Manning) Salida : Area = Área Transversal para un tirante que se ingresó (CotaTirante). Perímetro = Perímetro Transversal para un tirante que se ingresó (CotaTirante). K = Factor de transportabilidad. Beta = Factor de correción. RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Calcula el Área y el Perímetro de una sección transversal a partir de una cota tirante. --------------------------------------------------------------------*/ { int j,k; double Ai = 0.0, At = 0.0, Ad = 0.0, // Áreas : Izquierda, trapecios, y derecha. Pi = 0.0, Pt = 0.0, Pd = 0.0; // Perímetros : Izquierda, trapecios y derecha. *ALF= 0.0, *AMC= 0.0, *ARF= 0.0, // Areas: Left, Central y Right. *PLF= 0.0, *PMC= 0.0, *PRF= 0.0; // Perimentro: Left, Central y Right. AcGePoint3dArray Vertices; // Variable local para reasignar los vértices. AcGePoint3d Vertex; // Traslada los valores hacia la nueva lista YY , XX for (k = 0; k < LvertexArray.length(); k++) { Vertex[X] = LvertexArray[k].x; Vertex[Y] = LvertexArray[k].y; Vertex[Z] = LvertexArray[k].z; Vertices.append(Vertex); } bool InundIzquierdo = false; // Por defecto NO Existe Inundación bool InundDerecho = false; // Por defecto NO Existe Inundación  291 // Inundación Margen Izquierda? if (CotaTirante > LvertexArray[0].y) { Vertices.removeAll(); Vertex[X] = LvertexArray[0].x; Vertex[Y] = CotaTirante; Vertex[Z] = LvertexArray[0].z; Vertices.append(Vertex); for (k =0; k < LvertexArray.length(); k++) { Vertex[X] = LvertexArray[k].x; Vertex[Y] = LvertexArray[k].y; Vertex[Z] = LvertexArray[k].z; Vertices.append(Vertex); } InundIzquierdo = true; } // Inundación Margen Derecha? if (CotaTirante > LvertexArray[LvertexArray.length()-1].y) { Vertex[X] = LvertexArray[LvertexArray.length()-1].x; Vertex[Y] = CotaTirante; Vertex[Z] = LvertexArray[LvertexArray.length()-1].z; Vertices.append(Vertex); InundDerecho = true; } // Inicio del recorrido de los vértices. for (j = 0; j < Vertices.length()-1; j++) { // Condición para calcular en el triángulo izquierdo if ((CotaTirante <= Vertices[j].y) && (CotaTirante >= Vertices[j+1].y)) { // Cálculo: Area del triángulo izquierdo Ai = Ai + pow((CotaTirante Vertices[j+1].y),2)*(Vertices[j+1].x Vertices[j].x)/(2.0*(Vertices[j].y-Vertices[j+1].y)); // Cálculo: Perímetro del triángulo izquierdo Pi = Pi + sqrt(pow((CotaTirante - Vertices[j+1].y),2)+ pow((CotaTirante Vertices[j+1].y)*(Vertices[j+1].x-Vertices[j].x)/(Vertices[j].y Vertices[j+1].y),2)); // Condiciones para las áreas y perímetros en los bancos y central if (j+1 < BL) { *ALF = *ALF + Ai + At + Ad; *PLF = *PLF + Pi + Pt + Pd; Ai = 0.0; At = 0.0; Ad = 0.0; Pi = 0.0; Pt = 0.0; Pd = 0.0; } if (j+1 >= BL && j+1 < BR) {  292 *AMC = *AMC + Ai + At + Ad; *PMC = *PMC + Pi + Pt + Pd; Ai = 0.0; At = 0.0; Ad = 0.0; Pi = 0.0; Pt = 0.0; Pd = 0.0; } if (j+1 >= BR ) { *ARF = *ARF + Ai + At + Ad; *PRF = *PRF + Pi + Pt + Pd; Ai = 0.0; At = 0.0; Ad = 0.0; Pi = 0.0; Pt = 0.0; Pd = 0.0; } bool condicion = true; while (condicion) { j++; // Condición para calcular en los trapecios. if (Vertices[j+1].y <= CotaTirante) { // Cálculo: Area del trapecio At= At + ((2.0*CotaTirante - Vertices[j].y- Vertices[j+1].y)/2.0)*(Vertices[j+1].x-Vertices[j].x); // Cálculo: Perímetro del trapecio Pt = Pt + sqrt(pow((Vertices[j+1].x- Vertices[j].x),2) + pow((Vertices[j+1].y - Vertices[j].y),2)); // Condiciones para las áreas y perímetros en los bancos y central if (j+1 < BL) { *ALF = *ALF + Ai + At + Ad; *PLF = *PLF + Pi + Pt + Pd; Ai = 0.0; At = 0.0; Ad = 0.0; Pi = 0.0; Pt = 0.0; Pd = 0.0; } if (j+1 >= BL && j+1 < BR) { *AMC = *AMC + Ai + At + Ad; *PMC = *PMC + Pi + Pt + Pd; Ai = 0.0; At = 0.0; Ad = 0.0; Pi = 0.0; Pt = 0.0; Pd = 0.0; } if (j+1 >= BR ) { *ARF = *ARF + Ai + At + Ad; *PRF = *PRF + Pi + Pt + Pd; Ai = 0.0; At = 0.0; Ad = 0.0; Pi = 0.0; Pt = 0.0; Pd = 0.0; } } // Condición para calcular en el triángulo derecho. if (Vertices[j+1].y >= CotaTirante) { // Cálculo: Area del triángulo derecho. Ad = Ad + pow((CotaTirante Vertices[j].y),2)*(Vertices[j+1].x Vertices[j].x)/(2.0*(Vertices[j+1].y-Vertices[j].y));  293 //acutPrintf(_T("\nValores de Area Derecha: %0.6f"), Ad); // Cálculo: Perímetro del triángulo derecho. Pd = Pd + sqrt(pow((CotaTirante - Vertices[j].y),2)+ pow((CotaTirante-Vertices[j].y)*(Vertices[j+1].x Vertices[j].x)/(Vertices[j+1].y-Vertices[j].y),2)); // Condiciones para las áreas y perímetros en los bancos y central if (j+1 < BL) { *ALF = *ALF + Ai + At + Ad; *PLF = *PLF + Pi + Pt + Pd; Ai = 0.0; At = 0.0; Ad = 0.0; Pi = 0.0; Pt = 0.0; Pd = 0.0; } if (j+1 >= BL && j+1 < BR) { *AMC = *AMC + Ai + At + Ad; *PMC = *PMC + Pi + Pt + Pd; Ai = 0.0; At = 0.0; Ad = 0.0; Pi = 0.0; Pt = 0.0; Pd = 0.0; } if (j+1 >= BR ) { *ARF = *ARF + Ai + At + Ad; *PRF = *PRF + Pi + Pt + Pd; Ai = 0.0; At = 0.0; Ad = 0.0; Pi = 0.0; Pt = 0.0; Pd = 0.0; } } if (Vertices[j+1].y < CotaTirante) { condicion = true; } else { condicion = false; } }//While } //if }//For j // Area y perímetro total (A,P) *A = *ALF + *AMC + *ARF; *P = *PLF + *PMC + *PRF; return RTNORM; } int CPLEDERSeccionesTransversales::GetAreaPoligon(AcGePoint2dArray VPoligon, double *Area) /*-------------------------------------------------------------------- Ingreso : VPoligon = Vértices de un poligono Salida : Area = Área Transversal de un polígono RTNORM si no se produce ningún error. RTERROR en otro caso. Propósito : Calcula el Área de un polígono --------------------------------------------------------------------*/  294  { *Area = 0.0; long N = VPoligon.length(); for(int i = 0; i < N -1; i++) { *Area = *Area + VPoligon[i].x * VPoligon[i+1].y - VPoligon[i].y * VPoligon[i+1].x; } *Area = 0.5* (*Area + VPoligon[N-1].x * VPoligon[0].y - VPoligon[N-1].y * VPoligon[0].x); acutPrintf(_T("\n El area es= %0.3f "), *Area); return RTNORM; } PLEDERSeccionesTransversalesDlg.cpp // PLEDERSeccionesTransversalesDlg.cpp: archivo de implementación // #include "stdafx.h" #include "PLEDERSeccionesTransversales.h" #include "PLEDERSeccionesTransversalesDlg.h" #include "PLEDERHidraBuffer.h" #include "PLEDERRecursosCad.h" #include "PLEDERHidraSecTrasnv.h" //Objetos PLEDER CRecursosCad RecursosST; CPLEDERSeccionesTransversales CS; HidraSecTrasnv GeometriaST; // Cuadro de diálogo de CPLEDERSeccionesTransversalesDlg IMPLEMENT_DYNAMIC(CPLEDERSeccionesTransversalesDlg, CAdUiDialog) CPLEDERSeccionesTransversalesDlg::CPLEDERSeccionesTransversalesDlg(CWn d* pParent /*=NULL*/) : CAdUiDialog(CPLEDERSeccionesTransversalesDlg::IDD, pParent) { m_bFullRow = TRUE; m_bGridLines = TRUE; m_bCheckboxes = TRUE; m_LI = _T("20.00"); m_LC = _T("20.00"); m_LD = _T("20.00"); m_BI = _T("1"); m_BD = _T(""); m_NI = _T("0.025"); m_NC = _T("0.017"); m_ND = _T("0.025"); 295 m_CC = _T("0.1"); m_CE = _T("0.3"); m_Material = 1; // Tipo de material, Cohesivo = 0, No Cohesivo = 1. m_CoefProb = 6; // Coeficiente de probabilidad de gasto. (Ubicación) m_CoefMaterial = 0.0; // Peso específico ó diámetro medio del material de fondo. } CPLEDERSeccionesTransversalesDlg::~CPLEDERSeccionesTransversalesDlg() { } void CPLEDERSeccionesTransversalesDlg::DoDataExchange(CDataExchange* pDX) { CAdUiDialog::DoDataExchange(pDX); // List DDX_Control(pDX, IDC_LIST1, m_wndList); // Cajas de Texto. DDX_Control(pDX, IDC_EDIT_LI, m_Edit_LI); DDX_Control(pDX, IDC_EDIT_LC, m_Edit_LC); DDX_Control(pDX, IDC_EDIT_LD, m_Edit_LD); DDX_Control(pDX, IDC_EDIT_BI, m_Edit_BI); DDX_Control(pDX, IDC_EDIT_BD, m_Edit_BD); DDX_Control(pDX, IDC_EDIT_NI, m_Edit_NI); DDX_Control(pDX, IDC_EDIT_NC, m_Edit_NC); DDX_Control(pDX, IDC_EDIT_ND, m_Edit_ND); DDX_Control(pDX, IDC_EDIT_CC, m_Edit_CC); DDX_Control(pDX, IDC_EDIT_CE, m_Edit_CE); //ComboBox. DDX_Control(pDX, IDC_COMBO_ST, m_Combo_ST); // Botones (CAD) DDX_Control(pDX, IDC_BUTTON_ST, m_PickButton_ST); DDX_Control(pDX, IDC_BUTTON_LI, m_PickButton_LI); DDX_Control(pDX, IDC_BUTTON_LC, m_PickButton_LC); DDX_Control(pDX, IDC_BUTTON_LD, m_PickButton_LD); DDX_Control(pDX, IDC_BUTTON_BI, m_PickButton_BI); DDX_Control(pDX, IDC_BUTTON_BD, m_PickButton_BD); // Botones Menú //DDX_Control(pDX, IDR_MENU_ST, OnCommandSTN); } BEGIN_MESSAGE_MAP(CPLEDERSeccionesTransversalesDlg, CAdUiDialog) ON_EN_KILLFOCUS(IDC_EDIT_BI, OnKillfocusEdit_BI) ON_EN_KILLFOCUS(IDC_EDIT_BD, OnKillfocusEdit_BD)  296  ON_EN_KILLFOCUS(IDC_EDIT_CC, OnKillfocusEdit_CC) ON_EN_KILLFOCUS(IDC_EDIT_CE, OnKillfocusEdit_CE) // Combo Box ON_CBN_SELCHANGE(IDC_COMBO_ST, OnKillfocusComboST) // Botones incluidos cad ON_BN_CLICKED(IDC_BUTTON_ST, OnButtonST) ON_BN_CLICKED(IDC_BUTTON_LI, OnButtonLI) ON_BN_CLICKED(IDC_BUTTON_LC, OnButtonLC) ON_BN_CLICKED(IDC_BUTTON_LD, OnButtonLD) ON_BN_CLICKED(IDC_BUTTON_BI, OnButtonBI) ON_BN_CLICKED(IDC_BUTTON_BD, OnButtonBD) // Botones ON_BN_CLICKED(IDC_BUTTON_APLICAR, OnCommandAPLICAR) // Botones, incluido del menú ON_COMMAND(ID_ST_NUEVO, OnCommandSTN) //ON_BN_CLICKED(IDOK, &CPLEDERLluviaEscorrentiaDlg::OnBnClickedOk) END_MESSAGE_MAP() // Controladores de mensajes de CPLEDERSeccionesTransversalesDlg BOOL CPLEDERSeccionesTransversalesDlg::OnInitDialog() { CDialog::OnInitDialog(); // Insertando las grillas m_wndList.SetHeadings(_T("Nº, 30; Estación, 80; Elevación, 80")); for (int i = 0; i < 500; i++) { m_wndList.InsertItem(0, _T(""), _T(""),_T("")); } m_wndList.SetGridLines(TRUE); //m_wndList.SetCheckboxes(TRUE); // Inicializa Cajas de texto m_Edit_LI.SetWindowText(m_LI); m_Edit_LC.SetWindowText(m_LC); m_Edit_LD.SetWindowText(m_LD); m_Edit_BI.SetWindowText(m_BI); m_Edit_BI.SetRange(1, MAX_VERTICES); m_Edit_BD.SetWindowText(m_BD); m_Edit_BD.SetRange(1, MAX_VERTICES); m_Edit_NI.SetWindowText(m_NI); m_Edit_NC.SetWindowText(m_NC); m_Edit_ND.SetWindowText(m_ND); m_Edit_CC.SetWindowText(m_CC); m_Edit_CC.SetRange(0, 1); 297  m_Edit_CE.SetWindowText(m_CE); m_Edit_CE.SetRange(0, 1); // Inicializa Bombo box //m_Combo_ST.SetCurSel(0); // Inicializa el boton tipo Cad m_PickButton_ST.AutoLoad(); m_PickButton_LI.AutoLoad(); m_PickButton_LC.AutoLoad(); m_PickButton_LD.AutoLoad(); m_PickButton_BI.AutoLoad(); m_PickButton_BD.AutoLoad(); if (!m_pSections) { // Sin secciones transversales return TRUE; } long i; CString str_IdST; // Cargar los valores a la ventana for (i = 0; i < m_Sections_len; i++) { // Preparar las cadenas acdbRToS((m_pSections + i)->IdST, 2, 2, str_IdST.GetBuffer(80)); // Insertar el Id de la S.T. al combo de la ventana m_Combo_ST.AddString(str_IdST); m_Combo_ST.SetCurSel(i); } // Verificar si existe S.T. en el Drawing if (m_Sections_len <= 0) { acutPrintf(_T("\nNo Existen Secciones Transversales definidos.")); return TRUE; } // Llama a los atributos de la S.T. OnKillfocusComboST(); return TRUE; } void CPLEDERSeccionesTransversalesDlg::OnKillfocusEdit_BI() { m_Edit_BI.Convert(); if (!m_Edit_BI.Validate()) { ::AfxMessageBox(_T("Entrada no válida, Fuera de rango")); m_Edit_BI.SetFocus(); m_Edit_BI.SetSel(0, -1); } 298  CString str; m_Edit_BI.GetWindowText(m_BI); acdbRToS(::_wtof(m_BI), 2, 0, str.GetBuffer(80)); m_Edit_BI.SetWindowText(str); } void CPLEDERSeccionesTransversalesDlg::OnKillfocusEdit_BD() { m_Edit_BD.Convert(); if (!m_Edit_BD.Validate()) { ::AfxMessageBox(_T("Entrada no válida, Fuera de rango")); m_Edit_BD.SetFocus(); m_Edit_BD.SetSel(0, -1); } CString str; m_Edit_BD.GetWindowText(m_BD); acdbRToS(::_wtof(m_BD), 2, 0, str.GetBuffer(80)); m_Edit_BD.SetWindowText(str); } void CPLEDERSeccionesTransversalesDlg::OnKillfocusEdit_CC() { m_Edit_CC.Convert(); if (!m_Edit_CC.Validate()) { ::AfxMessageBox(_T("Entrada no válida, rango = 0 @ 1")); m_Edit_CC.SetFocus(); m_Edit_CC.SetSel(0, -1); } CString str; m_Edit_CC.GetWindowText(m_CC); acdbRToS(::_wtof(m_CC), 2, 2, str.GetBuffer(80)); m_Edit_CC.SetWindowText(str); } void CPLEDERSeccionesTransversalesDlg::OnKillfocusEdit_CE() { m_Edit_CE.Convert(); if (!m_Edit_CE.Validate()) { ::AfxMessageBox(_T("Entrada no válida, rango = 0 @ 1")); m_Edit_CE.SetFocus(); m_Edit_CE.SetSel(0, -1); } CString str; m_Edit_CE.GetWindowText(m_CE); acdbRToS(::_wtof(m_CE), 2, 2, str.GetBuffer(80)); m_Edit_CE.SetWindowText(str); } void CPLEDERSeccionesTransversalesDlg::OnKillfocusComboST() { double Id_ST; // Obtener el valor del combo seleccionado int nIndex = m_Combo_ST.GetCurSel(); m_Combo_ST.GetLBText(nIndex,m_Id_ST); Id_ST = _wtof(m_Id_ST); double X1, Y1, LL, LC, LR, NL, NC, NR, CC, CE; long BL, BR, nVST; 299  AcGePoint2dArray GlobalVertices; AcGePoint2dArray LocalVertices; // Coger los atributos de la S.T. desde su id CS.GetIdCrossSectionsAttributes(Id_ST, &nVST, LocalVertices, GlobalVertices, &LL, &LC, &LR, &NL, &NC, &NR, &CC, &CE); // Borra todo los datos de la grilla. &BL, &BR, m_wndList.DeleteAllItems(ItemdataProc, (LPARAM)this); TCHAR strN[100]; TCHAR strX[100]; TCHAR strY[100]; // Inserta los valores de los vértices en la grilla for (int i=0; i< nVST; i++) { acdbRToS(i+1 , 2, 0, strN); acdbRToS(LocalVertices[i].x , 2, 3, strX); acdbRToS(LocalVertices[i].y , 2, 3, strY); m_wndList.InsertItem(nVST, strN, strX, strY); } // Inserta los valores de la S.T. en la ventana m_LI.Format(_T("%g"), LL ); m_Edit_LI.SetWindowText(m_LI); m_LC.Format(_T("%g"), LC ); m_Edit_LC.SetWindowText(m_LC); m_LD.Format(_T("%g"), LR ); m_Edit_LD.SetWindowText(m_LD); m_NI.Format(_T("%g"), NL ); m_Edit_NI.SetWindowText(m_NI); m_NC.Format(_T("%g"), NC ); m_Edit_NC.SetWindowText(m_NC); m_ND.Format(_T("%g"), NR ); m_Edit_ND.SetWindowText(m_ND); m_BI.Format(_T("%d"), BL ); m_Edit_BI.SetWindowText(m_BI); m_BD.Format(_T("%d"), BR ); m_Edit_BD.SetWindowText(m_BD); m_CC.Format(_T("%g"), CC ); m_Edit_CC.SetWindowText(m_CC); m_CE.Format(_T("%g"), CE ); m_Edit_CE.SetWindowText(m_CE); // Realizar un Zoom a la sección transversal CS.ZoomCrossSections(Id_ST); } void CPLEDERSeccionesTransversalesDlg::OnButtonST() { if(m_Combo_ST.GetCount() == 0) { ::AfxMessageBox(_T("PLEDER ERROR: \n Ingresar Una Nueva sección")); } return; //Esconde el diálogo BeginEditorCommand(); // Coge el valor del combo para asignar el nombre de la S.T. int nIndex = m_Combo_ST.GetCurSel(); m_Combo_ST.GetLBText(nIndex,m_Id_ST); m_IdST = _wtof(m_Id_ST); 300 // Coge los atributos de los textos de la ventana. double LI, // Longitud izquierdo. LC, // Longitud central. LD, // Longitud derecho. NI, // Coeficiente de manning Banco izquierdo. NC, // Coeficiente de manning canal central. ND, // Coeficiente de manning Banco derecho CC, // Coeficiente de contracción. CE; // Coeficiente de expansión. Adesk::Int32 BI, // Límite banco izquierdo. BD; // límite banco derecho. m_Edit_LI.GetWindowTextW(m_LI); LI = _wtof(m_LI); m_Edit_LD.GetWindowTextW(m_LD); LD = _wtof(m_LD); m_Edit_LC.GetWindowTextW(m_LC); LC = _wtof(m_LC); m_Edit_NI.GetWindowTextW(m_NI); NI = _wtof(m_NI); m_Edit_NC.GetWindowTextW(m_NC); NC = _wtof(m_NC); m_Edit_ND.GetWindowTextW(m_ND); ND = _wtof(m_ND); m_Edit_CC.GetWindowTextW(m_CC); CC = _wtof(m_CC); m_Edit_CE.GetWindowTextW(m_CE); CE = _wtof(m_CE); m_Edit_BI.GetWindowTextW(m_BI); BI = _wtof(m_BI); m_Edit_BD.GetWindowTextW(m_BD); BD = _wtof(m_BD); ads_point punto, p1; ads_name nombrep; int retval, valor1, valor2; double X1, Y1, area, elevacion; double Diametro = 0.2; double AlturaTexto = 0.2; //Inicializa las variables de sistema. RecursosST.InicializarVariables(); // crear las capas del proyecto if (RecursosST.PlederCapas() != RTNORM) { RecursosST.RestaurarVariables(); CompleteEditorCommand(); return; } // Selecciona la polilinea if (acedEntSel(_T("\nSeleccionar Polilinea: "), nombrep, punto) != RTNORM) { RecursosST.RestaurarVariables(); acutPrintf(_T("\nError al seleccionar la Polilinea"));  301  CompleteEditorCommand(); return; } // Llama al punto de referencia en la seccion transversal if (acedGetPoint (NULL, _T("\nIngrese un Punto de Referencia"), p1) != RTNORM ) { } RecursosST.RestaurarVariables(); acutPrintf(_T("\nError al ingresar el Punto")); CompleteEditorCommand(); return; acedInitGet (RSG_NONULL | RSG_NOZERO, _T("")); // Ingreso del valor Distancia X valor1 = acedGetReal( _T("\nDistancia X: " ), &X1); switch (valor1) { } case RTCAN: //Pulsó ESC { RecursosST.RestaurarVariables(); acutPrintf(_T("\nError al ingresar el Punto X")); CompleteEditorCommand(); return; } case RTNONE: //Pulsó solamente ENTER { RecursosST.RestaurarVariables(); acutPrintf(_T("\nError al ingresar el Punto X")); CompleteEditorCommand(); return; } case RTKWORD: //Ingresó un texto { RecursosST.RestaurarVariables(); acutPrintf(_T("\nError al ingresar el Punto X")); CompleteEditorCommand(); return; } case RTNORM: //Pulsó valor correcto break; default: return; //switch (valor1) // Ingreso del valor Cota Y valor2 = acedGetReal(_T("\nCota Y: " ), &Y1); switch (valor2) { case RTCAN: //Pulsó ESC { RecursosST.RestaurarVariables(); acutPrintf(_T("\nError al ingresar el Punto Y")); CompleteEditorCommand(); return; } case RTNONE: //Pulsó solamente ENTER { 302  RecursosST.RestaurarVariables(); acutPrintf(_T("\nError al ingresar el Punto Y")); CompleteEditorCommand(); return; } case RTKWORD: //Ingresó un texto { RecursosST.RestaurarVariables(); acutPrintf(_T("\nError al ingresar el Punto Y")); CompleteEditorCommand(); return; } case RTNORM: //Pulsó valor correcto break; default: return; } //switch (valor2) long nVST = 0; if ( GeometriaST.NumeroVerticesPolilinea(nombrep, &nVST) != RTNORM) { } acdbFail(_T("\nError [NumeroVerticesPolilinea()]")); CompleteEditorCommand(); return; // Inserta a la caja texto en la valor de nVST m_BD.Format(_T("%d"), nVST ); m_Edit_BD.SetWindowText(m_BD); BD = nVST; double *CX= new double[nVST+1]; (Estación) double *CY= new double[nVST+1]; (Elevación) // Lista de Coordenadas X // Lista de Coordenadas Y if ( GeometriaST.LeerVerticesPolilinea(nombrep, CX, CY) != RTNORM) { } acdbFail(_T("\nError [NumeroVerticesPolilinea()]")); CompleteEditorCommand(); return; double HminG = 0, HminL; // Vértice mínimo global if (CS.GetMinVertice(CY, nVST, &HminG)!= RTNORM) { acdbFail(_T("\nError [GetMinVertice]")); CompleteEditorCommand(); return; } // Vértice mínimo local HminL = Y1-(p1[Y] - HminG); // Crea la entidad personalizada PLEDERCrossSections desde ObjectDBX 303 CPLEDERCrossSections *pPolilinea; // crear la nueva entidad try { pPolilinea = new CPLEDERCrossSections(p1, X1, Y1, m_IdST, nVST, CX, CY, HminG, HminL, Diametro, AlturaTexto, LI, LC, LD, NI, NC, ND, BI, BD, CC, CE, m_Material, m_CoefProb, m_CoefMaterial); } catch(const std::bad_alloc&) { acdbFail(_T("\nError de asignación de memoria [pPolilinea].")); return ; } AcDbObjectId ID; // añadirla a la base de datos de AutoCAD if (RecursosST.AñadirEntidadBlockTableRecord((AcDbEntity*)pPolilinea, ID) != Acad::eOk) { if (pPolilinea) { delete pPolilinea; } acdbFail(_T("\nError al añadir la entidad a la Base de Datos [AñadirEntidadBlockTableRecord].")); return ; } //Alimenta los datos a la grilla. TCHAR strN[100]; TCHAR strX[100]; TCHAR strY[100]; // Borra todo los datos de la grilla. m_wndList.DeleteAllItems(ItemdataProc, (LPARAM)this); ads_point v1; for (int i = 1; i<= nVST; i++) { v1[X]= X1 + (CX[i] - p1[X]); // Suma la posición inicial X + la distancia X v1[Y]= Y1 - (p1[Y] - CY[i]); // Resta la posición inicial Y - la distancia Y acdbRToS(i , 2, 0, strN); acdbRToS(v1[X], 2, 3, strX); acdbRToS(v1[Y], 2, 3, strY); m_wndList.InsertItem(nVST, strN,strX,strY); X1= v1[X]; Y1= v1[Y]; p1[X]= CX[i]; p1[Y]= CY[i]; }  304  RecursosST.RestaurarVariables(); //Restaura las variables de sistema //Retorna al diálogo CompleteEditorCommand(); delete [] CX; delete [] CY; } void CPLEDERSeccionesTransversalesDlg::OnButtonLI() { double L = OnButtonDistancia(); m_LI.Format(_T("%g"), L ); m_Edit_LI.SetWindowText(m_LI); } void CPLEDERSeccionesTransversalesDlg::OnButtonLC() { double L = OnButtonDistancia(); m_LC.Format(_T("%g"), L ); m_Edit_LC.SetWindowText(m_LC); } void CPLEDERSeccionesTransversalesDlg::OnButtonLD() { double L = OnButtonDistancia(); m_LD.Format(_T("%g"), L ); m_Edit_LD.SetWindowText(m_LD); } void CPLEDERSeccionesTransversalesDlg::OnButtonBI() { double Id_ST; // Obtener el valor del combo seleccionado int nIndex = m_Combo_ST.GetCurSel(); m_Combo_ST.GetLBText(nIndex,m_Id_ST); Id_ST = _wtof(m_Id_ST); double X1, Y1, LL, LC, LR, NL, NC, NR, CC, CE; long BL, BR; AcGePoint2dArray GlobalVertices; AcGePoint2dArray LocalVertices; long nVST; // Coger los atributos de la S.T. desde su id CS.GetIdCrossSectionsAttributes(Id_ST, &nVST, LocalVertices, GlobalVertices, &LL, &LC, &LR, &NL, &NC, &NR, &CC, &CE); //Esconde el diálogo BeginEditorCommand(); int nV; acedInitGet(RSG_NONULL, NULL); // Solicitar el número de Vértice &BL, &BR, 305  if (acedGetInt(_T("\nVértice del banco izquierdo: "), &nV) != RTNORM) { } CompleteEditorCommand(); return; // No se permite nV = 0 if (nV <= 0) { ::AfxMessageBox(_T("\nEntrada no válida.")); CompleteEditorCommand(); return; } // Verifica si esta dentro del rango de vértices if (nV > nVST) { rango")); } ::AfxMessageBox(_T("\nEntrada no válida. \nFuera de CompleteEditorCommand(); return; // Si todo es correcto CompleteEditorCommand(); m_BI.Format(_T("%d"), nV ); m_Edit_BI.SetWindowText(m_BI); } void CPLEDERSeccionesTransversalesDlg::OnButtonBD() { double Id_ST; // Obtener el valor del combo seleccionado int nIndex = m_Combo_ST.GetCurSel(); m_Combo_ST.GetLBText(nIndex,m_Id_ST); Id_ST = _wtof(m_Id_ST); double X1, Y1, LL, LC, LR, NL, NC, NR, CC, CE; long BL, BR; AcGePoint2dArray GlobalVertices; AcGePoint2dArray LocalVertices; long nVST; // Coger los atributos de la S.T. desde su id CS.GetIdCrossSectionsAttributes(Id_ST, &nVST, LocalVertices, GlobalVertices, &LL, &LC, &LR, &NL, &NC, &NR, &CC, &CE); //Esconde el diálogo BeginEditorCommand(); int nVD; acedInitGet(RSG_NONULL, NULL); // Solicitar el número de Vértice &BL, &BR, if (acedGetInt(_T("\nVértice del banco derecho: "), &nVD) != RTNORM) 306  { } CompleteEditorCommand(); return; // No se permite nVD = 0 if (nVD <= 0) { ::AfxMessageBox(_T("\nEntrada no válida.")); CompleteEditorCommand(); return; } // Verifica si está dentro del rango de vértices if (nVD > nVST) { rango")); } ::AfxMessageBox(_T("\nEntrada no válida. \nFuera de CompleteEditorCommand(); return; // Verifica si el nV (derecho) > nV (izquierdo) m_Edit_BI.GetWindowText(m_BI); if( _wtof(m_BI) >= nVD) { ::AfxMessageBox(_T("\nEntrada no válida. \nNº de vértice Izq. > Nº de vértice Der.)")); CompleteEditorCommand(); return; } // Si todo es correcto CompleteEditorCommand(); m_BD.Format(_T("%d"), nVD ); m_Edit_BD.SetWindowText(m_BD); } // Nueva Sección Transversal void CPLEDERSeccionesTransversalesDlg::OnCommandSTN() { //Declaracion de Objetos diálogos CPLEDERST1Dlg dlgSTN(CWnd::FromHandle(adsw_acadMainWnd())); if (dlgSTN.DoModal() != IDOK) { acutPrintf(_T("\nPLEDER: Se Canceló la Operación")); return; } double IdST, iST; IdST = _wtof(dlgSTN.m_NST); for(int i = 0; i < m_Combo_ST.GetCount(); i++) { m_Combo_ST.GetLBText(i,m_Id_ST); iST = _wtof(m_Id_ST); // Verifica si hay duplicidad 307 if (IdST == iST) { ::AfxMessageBox(_T("PLEDER ERROR: \nNo se permite duplicar")); acutPrintf(_T("\nNo se permite duplicar")); return; } } m_Combo_ST.AddString(dlgSTN.m_NST); int pos = 0; // Buscar la posicion para la seleción actual for(int i = 0; i < m_Combo_ST.GetCount(); i++) { m_Combo_ST.GetLBText(i,m_Id_ST); iST = _wtof(m_Id_ST); if (IdST == iST) { break;} pos++; } m_Combo_ST.SetCurSel(pos); // Borra todo los datos de la grilla. m_wndList.DeleteAllItems(ItemdataProc, (LPARAM)this); } double CPLEDERSeccionesTransversalesDlg::OnButtonDistancia() /*-------------------------------------------------------------------- Ingreso : Vacío. Salida : Vacío Propósito : Calcula la distancia entre varios puntos --------------------------------------------------------------------*/ { //Esconde el diálogo BeginEditorCommand(); ads_point p1, p2; int contador =0; double L=0.0 , ls=0.0; //Coge el Primer Punto P1 if (acedGetPoint (NULL, _T("\nIngrese el primer Punto [cota menor]"), p1) != RTNORM ) { acutPrintf(_T("\nPLEDER: !ERROR!\nal ingresar el Punto")); CompleteEditorCommand(); return RTERROR; } while (true) { // Cogen los puntos siguienes if (acedGetPoint(p1, _T("\nSiguiente punto: "), p2) != RTNORM) { CompleteEditorCommand(); return L; } contador++; // siguiente ls = acutDistance(p1,p2); L = L + ls;  308 acutPrintf(_T("\nDistancia %d: %0.3f"), contador, ls); p1[X]=p2[X]; p1[Y]=p2[Y]; p1[Z]=0.0; }//while return RTNORM; } void CPLEDERSeccionesTransversalesDlg::OnCommandAPLICAR() { // Coge los atributos de los textos de la ventana. Double LL, // Longitud izquierdo. LC, // Longitud central. LR, // Longitud derecho. NL, // Coeficiente de manning Banco izquierdo. NC, // Coeficiente de manning canal central. NR, // Coeficiente de manning Banco derecho CC, // Coeficiente de contracción. CE; // Coeficiente de expansión. Adesk::Int32 BL, // Límite banco izquierdo. BR; // Límite banco derecho. double IdST; // Id Seccion Transversal // Obtener los valores de las cajas de texto m_Edit_LI.GetWindowTextW(m_LI); LL = _wtof(m_LI); m_Edit_LC.GetWindowTextW(m_LC); LC = _wtof(m_LC); m_Edit_LD.GetWindowTextW(m_LD); LR = _wtof(m_LD); m_Edit_NI.GetWindowTextW(m_NI); NL = _wtof(m_NI); m_Edit_NC.GetWindowTextW(m_NC); NC = _wtof(m_NC); m_Edit_ND.GetWindowTextW(m_ND); NR = _wtof(m_ND); m_Edit_CC.GetWindowTextW(m_CC); CC = _wtof(m_CC); m_Edit_CE.GetWindowTextW(m_CE); CE = _wtof(m_CE); m_Edit_BI.GetWindowTextW(m_BI); BL = _wtof(m_BI); m_Edit_BD.GetWindowTextW(m_BD); BR = _wtof(m_BD); if(BL >= BR) { ::AfxMessageBox(_T("PLEDER ERROR: \nVértices del banco izquierdo >= al derecho")); //acutPrintf(_T("\n....La Aplicación de datos no fue exitosa....")); return; } // Obtener el valor del combo seleccionado int nIndex = m_Combo_ST.GetCurSel(); m_Combo_ST.GetLBText(nIndex,m_Id_ST); IdST = _wtof(m_Id_ST); struct resbuf *filter; // resbufs // Preparar el filtro para seleccionar las S.T. filter = acutBuildList( RTDXF0, _T("CPLEDERCrossSections"), 8, PLEDER_CAPA_SECCIONTRANSVERSAL, 0); if (!filter) {  309  acdbFail(_T("\nError al construir el filtro [acutBuildList].")); return ; } ads_name long ss; // ss sslen = 0; // longitud del ss // seleccionar las secciones transversales definidas if (acedSSGet(_T("_X"), NULL, NULL, filter, ss) != RTNORM) { acutPrintf(_T("\nNo hay secciones transversales definidas en el drawing")); acutRelRb(filter); return; } acutRelRb(filter); // tomar la longitud del ss if (acedSSLength(ss, &sslen) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar la longitud del conjunto de selección [acedSSLength].")); return; } CPLEDERCrossSections ads_name AcDbObjectId // recorrer el ss *pSecciones; ename; ID; for (int i = 0; i < sslen; i++) { // tomar el nombre de la entidad if (acedSSName(ss, i, ename) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar el nombre de la entidad CPLEDERCrossSections [acedSSName].")); return; } // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, ename) != Acad::eOk) { acedSSFree(ss); acdbFail(_T("\nError al tomar el ObjectId de la entidad CPLEDERCrossSections [acdbGetObjectId].")); return; } // abrir el objeto para escritura if (acdbOpenObject(pSecciones, ID, /*AcDb::kForRead*/ AcDb::kForWrite) != Acad::eOk) { acedSSFree(ss); acdbFail(_T("\nError al abrir el Objeto CPLEDERCrossSections [acdbOpenObject].")); return ; 310  } // chequear el tipo de objeto if (pSecciones->isKindOf(CPLEDERCrossSections::desc()) != Adesk::kTrue) { pSecciones->close(); acedSSFree(ss); acdbFail(_T("\nError Objeto CPLEDERCrossSections ")); return; } double Id_Seccion; // Tomar el ID para comparar pSecciones->IdCrossSections(Id_Seccion); // Si procede, actualizar los datos de la S.T. if (Id_Seccion == IdST) { pSecciones->SetLengthLeft(LL); pSecciones->SetLengthCenter(LC); pSecciones->SetLengthRight(LR); pSecciones->SetManningLeft(NL); pSecciones->SetManningCenter(NC); pSecciones->SetManningRight(NR); pSecciones->SetBankLeft(BL); pSecciones->SetBankRight(BR); pSecciones->SetCoeficentCont(CC); pSecciones->SetCoeficentExp(CE); } // if pSecciones->close(); } // for i acedSSFree(ss); acutPrintf(_T("\n....Datos modificados en forma Exitosa....")); return; } BOOL CPLEDERSeccionesTransversalesDlg::ItemdataProc(DWORD dwData, LPARAM lParam) { // TODO: Process your item data here // Please return TRUE to proceed the deletion, return FALSE to abort. return TRUE; } /*----------------------------------------------------------------- ------------------------------------------------------------------*/ // PLEDERST1Dlg.cpp: archivo de implementación // Cuadro de diálogo de CPLEDERST1Dlg 311  IMPLEMENT_DYNAMIC(CPLEDERST1Dlg, CDialog) CPLEDERST1Dlg::CPLEDERST1Dlg(CWnd* pParent /*=NULL*/) : CDialog(CPLEDERST1Dlg::IDD, pParent) { m_Edit_NST.SetFocus(); //m_Edit_NST.SetSel(0, -1); } CPLEDERST1Dlg::~CPLEDERST1Dlg() { } void CPLEDERST1Dlg::DoDataExchange(CDataExchange* pDX) { CDialog::DoDataExchange(pDX); // Cajas de Texto. DDX_Control(pDX, IDC_EDIT_NST, m_Edit_NST); } BEGIN_MESSAGE_MAP(CPLEDERST1Dlg, CDialog) ON_BN_CLICKED(IDOK, &CPLEDERST1Dlg::OnBnClickedOk) END_MESSAGE_MAP() // Controladores de mensajes de CPLEDERST1Dlg void CPLEDERST1Dlg::OnBnClickedOk() { // Coge los valores despues de pulsar OK // Cajas de texto m_Edit_NST.GetWindowText(m_NST); CDialog::OnOK(); //algo.EnableWindow( FALSE ); }
Apendice C HIDRAULICA FLUVIAL CODIGO FUENTE C++ EL componente Hidraulica Fluvial se organiza en 02 libreras con multiples funciones y 01 ventana grafica 313 Apendice C. HIDRAULICA FLUVIAL CODIGO FUENTE C++ ARCHIVOS DE CABECERA: PLEDERSocavacionGeneral.h #pragma once class CPLEDERSocavacionGeneral { public: CPLEDERSocavacionGeneral(void); ~CPLEDERSocavacionGeneral(void); public: // Cálculo de los datos para el coeficiente X. int SGDatosMaterial(int Material, float *DatosMaterialX, float *DatosMaterialY); // Cálculo de la variable X. int SGCoeficienteX(int Material, float CoefMaterial, float *X); // Cálculo del tirante medio H0 encada vértice de la sección transversal int SGVerticesH0(AcGePoint2dArray Vertices, AcGePoint2dArray& VerticesH0); // Cálculo de la socavación mediante el método de Lischtvan Lebeviev. int SGLischtvanLebeviev(float Q, float A, float P, AcGePoint2dArray VerticesH0, int Material, int CoefProb, float CoefMaterial, float X, AcGePoint2dArray& VerticesSoc); }; PLEDERSocavacionGeneralDlg.h //-------------------------------------------------------------------- //----- PLEDERSocavacionGeneralDlg.h : Declaration of the CPLEDERSocavacionGeneralDlg //-------------------------------------------------------------------- #pragma once //-------------------------------------------------------------------- class FGVResultadosBufer; #include "adui.h" #include "PLEDERReportCtrl.h" #include "resource.h" //-------------------------------------------------------------------- class CPLEDERSocavacionGeneralDlg : public CAdUiDialog { DECLARE_DYNAMIC (CPLEDERSocavacionGeneralDlg) public: static BOOL CALLBACK ItemdataProc(DWORD dwData, LPARAM lParam); CPLEDERSocavacionGeneralDlg (CWnd *pParent =NULL, HINSTANCE hInstance =NULL) ; virtual ~CPLEDERSocavacionGeneralDlg(); enum { IDD = IDD_HFLUVIAL_SOC} ; // Cajas de texto CAcUiNumericEdit m_Edit_SOCPes; CString m_SOCPes; CAcUiNumericEdit m_Edit_SOCDm; CString m_SOCDm; CAcUiNumericEdit m_Edit_SOCCoef; CString m_SOCCoef; // Combo Box CComboBox m_Combo_SOCId; CString m_SOCId; double m_STSOCId; CComboBox m_Combo_SOCProbg; CString m_SOCProbg; // Radio CButton m_Button_MaterialNoCoh; CButton m_Button_MaterialCoh; int m_Material; protected: virtual void DoDataExchange (CDataExchange *pDX) ; afx_msg LRESULT OnAcadKeepFocus (WPARAM, LPARAM) ; afx_msg void OnButtonTRPunto(); afx_msg void OnKillfocusEdit_SOCPes(); afx_msg void OnKillfocusEdit_SOCDm(); // Radio (Cuando existan cambios en el radio) afx_msg void OnRadioMaterialCohesivo(); afx_msg void OnRadioMaterialNoCohesivo(); // Para los combos afx_msg void OnKillfocusComboSOCId(); afx_msg void OnKillfocusComboSOCProbg(); // Botones afx_msg void OnCommandSOCAPLICAR(); public: virtual BOOL OnInitDialog(); public: FGVResultadosBufer* struct m_theFirstT; Socavacion* m_pSocavacion; los resultados. long m_Socavacion_len; DECLARE_MESSAGE_MAP() afx_msg void OnEnChangeEditSoccoef(); }; // Struct buffer para  ARCHIVOS Cpp: PLEDERSocavacionGeneral.cpp #include "StdAfx.h" #include "PLEDERSocavacionGeneral.h" #include "PLEDERMetodosNumericos.h" CMetodosNumericos CN; CPLEDERSocavacionGeneral::CPLEDERSocavacionGeneral(void) { } CPLEDERSocavacionGeneral::~CPLEDERSocavacionGeneral(void) { } int CPLEDERSocavacionGeneral::SGDatosMaterial(int Material, float *DatosMaterialX, float *DatosMaterialY) /*-------------------------------------------------------------------- Ingreso : Material = Tipo de material del lecho 1 -> No cohesivo. 0 -> Cohesivo. Salida Propósito : DatosMaterialX = Recibe en una lista los valores de las coordenadas X. Dependiendo del tipo del material. DatosMaterialX = Recibe en una lista los valores de las coordenadas Y. Dependiendo del tipo del material. : Prepara los datos en listas, dependiendo del tipo de material del lecho .------------------------------------------------------------------ */ { int i; float Coh_X[26] = {0.80,0.83,0.86,0.88,0.90,0.93,0.96,0.98,1.00,1.04,1.08,1.12,1.1 6,1.20,1.24,1.28,1.34,1.40,1.46,1.52,1.58,1.64,1.71,1.80,1.89,2. 00}; float Coh_Y[26] = {0.52,0.51,0.50,0.49,0.48,0.47,0.46,0.45,0.44,0.43,0.42,0.41,0.4 0,0.39,0.38,0.37,0.36,0.35,0.34,0.33,0.32,0.31,0.30,0.29,0.28,0. 27}; float NoCoh_X[25] = {0.05,0.15,0.50,1.00,1.50,2.50,4.00,6.00,8.00,10.00,15.00,20.00, 25.00,40.00,60.00,90.00,140.00,190.00,250.00,310.00,370.00,450.0 0,570.00,750.00,1000.00}; float NoCoh_Y[25] = {0.43,0.42,0.41,0.40,0.39,0.38,0.37,0.36,0.35,0.34,0.33,0.32,0.3 1,0.30,0.29,0.28,0.27,0.26,0.25,0.24,0.23,0.22,0.21,0.20,0.19}; if(Material == 1) // material no Cohesivo. { for (i=1; i<= 25; i++) { DatosMaterialX[i] = NoCoh_X[i-1]; DatosMaterialY[i] = NoCoh_Y[i-1]; } } // if 1 316 if(Material == 0) // material Cohesivo. { for (i=1; i<= 26; i++) { DatosMaterialX[i] = Coh_X[i-1]; DatosMaterialY[i] = Coh_Y[i-1]; } } // if 0 return RTNORM; } int CPLEDERSocavacionGeneral::SGCoeficienteX(int Material, float CoefMaterial, float *X) /*-------------------------------------------------------------------- Ingreso : Material = Tipo de material del lecho. 1 -> No cohesivo. 0 -> Cohesivo. CoefMaterial = Coeficiente o dato del material del lecho. Salida : X = Valor interpolado linealmente, según la tabla que se expone en la teoría (Capítulo V) Propósito : Calcula el coeficiente X, necesario para la fórmula de la socavación. -------------------------------------------------------------------*/ { int i; float Y; float *DatosMaterialX = new float[28]; float *DatosMaterialY = new float[28]; if(Material == 1) // Material No Cohesivo. { if(CoefMaterial > 0.0 & CoefMaterial < 0.05) // mm { // Se ajusta a un sólo valor = 0.43 *X = 0.43; } if(CoefMaterial >= 0.05 & CoefMaterial <= 1000.0) // mm { // Recibe los datos del material para una interpolación, SGDatosMaterial(Material, DatosMaterialX, DatosMaterialY); // Interpolaciones lineales. *X = CN.InterpolacionLineal(25,DatosMaterialY,DatosMaterialX, CoefMaterial); } if(CoefMaterial > 1000.0) // mm { // Para R2 = 0.99 (polinómica) *X = 0.00000013*CoefMaterial*CoefMaterial - 0.00024369*CoefMaterial + 0.30353418; } } // if 1 ApendiceC. if(Material == 0) // Material Cohesivo. { if(CoefMaterial > 0.0 & CoefMaterial < 0.80) // Ton/m3 { // Para R2 = 0.99 (polinómica) y = -0.097311x3 + 0.538865x2 - 1.113115x + 1.116961 *X = -0.097311*CoefMaterial*CoefMaterial*CoefMaterial + 0.538865*CoefMaterial*CoefMaterial - 1.113115*CoefMaterial + 1.116961; } if(CoefMaterial >= 0.80 & CoefMaterial <= 2.00) // Ton/m3 { // Recibe los datos del material para una interpolación, SGDatosMaterial(Material, DatosMaterialX, DatosMaterialY); // Interpolaciones lineales. *X = CN.InterpolacionLineal(25,DatosMaterialY,DatosMateria lX, CoefMaterial); } if(CoefMaterial > 2.0) // Ton/m3 { // Para R2 = 0.99 (polinómica) y = -0.097311x3 + 0.538865x2 - 1.113115x + 1.116961 *X = -0.097311*CoefMaterial*CoefMaterial*CoefMaterial + 0.538865*CoefMaterial*CoefMaterial - 1.113115*CoefMaterial+ 1.116961; } } // if 0 delete [] DatosMaterialX; delete [] DatosMaterialY; return RTNORM; } int CPLEDERSocavacionGeneral::SGVerticesH0(AcGePoint2dArray Vertices, AcGePoint2dArray& VerticesH0) { int k; AcGePoint2d Vertex; // Calculo de los tirantes medios (H0) for (k = 0; k < Vertices.length()-1; k++) { Vertex[X] = (2*Vertices[0].y - Vertices[k].y - Vertices[k+1].y )/2.0; Vertex[Y] = 0.0; VerticesH0.append(Vertex); //acutPrintf(_T("\nH0[%d]: %0.3f"), k, VerticesH0[k].x ); } return RTNORM; } 318 int CPLEDERSocavacionGeneral::SGLischtvanLebeviev(float Q, float A, float P, AcGePoint2dArray VerticesH0, int Material, int CoefProb, float CoefMaterial, float X,AcGePoint2dArray& VerticesSoc) /*------------------------------------------------------------------- Ingreso : Q = Caudal del flujo (m3/s) A = Area del flujo calculado en la sección transversal. P = Perímetro del flujo calculado en la sección transversal. VerticesH0;= Vértices de H0 = (Hj+ Hj+1)/2 Material = Tipo de material del lecho. 1 -> No cohesivo. 0 -> Cohesivo. CoefProb = Coeficiente de probabilidad de ocurrencia del flujo. CoefMaterial= Coeficiente o dato del material del lecho. X = Valor interpolado linealmente, según la tabla Salida : Propósito : Calcula la altura de la socavación general en la sección transversal. --------------------------------------------------------------------*/ { float v, // Coeficiente de probabilidad de gasto Exp23 = 2.0/3.0, Exp53 = 5.0/3.0, ExpMatNc= 0.28, ExpMatC = 1.18, Exp1X = 1.0/(1.0+X); int k; AcGePoint2d Vertex; switch (CoefProb) { case 0: { v = 0.77; break; } case 1: { v = 0.82; break; } case 2: { v = 0.86; break; } case 3: { v = 0.90; break; } case 4: { v = 0.94; break; } case 5: { v = 0.97; break; } case 6: { v = 1.00; break; } case 7: { v = 1.03; break; } case 8: { v = 1.05; break; } case 9: { v = 1.07; break; } default: acutPrintf(_T("\nFuera de Rango")); } //switch (CoefProb) float H0, Hs; if (Material == 1) // Fórmula para un lecho No Cohesivo { for (k = 0; k < VerticesH0.length(); k++) { H0 = VerticesH0[k].x; Hs = Q*pow(P,Exp23)*pow(H0, Exp53)/ (0.68*v*pow(A,Exp53)*pow(CoefMaterial,ExpMatNc)); Hs = pow(Hs,Exp1X); Vertex[X] = 0.0; Vertex[Y] = Hs; VerticesSoc.append(Vertex); } // for k } //if if (Material == 0) // Fórmula para lecho Cohesivo { for (k = 0; k < VerticesH0.length(); k++) { H0 Hs = VerticesH0[k].x; = Q*pow(P,Exp23)*pow(H0,Exp53)/ (0.60*v*pow(A,Exp53)*pow(CoefMaterial,ExpMatC)); Hs = pow(Hs,Exp1X); Vertex[X] = 0.0; Vertex[Y] = Hs; // For k VerticesSoc.append(Vertex); } } // if return RTNORM; } PLEDERSocavacionGeneralDlg.cpp //-------------------------------------------------------------------- //----- PLEDERTranSediFormaFondoDlg.cpp : Implementation of CPLEDERTranSediFormaFondoDlg //-------------------------------------------------------------------- #include "StdAfx.h" #include "resource.h" #include "PLEDERSocavacionGeneralDlg.h" #include "PLEDERSeccionesTransversales.h" #include "PLEDERHidraBuffer.h" #include "PLEDERRecursosCad.h" #include "axlock.h" CRecursosCad RSOC; CPLEDERSeccionesTransversales STSOC; // Tabla //----------------------------------------------------------------------------- IMPLEMENT_DYNAMIC (CPLEDERSocavacionGeneralDlg, CAdUiDialog) BEGIN_MESSAGE_MAP(CPLEDERSocavacionGeneralDlg, CAdUiDialog) ON_MESSAGE(WM_ACAD_KEEPFOCUS, OnAcadKeepFocus) ON_EN_KILLFOCUS(IDC_EDIT_SOCPes, OnKillfocusEdit_SOCPes) ON_EN_KILLFOCUS(IDC_EDIT_SOCDm, OnKillfocusEdit_SOCDm) // Botones incluidos cad ON_BN_CLICKED(IDC_BUTTON_SOCApl, OnCommandSOCAPLICAR) // Radios (cambios en los Radios) ON_BN_CLICKED(IDC_RADIO_SOCCoh, OnRadioMaterialCohesivo) ON_BN_CLICKED(IDC_RADIO_SOCNocoh, OnRadioMaterialNoCohesivo) // Combo Box ON_CBN_SELCHANGE(IDC_COMBO_SOCId, OnKillfocusComboSOCId) ON_CBN_SELCHANGE(IDC_COMBO_SOCProbg, OnKillfocusComboSOCProbg) ON_EN_CHANGE(IDC_EDIT_SOCCoef, &CPLEDERSocavacionGeneralDlg::OnEnChangeEditSoccoef) END_MESSAGE_MAP() //--------------------------------------------------------------------  CPLEDERSocavacionGeneralDlg::CPLEDERSocavacionGeneralDlg (CWnd *pParent /*=NULL*/, HINSTANCE hInstance /*=NULL*/) : CAdUiDialog (CPLEDERSocavacionGeneralDlg::IDD, pParent, hInstance) { m_Material = 0; m_SOCPes = _T("0.0"); m_SOCDm = _T("0.0"); m_SOCCoef = _T("1.00"); } CPLEDERSocavacionGeneralDlg::~CPLEDERSocavacionGeneralDlg() { } //-------------------------------------------------------------------- void CPLEDERSocavacionGeneralDlg::DoDataExchange (CDataExchange *pDX) { CAdUiDialog::DoDataExchange (pDX) ; // Cajas de Texto. DDX_Control(pDX, IDC_EDIT_SOCPes, m_Edit_SOCPes); DDX_Control(pDX, IDC_EDIT_SOCDm, m_Edit_SOCDm); DDX_Control(pDX, IDC_EDIT_SOCCoef, m_Edit_SOCCoef); // Radio DDX_Control(pDX, IDC_RADIO_SOCNocoh, m_Button_MaterialNoCoh); DDX_Control(pDX, IDC_RADIO_SOCCoh, m_Button_MaterialCoh); //DDX_Radio(pDX, IDC_RADIO_SOCNocoh, m_Material); //ComboBox DDX_Control(pDX, IDC_COMBO_SOCId, m_Combo_SOCId); DDX_Control(pDX, IDC_COMBO_SOCProbg, m_Combo_SOCProbg); } //-------------------------------------------------------------------- //----- Needed for modeless dialogs to keep focus. //----- Return FALSE to not keep the focus, return TRUE to keep the focus LRESULT CPLEDERSocavacionGeneralDlg::OnAcadKeepFocus (WPARAM, LPARAM) { return (TRUE) ; } BOOL CPLEDERSocavacionGeneralDlg::OnInitDialog() { CDialog::OnInitDialog(); // Inicializar cajas de texto m_Edit_SOCPes.SetWindowText(m_SOCPes); m_Edit_SOCPes.SetRange(0,100); m_Edit_SOCDm.SetWindowText(m_SOCDm); m_Edit_SOCDm.SetRange(0,10000); m_Edit_SOCCoef.SetWindowText(m_SOCCoef); // Activar radio Material No Cohesivo m_Button_MaterialNoCoh.SetCheck(1); // Activa y desactiva para material Cohesivo. m_Edit_SOCPes.EnableWindow(0); m_Edit_SOCDm.EnableWindow(1); m_Material = 1; // Por defecto en la posición 6 (1%) m_Combo_SOCProbg.SetCurSel(6); // Cargar los Ids de las secciones transversales. if (!m_pSocavacion) { } // Sin secciones transversales return TRUE; long i; CString str_IdST; // Cargar los valores a la ventana for (i = 0; i < m_Socavacion_len; i++) { // Preparar las cadenas acdbRToS((m_pSocavacion + i)->IdST, 2, 3, str_IdST.GetBuffer(80)); // Insertar el Id de la S.T. al combo de la ventana m_Combo_SOCId.AddString(str_IdST); m_Combo_SOCId.SetCurSel(i); } // Verificar si existe S.T. en el Drawing if (m_Socavacion_len <= 0) { acutPrintf(_T("\nNo Existen Secciones Transversales definidos.")); return TRUE; } // Llama a los atributos de la S.T. OnKillfocusComboSOCId(); return TRUE; } void CPLEDERSocavacionGeneralDlg::OnKillfocusEdit_SOCPes() { m_Edit_SOCPes.Convert(); if (!m_Edit_SOCPes.Validate()) { ::AfxMessageBox(_T("Entrada no válida, Fuera de rango")); m_Edit_SOCPes.SetFocus(); m_Edit_SOCPes.SetSel(0, -1); } CString str; m_Edit_SOCPes.GetWindowText(m_SOCPes); acdbRToS(::_wtof(m_SOCPes), 2, 3, str.GetBuffer(80)); m_Edit_SOCPes.SetWindowText(str); } void CPLEDERSocavacionGeneralDlg::OnKillfocusEdit_SOCDm() { m_Edit_SOCDm.Convert();if (!m_Edit_SOCDm.Validate()) { ::AfxMessageBox(_T("Entrada no válida, Fuera de rango")); m_Edit_SOCDm.SetFocus(); m_Edit_SOCDm.SetSel(0, -1); } CString str; m_Edit_SOCDm.GetWindowText(m_SOCDm); acdbRToS(::_wtof(m_SOCDm), 2, 3, str.GetBuffer(80)); m_Edit_SOCDm.SetWindowText(str); } void CPLEDERSocavacionGeneralDlg::OnRadioMaterialCohesivo() { // Activa y desactiva las casillas de la ventana m_Edit_SOCPes.EnableWindow(1); m_Edit_SOCDm.EnableWindow(0); m_Material = 0; } void CPLEDERSocavacionGeneralDlg::OnRadioMaterialNoCohesivo() { // Activa las casillas de la ventana m_Edit_SOCPes.EnableWindow(0); m_Edit_SOCDm.EnableWindow(1); m_Material = 1; } void CPLEDERSocavacionGeneralDlg::OnEnChangeEditSoccoef() { // TODO: Si éste es un control RICHEDIT, el control no // enviará esta notificación a menos que se invalide CAdUiDialog::OnInitDialog() // función y llamada CRichEditCtrl().SetEventMask() // con el marcador ENM_CHANGE ORed en la máscara. // TODO: Agregue aquí el controlador de notificación de controles } void CPLEDERSocavacionGeneralDlg::OnCommandSOCAPLICAR() { // Parámetros para socavación int Material, CoefProb; double // Tipo de material, Cohesivo = 0, No Cohesivo = 1. // Coeficiente de probabilidad de gasto. CoefMaterial; double IdST; // Peso específico ó diámetro medio del material de fondo. // id Seccion Transversal // Obtener el valor del combo seleccionado int nIndex = m_Combo_SOCId.GetCurSel(); m_Combo_SOCId.GetLBText(nIndex,m_SOCId); IdST = _wtof(m_SOCId); CoefProb = m_Combo_SOCProbg.GetCurSel(); // Obtener los atributos de la ventana Material = m_Material; if(Material == 1) // Material No cohesivo { m_Edit_SOCDm.GetWindowTextW(m_SOCDm); CoefMaterial = _wtof(m_SOCDm); } else // Material cohesivo { m_Edit_SOCPes.GetWindowTextW(m_SOCPes); CoefMaterial = _wtof(m_SOCPes); } // Verificando los datos correctos if(CoefMaterial <= 0.0) { acutPrintf(_T("\nLos datos de la seccion: %0.3f, no fueron cargados correctamente"), IdST ); return; } struct resbuf *filter; // resbufs // Preparar el filtro para seleccionar las S.T. filter = acutBuildList( RTDXF0, _T("CPLEDERCrossSections"), 8, 0); if (!filter) { PLEDER_CAPA_SECCIONTRANSVERSAL, acdbFail(_T("\nError al construir el filtro [acutBuildList].")); return ; } ads_name long ss; // ss sslen = 0; // longitud del ss // seleccionar las secciones transversales definidas if (acedSSGet(_T("_X"), NULL, NULL, filter, ss) != RTNORM) { acutPrintf(_T("\nNo hay secciones transversales definidas en el drawing")); acutRelRb(filter); return; } acutRelRb(filter); // tomar la longitud del ss if (acedSSLength(ss, &sslen) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar la longitud del conjunto de selección [acedSSLength].")); return; } CPLEDERCrossSections ads_name AcDbObjectId *pSecciones; ename; ID; // recorrer el ss for (int i = 0; i < sslen; i++) { // tomar el nombre de la entidad if (acedSSName(ss, i, ename) != RTNORM) { acedSSFree(ss); acdbFail(_T("\nError al tomar el nombre de la entidad CPLEDERCrossSections [acedSSName].")); return; } // cambiar el nombre por el ObjectId if (acdbGetObjectId(ID, ename) != Acad::eOk) { acedSSFree(ss); acdbFail(_T("\nError al tomar el ObjectId de la entidad CPLEDERCrossSections [acdbGetObjectId].")); return; } // abrir el objeto para escritura if (acdbOpenObject(pSecciones, ID, /*AcDb::kForRead*/ AcDb::kForWrite) != Acad::eOk) { acedSSFree(ss); acdbFail(_T("\nError al abrir el Objeto CPLEDERCrossSections [acdbOpenObject].")); return ; } // chequear el tipo de objeto if (pSecciones->isKindOf(CPLEDERCrossSections::desc()) != Adesk::kTrue) { pSecciones->close(); acedSSFree(ss); acdbFail(_T("\nError Objeto CPLEDERCrossSections ")); return; } double Id_Seccion; // Tomar el ID para comparar pSecciones->IdCrossSections(Id_Seccion); // Si procede, actualizar los datos de la S.T. if (Id_Seccion == IdST) { pSecciones->SetTipoMaterial(Material); pSecciones->SetCoeficienteProb(CoefProb); pSecciones->SetCoeficienteMaterial(CoefMaterial); } // if pSecciones->close(); } // for i acedSSFree(ss); acutPrintf(_T("\n....Datos modificados en forma Exitosa....")); return; }  void CPLEDERSocavacionGeneralDlg::OnKillfocusComboSOCId() { double Id_ST; // Obtener el valor del combo seleccionado int nIndex = m_Combo_SOCId.GetCurSel(); m_Combo_SOCId.GetLBText(nIndex,m_SOCId); Id_ST = _wtof(m_SOCId); // Realizar un Zoom a la sección transversal STSOC.ZoomCrossSections(Id_ST); int Material, CoefProb; double // Tipo de material, Cohesivo = 0, No Cohesivo = 1. // Coeficiente de probabilidad de gasto. (Posición del combo) CoefMaterial; // Peso específico ó diámetro medio del material de fondo. if (STSOC.GetIdCrossSectionsAttributesSocavacion(Id_ST, &Material, &CoefProb, &CoefMaterial) != RTNORM) { acutPrintf(_T("\nERROR PLEDER:[GetIdCrossSectionsAttributesSocavacion]")); return; } // Inserta el valor del material en la ventana if(Material == 1) // Material No cohesivo { // Activar radio m_Button_MaterialNoCoh.SetCheck(1); m_Button_MaterialCoh.SetCheck(0); // Activa y desactiva las casillas de la ventana m_Edit_SOCPes.EnableWindow(0); m_Edit_SOCDm.EnableWindow(1); m_SOCDm.Format(_T("%g"), CoefMaterial); m_Edit_SOCDm.SetWindowText(m_SOCDm); } else // Material cohesivo { // Activar radio m_Button_MaterialNoCoh.SetCheck(0); m_Button_MaterialCoh.SetCheck(1); // Activa y desactiva las casillas de la ventana m_Edit_SOCPes.EnableWindow(1); m_Edit_SOCDm.EnableWindow(0); m_SOCPes.Format(_T("%g"), CoefMaterial); m_Edit_SOCPes.SetWindowText(m_SOCPes); } // Activa el combo, en la posición indicada. m_Combo_SOCProbg.SetCurSel(CoefProb); OnKillfocusComboSOCProbg(); } void CPLEDERSocavacionGeneralDlg::OnKillfocusComboSOCProbg() { switch (m_Combo_SOCProbg.GetCurSel()) { 327 case 0: { m_Edit_SOCCoef.SetWindowText(_T("0.77")); break; } case 1: { m_Edit_SOCCoef.SetWindowText(_T("0.82")); break; } case 2: { m_Edit_SOCCoef.SetWindowText(_T("0.86")); break; } case 3: { m_Edit_SOCCoef.SetWindowText(_T("0.90")); break; } case 4: { m_Edit_SOCCoef.SetWindowText(_T("0.94")); break; } case 5: { m_Edit_SOCCoef.SetWindowText(_T("0.97")); break; } case 6: { m_Edit_SOCCoef.SetWindowText(_T("1.00")); break; } case 7: { m_Edit_SOCCoef.SetWindowText(_T("1.03")); break; } case 8: { m_Edit_SOCCoef.SetWindowText(_T("1.05")); break; } case 9: { m_Edit_SOCCoef.SetWindowText(_T("1.07")); break; } default: acutPrintf(_T("\nFuera de Rango")); } //switch (m_Combo_SOCProbg.GetCurSel()) }